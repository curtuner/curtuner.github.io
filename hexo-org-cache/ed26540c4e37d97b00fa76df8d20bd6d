{"md5":"04efe60f9643073d86bf8ce9f6e91f98","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 前言</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n基于事件异步IO框架中，调度的单位是事件处理函数。基于协程的异步IO框架的调度单位是协程。而一个协程的往往可以包含多个事件处理函数。这里就可以粗略看出，使用协程降低了一定复杂度（至少不需要设置那么多事件）。\n目前，Python中的协程的实现有很多种，包括：\n</p>\n<ol class=\"org-ol\">\n<li>基于greenlet的协程，使用C实现协程调度。\n</li>\n<li>Python 3.5开始支持的原生async方法。\n</li>\n<li>基于生成器的协程，如Python3.5之前的asyncio和Tornado。\n</li>\n</ol>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> 协程定义</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\nDonald Knuth是一个子例程是协程的特殊情况。子例程一般被称为函数，只有一个入口（函数调用）和一个出口（一般是return），而协程是可以有多个入口点的。\n</p>\n</div>\n<div id=\"outline-container-sec-2-1\" class=\"outline-3\">\n<h3 id=\"sec-2-1\"><span class=\"section-number-3\">2.1</span> 定义</h3>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 生成器的实现</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n<p>\n生成器可以把控制权交给调用者，所以如果作为一个协程，需要有一个程序能不断分配控制权，作为一个生成器，一大问题是，需要有一个程序来将控制权交回给它。这就是顶调度 <b>子例程</b> ，由于是子例程，所以不存在控制权无法重新得到的问题。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> Future回调的模式</h2>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> <span class=\"todo TODO\">TODO</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n</div><div id=\"outline-container-sec-5-1\" class=\"outline-3\">\n<h3 id=\"sec-5-1\"><span class=\"section-number-3\">5.1</span> <span class=\"todo TODO\">TODO</span> Tornado和asyncio的协程通信模式</h3>\n<div class=\"outline-text-3\" id=\"text-5-1\">\n<p>\n这里协程其实涉及到两个：\n</p>\n<ol class=\"org-ol\">\n<li>Tornado和Python 3.5之前的协程。\n</li>\n<li>Python 3.5之后的协程。\n</li>\n</ol>\n\n<p>\n所幸两者的实现原理是一样的。都是基于生成器来实现的，Python 3.5本质上是使用了内部生成器来实现的。协程是通过程序自定义的调度器来进行调度的，以及一个通信机制。这里都是使用Promise-Future通信模型。\nPromise-Future通信模型的基本思路是\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5-2\" class=\"outline-3\">\n<h3 id=\"sec-5-2\"><span class=\"section-number-3\">5.2</span> <span class=\"todo TODO\">TODO</span> yield from的语义</h3>\n<div class=\"outline-text-3\" id=\"text-5-2\">\n<p>\nyield from 可以获取一个协程（生成器最终的返回值），生成器最终会返回一个异常StopIteration，这个异常含有value。就是这个协程的最终返回值。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5-3\" class=\"outline-3\">\n<h3 id=\"sec-5-3\"><span class=\"section-number-3\">5.3</span> <span class=\"todo TODO\">TODO</span> Tornado的协程实现</h3>\n<div class=\"outline-text-3\" id=\"text-5-3\">\n<p>\nfuture线程间同步模型，\n</p>\n</div>\n</div>\n</div>\n\nLast Updated 2018-03-04 日 03:01.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
