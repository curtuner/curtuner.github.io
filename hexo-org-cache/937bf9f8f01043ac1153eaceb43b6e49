{"md5":"29c31abd7197d7646b20aec9926c7108","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 前言</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n上班在车上无聊就看了一下《C++语言的设计和演化》，虽说目前主要用C，但看一下C++之父对编程语言（主要对C和C++）的思考还是大有裨益的。一旦语言要编译成机器码，就不得不了解一些底层的惯例。这些东西其实在学习C语言的过程中经常会接触到。C语言程序的链接约定估计是在C语言出现之前就有了雏形。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> 链接模型</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\nC语言是使用分别编译之后再链接的方式来生成可执行文件的，这算是历史传统。单独编译一个文件时为了保证之后能域其他模块顺利链接，必须要有其他模块的信息，一般我们把这些信息写在头文件中。C语言和C++的兼容指的是链接兼容的，即它们的链接模型是相同的。所谓的二进制兼容大约是在这个层次了。有了链接的兼容，代码的兼容是否重要又是另一回事了。最终的结果是C++其实早就和C在源码级别上不兼容了，一般所说的兼容其实是链接模型兼容。但其实对于符号的命名规范还是有所不同。\nC语言的类型系统很比较弱，尤其到了链接的时候就能发现，因为C语言的符号修饰规则并不包含类型信息。而对于包含了符号信息的C++来说，链接时出现函数类型不匹配时，可以报未定义的引用这个错误，另一方面，这也是实现重载的手段。方法很简单，可以C语言从大规模使用开始就注定了不能这样改进了。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 预处理器（Cpp）</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-sec-3-1\" class=\"outline-3\">\n<h3 id=\"sec-3-1\"><span class=\"section-number-3\">3.1</span> 前言</h3>\n<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\n由于历史原因，C语言对于名称的处理一直不好，这个从链接的过程就可以看出了，加上C语言是弱类型，这个已经很麻烦了。平时编程的时候要小心符号的污染问题。预处理器的做法又进一步减弱了我们把握符号的能力。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3-2\" class=\"outline-3\">\n<h3 id=\"sec-3-2\"><span class=\"section-number-3\">3.2</span> #include</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\n这是预处理器的指示字，以前我一直觉得这是个比较智能的指令，可以根据文件使用的函数到相关文件中查找定义再插入生成.i文件。然而其实它只是单纯从其他文件里复制源文件正文，并且是整个文件复制。这样的结果是会给编译其前端带来巨大的负担。要体会一下，可以用指令生成.i文件来查看：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -E -o test.i test.c</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n多#include几个文件就千行了，考虑到很多头文件都被重复引用，代价还是比较大的。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3-3\" class=\"outline-3\">\n<h3 id=\"sec-3-3\"><span class=\"section-number-3\">3.3</span> #define（可部分替代）</h3>\n<div class=\"outline-text-3\" id=\"text-3-3\">\n<p>\n这个指示字可以进行简单的文本替换。比较常用的是定义开子程序，和定义常量。目前这两个功能已经可以被const，enum和inline大部分替代。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3-4\" class=\"outline-3\">\n<h3 id=\"sec-3-4\"><span class=\"section-number-3\">3.4</span> #ifdef</h3>\n<div class=\"outline-text-3\" id=\"text-3-4\">\n<p>\n目前还是不可缺的功能：\n</p>\n<ul class=\"org-ul\">\n<li>版本控制\n</li>\n<li>注释代码（可以提供嵌套的注释）\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-3-5\" class=\"outline-3\">\n<h3 id=\"sec-3-5\"><span class=\"section-number-3\">3.5</span> #progma</h3>\n<div class=\"outline-text-3\" id=\"text-3-5\">\n<ul class=\"org-ul\">\n<li>布局控制\n</li>\n<li>为编译程序提供非常规的控制流信息\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> 关于静态分配内存</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\nC语言用于存放结构化数据的内存大体分成了三种：栈、数据段、堆。我过去编程的时候比较在意堆和栈的内存使用，而忽略了数据段这个在初始化时就分配的内存，相比其他两个，合理使用数据段能带来更多的好处。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 语法</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a; <span class=\"comment\">// 默认类型是int</span></span><br><span class=\"line\">f(); <span class=\"comment\">// 默认返回类型是int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>{</span><br><span class=\"line\">    a =<span class=\"number\">5</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n这样的程序居然编译过了，只有一个警告。第一次知道C\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-6\" class=\"outline-2\">\n<h2 id=\"sec-6\"><span class=\"section-number-2\">6</span> 关于使用goto语言的要点</h2>\n<div class=\"outline-text-2\" id=\"text-6\">\n</div><div id=\"outline-container-sec-6-1\" class=\"outline-3\">\n<h3 id=\"sec-6-1\"><span class=\"section-number-3\">6.1</span> 分析状态来消去goto</h3>\n<div class=\"outline-text-3\" id=\"text-6-1\">\n<p>\n内核以及系统编程总是能看到goto语句的实现，类似资源释放这种事情暂时还没找到更好的办法。但是偶然在《Unix网络编程 卷一》看到一段代码：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"unp.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">str_echo</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[MAXLINE];</span><br><span class=\"line\">again:</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((n = read(sockfd, buf, MAXLINE)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\tWriten(sockfd, buf, n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> &amp;&amp; errno == EINTR)</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> again;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\terr_sys(<span class=\"string\">\"str_echo: read error\"</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n这里使用了goto跳转，其使用实在是没必要地增加了代码的阅读难度。由于能力所限，还是用自动机来将代码理清。个人目前对于while的理解还是如下图：\n</p>\n\n<div class=\"figure\">\n<p><img src=\"关于C语言问题和改进/while.png\" alt=\"while.png\">\n</p>\n</div>\n\n<p>\n这是一个比较笼统的图，表示不断重复一个循环体，直到达到终止条件，所以使用while的关键是要把终止条件描述完整。前面之所以要用goto，是因为上面哪个while不能完整描述终止条件。去掉goto的做法是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"unp.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">str_echo</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">ssize_t</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[MAXLINE];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((n = read(sockfd, buf, MAXLINE)) != <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t    Writen(sockfd, buf, n);</span><br><span class=\"line\">\t} <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> &amp;&amp; errno != EINTR) {</span><br><span class=\"line\">\t    err_sys(<span class=\"string\">\"str_echo: read error\"</span>);</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n这样就好看多了。当然，这样还有一个问题，对于C语言编程，我一直希望 <b>计算</b> 和 <b>写</b> 操作可以比较明显的分开。可惜在while中这种在判断语句中还是有点让人迷惑，毕竟判断语句有副作用，这不算是好的判断语句，虽然在C语言里不用太在意就是了。我换了一种形式：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"unp.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">str_echo</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[MAXLINE];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">ssize_t</span> n = read(sockfd, buf, MAXLINE); n; n = read(sockfd, buf, MAXLINE)) {</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t    Writen(sockfd, buf, n);</span><br><span class=\"line\">\t} <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span> &amp;&amp; errno != EINTR) {</span><br><span class=\"line\">\t    err_sys(<span class=\"string\">\"str_echo: read error\"</span>);</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n这样就把判断和副作用分开了，这个算是for的一个作用。至少个人觉得代码美观了不少。需要额外注意的是代码的对于异常处理，我的理解是不把它当作执行流的一部分。\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-7\" class=\"outline-2\">\n<h2 id=\"sec-7\"><span class=\"section-number-2\">7</span> <span class=\"todo TODO\">TODO</span> 关于减少使用#define的问题</h2>\n<div class=\"outline-text-2\" id=\"text-7\">\n<p>\n使用宏定义的问题在于我们定义的名字是无法被编译器看到的，这意味这我们和编译器的交流过程存在信息的损失，这对我们报错会造成很大的影响\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-8\" class=\"outline-2\">\n<h2 id=\"sec-8\"><span class=\"section-number-2\">8</span> 阅读源码中学习到的一些小技巧</h2>\n<div class=\"outline-text-2\" id=\"text-8\">\n<ul class=\"org-ul\">\n<li>使用基本数据类型或者系统数据类型的别名，别名的作用是提供了多一层抽象。这样可以提高可移植性，如可能会域到不同的系统应该使用不同的类型来提高效率的情况。\n</li>\n<li>有时我们用一个结构体来表示不同的类型，一般情况下结构体会变得十分大，所以我们需要对公共的部分进行抽象。设定宏来强调并快速访问\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-9\" class=\"outline-2\">\n<h2 id=\"sec-9\"><span class=\"section-number-2\">9</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-9\">\n<ul class=\"org-ul\">\n<li>相比之下，Python、Java、Lua这类语言代表是有自己完整系统和环境（虚拟机）的语言，这样限制了语言的角色，而不必去做它不擅长的事情。\n</li>\n<li>相比之下llvm是如何做到的？\n</li>\n<li>类型检查发生编译器运行过程中，然而C语言本身是弱类型，所以可能使用const，enum，inline来替代#define的动力没那么大？\n</li>\n<li>当分支不会在合并时，最好记得使用else，不带else的if应该暗示它的分支最终会合并，即最终没有分支的时候可以。对于continue而言分支其实最终会合并，所以可以不是用else\n</li>\n<li>编程中对于类型其别名，本身是一种抽象。主要为了应对对于不同平台上的不同类型，或者之后要增大类型的情况，\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-10\" class=\"outline-2\">\n<h2 id=\"sec-10\"><span class=\"section-number-2\">10</span> 参考</h2>\n<div class=\"outline-text-2\" id=\"text-10\">\n<ul class=\"org-ul\">\n<li>《C++语言的设计和演化》\n</li>\n<li>《Effective C++》\n</li>\n</ul>\n</div>\n</div>\n\nLast Updated 2017-09-19 二 09:36.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
