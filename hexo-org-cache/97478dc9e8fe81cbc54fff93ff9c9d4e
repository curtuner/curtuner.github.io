{"md5":"68a3286fe5fef56b3bc9563001cdcf14","content":"\n\n\n<div id=\"outline-container-org9241381\" class=\"outline-2\">\n<h2 id=\"org9241381\"><span class=\"section-number-2\">1</span> 前言</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nxv6的一个麻烦的点是它支持多核处理器，所以代码要比一般的简单的操作系统项目要麻烦。\n</p>\n</div>\n</div>\n<div id=\"outline-container-orge6dd222\" class=\"outline-2\">\n<h2 id=\"orge6dd222\"><span class=\"section-number-2\">2</span> xv6源码获取</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<div class=\"org-src-container\">\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/mit-pdos/xv6-public.git xv6</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-org4b5e522\" class=\"outline-2\">\n<h2 id=\"org4b5e522\"><span class=\"section-number-2\">3</span> xv6源码结构</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-orgfee8871\" class=\"outline-3\">\n<h3 id=\"orgfee8871\"><span class=\"section-number-3\">3.1</span> 内核</h3>\n</div>\n<div id=\"outline-container-org0c213f2\" class=\"outline-3\">\n<h3 id=\"org0c213f2\"><span class=\"section-number-3\">3.2</span> 用户态程序</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<ul class=\"org-ul\">\n<li>cat.c</li>\n<li>date.c</li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"outline-container-org05629c7\" class=\"outline-2\">\n<h2 id=\"org05629c7\"><span class=\"section-number-2\">4</span> 物理地址空间</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\n虽然有页机制掩盖了物理地址，但是物理地址也不是杂乱无章的。物理地址按低地址到高地址分成三个部分：\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgf3afb03\" class=\"outline-2\">\n<h2 id=\"orgf3afb03\"><span class=\"section-number-2\">5</span> 自旋锁的实现</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n<p>\n使用一个锁变量，不同的运行实体通过读取该变量来判断是否使用某个资源。看描述就知道这个锁变量满足了引起竞态条件的所有条件，一般的解决方案是使用x86提供的特殊指令xchg：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">static inline uint</span><br><span class=\"line\">xchg(volatile uint *addr, uint newval)</span><br><span class=\"line\">{</span><br><span class=\"line\">  uint result;</span><br><span class=\"line\"></span><br><span class=\"line\">  // The + in \"+m\" denotes a read-modify-write operand.</span><br><span class=\"line\">  asm volatile(\"lock; xchgl %0, %1\" :</span><br><span class=\"line\">               \"+m\" (*addr), \"=a\" (result) :</span><br><span class=\"line\">               \"1\" (newval) :</span><br><span class=\"line\">               \"cc\");</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\nlock前缀保证了多处理器系统中的某个处理器能独立使用共享内存，这里lock前缀不是必要的，xchg默认会设置lock信号。由于锁变量只是内存，所以主要的难点在于获取锁和释放锁的过程。这里先观察xv6中的实现：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Acquire the lock.</span></span><br><span class=\"line\"><span class=\"comment\">// Loops (spins) until the lock is acquired.</span></span><br><span class=\"line\"><span class=\"comment\">// Holding a lock for a long time may cause</span></span><br><span class=\"line\"><span class=\"comment\">// other CPUs to waste time spinning to acquire it.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">struct</span> spinlock *lk)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">  pushcli(); <span class=\"comment\">// disable interrupts to avoid deadlock.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(holding(lk))</span><br><span class=\"line\">    panic(<span class=\"string\">\"acquire\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The xchg is atomic.</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(xchg(&amp;amp;lk-&amp;gt;locked, <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class=\"line\">  <span class=\"comment\">// past this point, to ensure that the critical section's memory</span></span><br><span class=\"line\">  <span class=\"comment\">// references happen after the lock is acquired.</span></span><br><span class=\"line\">  __sync_synchronize();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Record info about lock acquisition for debugging.</span></span><br><span class=\"line\">  lk-&amp;gt;cpu = cpu;</span><br><span class=\"line\">  getcallerpcs(&amp;amp;lk, lk-&amp;gt;pcs);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</div>\n<p>\n自旋锁采用的是忙等待的策略来获得锁，while的那一行是主要的逻辑。其他的暂时不去理会。释放锁只有写入的操作，所以不需要考虑太多，直接用mov写入一个0即可。自旋锁的自旋描述的是获取锁的控制流不断试探的行为。\n</p>\n</div>\n</div>\n<div id=\"outline-container-org14da802\" class=\"outline-2\">\n<h2 id=\"org14da802\"><span class=\"section-number-2\">6</span> <span class=\"todo TODO\">TODO</span> 多核CPU的理解</h2>\n</div>\n<div id=\"outline-container-org22b8a57\" class=\"outline-2\">\n<h2 id=\"org22b8a57\"><span class=\"section-number-2\">7</span> 内核写入内存后的启动流程</h2>\n<div class=\"outline-text-2\" id=\"text-7\">\n</div><div id=\"outline-container-orgf3247d7\" class=\"outline-3\">\n<h3 id=\"orgf3247d7\"><span class=\"section-number-3\">7.1</span> 开启分页机制</h3>\n<div class=\"outline-text-3\" id=\"text-7-1\">\n<p>\n分页机制是操作系统，\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-orga2e7f20\" class=\"outline-2\">\n<h2 id=\"orga2e7f20\"><span class=\"section-number-2\">8</span> 不同模块的分析</h2>\n<div class=\"outline-text-2\" id=\"text-8\">\n</div><div id=\"outline-container-orge32369e\" class=\"outline-3\">\n<h3 id=\"orge32369e\"><span class=\"section-number-3\">8.1</span> 代码</h3>\n<div class=\"outline-text-3\" id=\"text-8-1\">\n<ul class=\"org-ul\">\n<li>bootasm.S</li>\n<li>bootmain.c</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-orge02f1a8\" class=\"outline-3\">\n<h3 id=\"orge02f1a8\"><span class=\"section-number-3\">8.2</span> 系统初始化</h3>\n<div class=\"outline-text-3\" id=\"text-8-2\">\n</div><div id=\"outline-container-orgef8901f\" class=\"outline-4\">\n<h4 id=\"orgef8901f\"><span class=\"section-number-4\">8.2.1</span> BIOS</h4>\n<div class=\"outline-text-4\" id=\"text-8-2-1\">\n<p>\n计算机上电之后，第一条指令执行ROM中的BIOS，进行硬件自检，并读取第一个扇区，将其放入0x7c00处，一般情况下这就是bootloader。\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgc09e294\" class=\"outline-4\">\n<h4 id=\"orgc09e294\"><span class=\"section-number-4\">8.2.2</span> 设置A20地址线</h4>\n</div>\n<div id=\"outline-container-orgdc60144\" class=\"outline-4\">\n<h4 id=\"orgdc60144\"><span class=\"section-number-4\">8.2.3</span> 内核的初始化</h4>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org23ac782\" class=\"outline-2\">\n<h2 id=\"org23ac782\"><span class=\"section-number-2\">9</span> 编译结果和调试</h2>\n<div class=\"outline-text-2\" id=\"text-9\">\n<p>\n我使用的是qemu来调试内核代码，所以编译的指令是：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">make qemu</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n观察xv6的Makefile可以看到：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"constant\">QEMUOPTS</span> = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp <span class=\"variable\">$(CPUS)</span> -m 512 <span class=\"variable\">$(QEMUEXTRA)</span></span><br><span class=\"line\">$(QEMU) -serial mon:stdio $(QEMUOPTS)a</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n所以我们要生成的文件是fs.img和xv6.img，一个是根文件系统，而另一个是内核镜像。先讨论内核镜像，即先分析xv6.img\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">xv6.img: bootblock kernel fs.img</span><br><span class=\"line\">        dd if=/dev/zero of=xv6.img count=10000</span><br><span class=\"line\">        dd if=bootblock of=xv6.img conv=notrunc</span><br><span class=\"line\">        dd if=kernel of=xv6.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n第一条指令相当有建立一个磁盘，大小是5120000字节。第二条指令是将bootblock写入虚拟磁盘的第一个扇区中。第三条指令代表跳过一个扇区后写入内核文件。\nxv6是直接使用第一个扇区的程序作为bootloader的：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootblock: bootasm.S bootmain.c</span><br><span class=\"line\">        $(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class=\"line\">        $(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class=\"line\">        $(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class=\"line\">        $(OBJDUMP) -S bootblock.o &amp;gt; bootblock.asm</span><br><span class=\"line\">        $(OBJCOPY) -S -O binary -j .text bootblock.o bootblock</span><br><span class=\"line\">        ./sign.pl bootblock</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n从以上指令可以看出bootasm.S和bootmain共同定义了bootloader。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-orgb949f9e\" class=\"outline-2\">\n<h2 id=\"orgb949f9e\"><span class=\"section-number-2\">10</span> swtch分析</h2>\n<div class=\"outline-text-2\" id=\"text-10\">\n<p>\nswtch是切换线程时必须使用的程序：\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Context switch&#10;#&#10;#   void swtch(struct context **old, struct context *new);&#10;# &#10;# Save current register context in old&#10;# and then load register context from new.&#10;&#10;.globl swtch&#10;swtch:&#10;  movl 4(%esp), %eax&#10;  movl 8(%esp), %edx&#10;&#10;  # Save old callee-save registers&#10;  pushl %ebp&#10;  pushl %ebx&#10;  pushl %esi&#10;  pushl %edi&#10;&#10;  # Switch stacks&#10;  movl %esp, (%eax)&#10;  movl %edx, %esp&#10;&#10;  # Load new callee-save registers&#10;  popl %edi&#10;  popl %esi&#10;  popl %ebx&#10;  popl %ebp&#10;  ret</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n该函数是内核线程调用的，用于保存内核线程自身的上下文并切换到另一个内核线程。这个函数可以和一般的函数的汇编代码对比，可以发现这个汇编程序的一开始并没有保存%ebp的值来建立一个帧，原因是这个函数并不需要返回，在保存了内核线程的%eip和被调用者保存寄存器后就可以切换到另一个程序了，ret时返回地址已经和调用时不同了。通过改变%esp来改变返回地址，这算是一个对初学者来说比较巧妙的做法。这个程序页暗示，内核线程的栈在切换后是一直保留在内存中的。swtch的第一个参数的含义也就明了了，是一个proc实例的context字段的地址。context其实是内核线程栈的栈顶地址\n</p>\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> context {</span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">enum</span> procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Per-process state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> proc {</span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"keyword\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> procstate state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> proc *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> trapframe *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> context *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> file *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> inode *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-org2111d37\" class=\"outline-2\">\n<h2 id=\"org2111d37\"><span class=\"section-number-2\">11</span> 调度</h2>\n<div class=\"outline-text-2\" id=\"text-11\">\n<p>\n多核CPU共享一个进程表，进程表可变，且读写是分开的，所以会造成竞争条件。这里一般的想法是用代价较小的锁，要不可能就要不断生成新的进程表了。\n</p>\n</div>\n</div>\n<div id=\"outline-container-org75df295\" class=\"outline-2\">\n<h2 id=\"org75df295\"><span class=\"section-number-2\">12</span> 进程调度</h2>\n<div class=\"outline-text-2\" id=\"text-12\">\n<p>\n进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供独立的内存空间和CPU。对于进程间的通信看作是不同机器的通信其实是最自然的一种做法，这也是进程间通信使用。\n通常我们为进程提供一个独占处理器的假象，而处理器的数目其实是有限的，所以这里同内存一样也是使用有限的资源来模拟大量的资源的一种做法。这里的资源有限不是处理器速度的有限，而是每个处理器核心一次只能处理一个控制流。进程独占处理器的抽象其实只要保证它的行为和中断运行的行为效果是相同的即可。所以这其实页取决域进程的定义，不可过于爆漏资源。一个进程独占处理器和内存资源主要通过进程调度器、内存分配其、页表来实现的。\n实现处理器的多路复用有几个难点：\n</p>\n<ol class=\"org-ol\">\n<li>普通的上下文切换</li>\n<li>上下文切换如何透明化</li>\n<li>如何避免多核处理器的切换问题</li>\n<li>如何释放占用的内存和资源</li>\n</ol>\n<p>\n另外，进程的协作可以降低软件编写的复杂度。所以IPC机制的实现也十分重要。\n</p>\n</div>\n</div>\n<div id=\"outline-container-org52ff3ae\" class=\"outline-2\">\n<h2 id=\"org52ff3ae\"><span class=\"section-number-2\">13</span> <span class=\"todo TODO\">TODO</span> xv6和Linux的进程定义的区别</h2>\n<div class=\"outline-text-2\" id=\"text-13\">\n<div class=\"org-src-container\">\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> proc {</span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"keyword\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table </span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> procstate state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> proc *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> trapframe *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> context *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> file *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> inode *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n需要对所有进程进行处理时需要考虑\n首先是进程标识，进程名、pid，用于定位进程，kill 一个进程时可以通过进程来。构成集合的结构，一般的集合数据结构，parent 字段代表这是一个树形结构或者链表型结构。进程的运行信息字段包括sz，pgdir,kstack, state tf context\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org89cea95\" class=\"outline-2\">\n<h2 id=\"org89cea95\"><span class=\"section-number-2\">14</span> 思考</h2>\n<div class=\"outline-text-2\" id=\"text-14\">\n<ul class=\"org-ul\">\n<li>Linux 有很多复杂的结构体，但实际上处理结构体的复杂度未必有多高，每个处理程序可能只是处理有限的字段，对大的处理复杂度可以根据最复杂的处理程序而定。</li>\n<li>进程调度需要多少字段</li>\n<li>这里处理集合的算法又是一个类别</li>\n<li>如何表示集合，有哪些集合数据结构，</li>\n<li>段寄存器的指是否是不变的</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-org96b297f\" class=\"outline-2\">\n<h2 id=\"org96b297f\"><span class=\"section-number-2\">15</span> 文件系统</h2>\n<div class=\"outline-text-2\" id=\"text-15\">\n<p>\n设备驱动是文件系统的实现\n</p>\n</div>\n<div id=\"outline-container-org2811009\" class=\"outline-3\">\n<h3 id=\"org2811009\"><span class=\"section-number-3\">15.1</span> xv6文件系统解决的问题</h3>\n<div class=\"outline-text-3\" id=\"text-15-1\">\n<p>\n这里先考虑磁盘文件系统，Unix的文件系统接口其实基本固定，所以没有什么需要自己创造的。\n</p>\n<ul class=\"org-ul\">\n<li>如何在磁盘数据结构的基础上构建unix文件系统</li>\n<li>崩溃回复</li>\n<li>同步</li>\n<li>缓存</li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"outline-container-org1aa326e\" class=\"outline-2\">\n<h2 id=\"org1aa326e\"><span class=\"section-number-2\">16</span> 磁盘高速缓存</h2>\n<div class=\"outline-text-2\" id=\"text-16\">\n<p>\n磁盘高速缓机制存把磁盘上的一些数据保留在RAM中\n</p>\n</div>\n</div>\n<div id=\"outline-container-org1cb52a4\" class=\"outline-2\">\n<h2 id=\"org1cb52a4\"><span class=\"section-number-2\">17</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-17\">\n<ul class=\"org-ul\">\n<li>x86提供了分页和分段机制，所以地址有三种类型，虚拟地址、线性地址和物理地址。在xv6中，除了每个CPU独立的数据有非0的基址意外，其他的如内核数据段、代码段一般都是从基址0开始的，这样大大简化的地址操作的程序的编程。所以一般我们只需要考虑分页的地址映射而已。</li>\n<li>加载内核时是没有loader的所以我们要自己利用elf格式手动加载内核。</li>\n<li>进程的地址空间的控制并不再进程的数据结构中，而是在每次切换进程时，改变cr0的物理地址。</li>\n<li>分页机制下，物理地址空间被分为一个个页帧，所以如果只是索引叶帧的话只需要20位地址而已。cr0指向页目录表的基址，页目录每一项用20位指向一个子页表，由于一个页目录项指向的页表只有4k所以也是使用20位就可以了，其他位可以作为控制位。</li>\n<li>所有CPU核心共用一个进程表</li>\n<li>allocproc在进程表中找到一个标记为UNUSED的槽位</li>\n<li>进程有内核线程的用户线程，每个线程要有栈</li>\n<li>看linux源码时要注意组成内核的部分一般是不会出现在根文件系统中的，也就是自己要理清内核和通常意义上的操作系统的区别。</li>\n<li>进程表是用于调度一个计算机中所有的进程，所以用一个表统一管理</li>\n<li>进程的线程一般是交替使用内核栈和用户栈的</li>\n<li>第一个程序是操作系统内核来运行的，但是还是使用了对于操作系统来说比较统一的方法。</li>\n<li>在x64中一般是先call压如pc的返回地址，再由被调用者管理栈帧。但这其实也不是必须的，实际上调用者管理也是可以的，当然我觉得还是前者的汇编代码好看一点。当然参数还是调用者来管理</li>\n<li>x64之后寄存器多了，函数参数可以直接保存在寄存器里了</li>\n<li>x86中的leave是一个语法糖，被调用者用于栈帧管理。等价于movl %ebp %esp; popl %ebp</li>\n<li>x86中调用者保存寄存器是被过程认为是易失，所以被调用者可以直接使用，如果要要使用则要求调用者保存。被调用者保存的寄存器包括ebx, edi和esi，其中esp和ebp是必须要维护的。</li>\n<li>Unix的一大优点是大部分资源都可以用文件来表示</li>\n<li>文件操作是对设备操作的组织和抽象，设备操作则是文件操作最终实现。</li>\n<li>层次的划分取决于使用了使用了哪些元语，依赖哪些实现</li>\n<li>抽象的结果是我们可以忽略哪些东西了</li>\n<li>传统的设备文件包括块设备和字符设备，之后设备变得越来越复杂，像网络接口这种不能确定属于那一类的设备就被独立出来了。所以一般区分设备包括块设备，字符设备和网络接口。</li>\n<li>由于设备的多样性，设备驱动是一个需要正本专著讨论的大课题</li>\n<li>PCI已经成为通用的标准总线，</li>\n</ul>\n</div>\n<div id=\"outline-container-org4de0b41\" class=\"outline-3\">\n<h3 id=\"org4de0b41\"><span class=\"section-number-3\">17.1</span> 可安装模块（module）</h3>\n<div class=\"outline-text-3\" id=\"text-17-1\">\n<p>\nmoule可以在系统运行时动态安装和拆卸的内核软件，实际上它的作用不限于设备驱动\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgdba0c60\" class=\"outline-3\">\n<h3 id=\"orgdba0c60\"><span class=\"section-number-3\">17.2</span> 将内核频文件载入</h3>\n<div class=\"outline-text-3\" id=\"text-17-2\">\n<p>\nC函数需要使用栈，所以bootloader先用0x7c00作为栈的开始，\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgb21d299\" class=\"outline-3\">\n<h3 id=\"orgb21d299\"><span class=\"section-number-3\">17.3</span> bootloader的理解</h3>\n<div class=\"outline-text-3\" id=\"text-17-3\">\n<p>\nIntel的CPU一开始运行在实模式之上，为了进入保护模式我们要在实模式中构建保护模式的运行环境，最后通过一个jmp正式进入保护模式。内核运行在保护模式中，页机制对于保护模式而言不是必须的，第一步先要启动的是段机制。\n</p>\n</div>\n</div>\n<div id=\"outline-container-org5ae9f69\" class=\"outline-3\">\n<h3 id=\"org5ae9f69\"><span class=\"section-number-3\">17.4</span> <span class=\"todo TODO\">TODO</span> i386的内存管理</h3>\n<div class=\"outline-text-3\" id=\"text-17-4\">\n<p>\nCPU对于内存管理其实设定了不少,\n</p>\n</div>\n</div>\n<div id=\"outline-container-org389906f\" class=\"outline-3\">\n<h3 id=\"org389906f\"><span class=\"section-number-3\">17.5</span> 虚拟地址空间</h3>\n<div class=\"outline-text-3\" id=\"text-17-5\">\n<p>\n虚拟地址空间是二维的，可以包含最多\n</p>\n</div>\n</div>\n<div id=\"outline-container-orgdc74eb1\" class=\"outline-3\">\n<h3 id=\"orgdc74eb1\"><span class=\"section-number-3\">17.6</span> 段寄存器</h3>\n<div class=\"outline-text-3\" id=\"text-17-6\">\n<p>\n段寄存器有6个，一个程序一般至少需要3个CS、DS和SS，还有三个辅助的数据段寄存器ES、FS、GS。另外段寄存器还包含不可见的缓存来保存段描述符。对于描述符表做改动后立刻重新加载6个段寄存器\n</p>\n</div>\n</div>\n<div id=\"outline-container-org91667bf\" class=\"outline-3\">\n<h3 id=\"org91667bf\"><span class=\"section-number-3\">17.7</span> 利用有限的资源模拟无限的资源</h3>\n</div>\n<div id=\"outline-container-org6318699\" class=\"outline-3\">\n<h3 id=\"org6318699\"><span class=\"section-number-3\">17.8</span> types.h</h3>\n<div class=\"outline-text-3\" id=\"text-17-8\">\n<p>\n基本系统数据类型。\n</p>\n</div>\n</div>\n<div id=\"outline-container-org3d24e2e\" class=\"outline-3\">\n<h3 id=\"org3d24e2e\"><span class=\"section-number-3\">17.9</span> 如何操作磁盘</h3>\n</div>\n</div>\n<div id=\"outline-container-org605f001\" class=\"outline-2\">\n<h2 id=\"org605f001\"><span class=\"section-number-2\">18</span> 思考</h2>\n<div class=\"outline-text-2\" id=\"text-18\">\n<ul class=\"org-ul\">\n<li>复杂的顺序结构和复杂的逻辑结构</li>\n<li>操作系统最重要的是进程管理，内存管理，文件系统。一些操作系统（嵌入式）可能没有文件系统也可能没有进程管理，进程管理和文件系统必须至少有一个才能</li>\n<li>对于硬件如磁盘来说，有不少动作，但是这些动作的模式却不多，硬件抽象的目的在于提取所有的模式，保证其内容都是完全的</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-org1eecf51\" class=\"outline-2\">\n<h2 id=\"org1eecf51\"><span class=\"section-number-2\">19</span> 参考</h2>\n<div class=\"outline-text-2\" id=\"text-19\">\n<ul class=\"org-ul\">\n<li><a href=\"http://blog.csdn.net/qq_25426415/article/category/6684908\">xv6源码分析</a></li>\n<li><a href=\"http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html\">地址空间分布</a></li>\n<li>xv6文档</li>\n<li><a href=\"https://segmentfault.com/a/1190000008308764\">xv6中存储cpu和进程信息的技巧</a></li>\n</ul>\n</div>\n</div>\n\nLast Updated 2017-08-05 六 23:16.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.2.1 (<a href=\"http://orgmode.org\">Org</a> mode 9.0.8)\n"}
