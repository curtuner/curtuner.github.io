{"md5":"0fd399dae1c271a8b31a95de997378a2","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 概述</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nHA模块有三个模式，连接保护模式、双机热备模式和负载均衡模式。设备之间都需要通过VRRP报文来沟通，以期让具有同样能力的防火墙的共同协作来提高网络稳定性。每个设备独立但是又需要维护协作设备的信息，所以通过VRRP报文定期更新这些信息，监控所有设备的状态。稳定条件是指协作的设备能完成单个设备的所有功能，并且不会发生主备切换。一旦通过发现稳定条件被破坏，就协商出新的设备来替代故障的设备，以此达成新的稳定状态。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> HA保活机制</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\nHA依靠多台设备的冗余备份来抵抗异常状况。就实现而言，HA模块的几种模式都要求利用HA集群中不止一个设备的状态信息来支持决策。但由于设备是独立运行的，每个设备都无法直接把握整个HA集群中其他设备的状态信息。为了让相应的HA程序能运行在比较可靠的前条件之下，HA让每个设备通过心跳口发送包含必要状态信息的报文来显示自己的状态，使得各个设备可以实时更新或者维持HA集群的状态。\n所以如果要从实现上理解HA保活机制，大体上有三个问题：\n</p>\n<ol class=\"org-ol\">\n<li>有哪些状态信息需要维护？\n</li>\n<li>如何发送状态信息?\n</li>\n<li>如何更新状态信息？\n</li>\n</ol>\n<p>\n这三个问题对应到C语言实现上，就是数据结构以及其读写的方法。\n</p>\n</div>\n<div id=\"outline-container-sec-2-1\" class=\"outline-3\">\n<h3 id=\"sec-2-1\"><span class=\"section-number-3\">2.1</span> 需要维护的状态信息</h3>\n<div class=\"outline-text-3\" id=\"text-2-1\">\n<p>\n保活机制维护的对象是集群信息和VR（Virtual Route）信息，接收vrrp包的更新集群信息，在HA模块中，集群和vrid的数据结构如下：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> HA_MAX_CLUSTER_NUM <span class=\"number\">8</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ha_cluster_data</span><br><span class=\"line\">{</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> update_time;</span><br><span class=\"line\">\t__u32 ip;</span><br><span class=\"line\">\t__u32 error;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\t__u8 valid;</span><br><span class=\"line\">\t__u32 mode;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ha_cluster_data ha_cluster_info[HA_MAX_CLUSTER_NUM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> ha_vrid_data {</span><br><span class=\"line\">   __u8 valid;</span><br><span class=\"line\">   __u8 priority;</span><br><span class=\"line\">   __u8 preempt;</span><br><span class=\"line\">   __u8 state;</span><br><span class=\"line\">   __u8 vrid;</span><br><span class=\"line\">   __u32 ha_metric;</span><br><span class=\"line\">   __u8 monitor_devname[HA_MAX_MONITOR_DEV_SYNC][IFNAMSIZ];</span><br><span class=\"line\">   };</span><br><span class=\"line\"><span class=\"keyword\">struct</span> ha_vrid_data vrid_info[HA_MAX_CLUSTER_NUM][HA_MAX_VRID_NUM_SYNC];</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n需要注意的是本地的vrid信息并不会保留在vrid_info中，而是在tos_ha_config中。另外，虽然可以在更新完这些信息之后进行决策。但对效率而言没太大帮助，而且实际使用的算法并不要求完全的视图。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-2-2\" class=\"outline-3\">\n<h3 id=\"sec-2-2\"><span class=\"section-number-3\">2.2</span> 如何发送状态信息</h3>\n<div class=\"outline-text-3\" id=\"text-2-2\">\n<p>\n相比其VRRP协议定义的报文，HA模块的定义的报文只是使用了vrrp协议头而已，之后就是ha_vrid_data了：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> vrrphdr {   <span class=\"comment\">/* rfc2338.5.1 */</span></span><br><span class=\"line\">\t__u8               vers_type;      <span class=\"comment\">/* 0-3=type, 4-7=version */</span></span><br><span class=\"line\">\t__u8               vrid;           <span class=\"comment\">/* virtual router id */</span></span><br><span class=\"line\">\t__u8               priority;       <span class=\"comment\">/* router priority */</span></span><br><span class=\"line\">\t__u8               naddr;          <span class=\"comment\">/* address counter */</span></span><br><span class=\"line\">\t__u8               auth_type;      <span class=\"comment\">/* authentification type */</span></span><br><span class=\"line\">\t__u8               adver_int;      <span class=\"comment\">/* advertissement interval(in sec) */</span></span><br><span class=\"line\">\t__u16              chksum;         <span class=\"comment\">/* checksum (ip-like one) */</span></span><br><span class=\"line\">\t__u8               preempt;</span><br><span class=\"line\">\t__u8               mode;</span><br><span class=\"line\">\t__u8               state;</span><br><span class=\"line\">\t__u32      ha_metric;</span><br><span class=\"line\">\t__u32              ip;     </span><br><span class=\"line\">\t__u8               monitor_devname[HA_MAX_MONITOR_DEV_SYNC][IFNAMSIZ];</span><br><span class=\"line\">\t__u8               backup_monitor_status;<span class=\"comment\">//add for D3121</span></span><br><span class=\"line\"><span class=\"comment\">/* here &lt;naddr&gt; ip addresses */</span></span><br><span class=\"line\"><span class=\"comment\">/* here authentification infos */</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n<p>\nHA模块通过定时器vrrp_send_timer来发送心跳包，通过ha_vrrp_recv(struct tos_buff *tb)函数来处理心跳包。\n发送VRRP报文是通过会读取本机的信息来构造VRRP报文，相应的构造代码片段：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ha_vrrp_send</span><span class=\"params\">(__u8 vrid, <span class=\"keyword\">int</span> type)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/*省略*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*-----------------------------------------------------------------------*/</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vrrphd, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> vrrphdr));</span><br><span class=\"line\">    vrrphd-&gt;vers_type      = (Vms_down_timeRRP_VERSION &lt;&lt; <span class=\"number\">4</span>) | VRRP_PKT_ADVERT;</span><br><span class=\"line\">    vrrphd-&gt;vrid           = vrid;</span><br><span class=\"line\">    vrrphd-&gt;adver_int      = tos_ha_config.hello_interval;</span><br><span class=\"line\">    vrrphd-&gt;ip                     = heartbeat_ip_get(skb-&gt;dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vrid != NO_VRID)</span><br><span class=\"line\">\tvrrp_built_vrid(vrrphd);</span><br><span class=\"line\"></span><br><span class=\"line\">    vrrphd-&gt;chksum = vrrp_hd_csum( (__u16 *)vrrphd, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> vrrphdr), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*-----------------------------------------------------------------------*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*省略*/</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">vrrp_built_vrid</span><span class=\"params\">(<span class=\"keyword\">struct</span> vrrphdr *vrrphd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">\t__u8 vrid = vrrphd-&gt;vrid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvrrphd-&gt;priority   = vrid_monitor_interface_check(vrid);</span><br><span class=\"line\">\tvrrphd-&gt;preempt            = tos_ha_config.vrcfg[vrid].preempt;</span><br><span class=\"line\">\tvrrphd-&gt;ha_metric  = htonl(vrid_metric_get(vrid));</span><br><span class=\"line\">\tvrrphd-&gt;state              = tos_ha_config.vrcfg[vrid].state;</span><br><span class=\"line\">\tvrrphd-&gt;mode               = tos_ha_config.mode;<span class=\"comment\">//really need?</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tvrid_monitor_devname_get(vrid, (__u8 *)vrrphd-&gt;monitor_devname);</span><br><span class=\"line\">\t<span class=\"comment\">//begin add for D3121</span></span><br><span class=\"line\">\tvrrphd-&gt;backup_monitor_status = bk_monitor_interface_check(vrid) == NET_STAT_GOOD ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//end add for D3121</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\nHA配置是保存在tos_ha_config中的，构造vrrp报文主要读取该结构体的信息，\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-2-3\" class=\"outline-3\">\n<h3 id=\"sec-2-3\"><span class=\"section-number-3\">2.3</span> 如何更新和维持连接信息</h3>\n<div class=\"outline-text-3\" id=\"text-2-3\">\n<p>\nHA每次收到vrrp报文后会更新集群的信息，从而确认设备是否是活动的或者是否加入新设备。调用的函数是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cluster_info_update</span><span class=\"params\">(<span class=\"keyword\">struct</span> vrrphdr *vrrphd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//更新已有设备信息</span></span><br><span class=\"line\">\t__u8 monitor_devname[HA_MAX_MONITOR_DEV_SYNC][IFNAMSIZ];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; HA_MAX_CLUSTER_NUM; i++)</span><br><span class=\"line\">\t{</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((ha_cluster_info[i].valid == <span class=\"number\">1</span>) &amp;&amp; </span><br><span class=\"line\">\t\t\t(ha_cluster_info[i].ip == vrrphd-&gt;ip)) {</span><br><span class=\"line\">\t\t\tha_cluster_info[i].update_time = jiffies;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> next;</span><br><span class=\"line\">\t\t} </span><br><span class=\"line\">\t}</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//记录新加入设备信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; HA_MAX_CLUSTER_NUM; i++)</span><br><span class=\"line\">\t{</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ha_cluster_info[i].valid == <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memset</span>(&amp;ha_cluster_info[i], <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ha_cluster_data));</span><br><span class=\"line\">\t\t\tha_cluster_info[i].valid = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tha_cluster_info[i].update_time = jiffies;                  </span><br><span class=\"line\">\t\t\tha_cluster_info[i].ip = vrrphd-&gt;ip;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">goto</span> next;</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* BUG 36287 */</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == HA_MAX_CLUSTER_NUM - <span class=\"number\">1</span>) {</span><br><span class=\"line\">\t\t\tdbg_main(<span class=\"string\">\"ha cluster max member is HA_MAX_CLUSTER_NUM = 8, can not accept more\"</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t}  </span><br><span class=\"line\">\t<span class=\"comment\">/*省略。*/</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n从代码可以看到ha_cluster_info的update_time字段每次都会更新。所以如果要让他过期，还是需要借助某个定时器，这里用的是vrrp_send_timer。每一秒都会检查一遍是否过期，调用的是下面这个函数：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ha_cluster_database_expired</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> unused)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; HA_MAX_CLUSTER_NUM; i++)</span><br><span class=\"line\">\t{</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((ha_cluster_info[i].valid == <span class=\"number\">1</span>) &amp;&amp; </span><br><span class=\"line\">\t\t\ttime_is_before_jiffies(ha_cluster_info[i].update_time + (<span class=\"number\">3</span> * tos_ha_config.hello_interval + <span class=\"number\">1</span>) * HZ))</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memset</span>(&amp;ha_cluster_info[i], <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> ha_cluster_data));</span><br><span class=\"line\">\t}</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n说白了，只要一个设备四秒中没有发送vrrp报文，本机就认为它已经不存在VR中了。\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 主备协商机制</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-sec-3-1\" class=\"outline-3\">\n<h3 id=\"sec-3-1\"><span class=\"section-number-3\">3.1</span> 决策要素</h3>\n<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\nVRRP使用三个要素来确定虚拟路由器中每台设备的角色：\n</p>\n<ol class=\"org-ol\">\n<li>是否启动抢占方式\n</li>\n<li>优先级\n</li>\n<li>IP地址（在多主状态下使用）\n</li>\n</ol>\n</div>\n</div>\n<div id=\"outline-container-sec-3-2\" class=\"outline-3\">\n<h3 id=\"sec-3-2\"><span class=\"section-number-3\">3.2</span> 协商</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\n协商的目的是使所有设备达到稳定状态，即在所有设备都正常工作的情况的不会发生切换的状态。哪种状态是稳定的？我想到的做法是先对所有设备按优先级排序，不低于优先级别最高的抢占设备的设备可以作为唯一主设备时，可以认为该状态是稳定的。这就是稳定状态的定义。这就是主备协商的目标。\nHA模块的协商机制和VRRP有所不同，由于没有IP拥有者的概念，所以HA启动后，所有设备默认是Backup状态的，待ms_down_timer定时器超时后再切换至Master状态，首先切换至Master状态的设备会通过VRRP通告报文的交互获知虚拟设备中其他成员的优先级，进行Master的选举：\n</p>\n<ul class=\"org-ul\">\n<li>如果发送自Master设备的VRRP报文的优先级 <b>高于或等于</b> 本设备，则本设备保持Backup状态\n</li>\n<li>如果发送自Master设备的VRRP报文的优先级低于本设备，且本设备是采用抢占方式的，则设备切换至Master状态，否则保持Backup状态。\n</li>\n<li>如果同时有多个设备进入Master，这通过报文交流后，优先级较低的会切换成Backup状态，优先级高的设备的会保持Master状态，如果设备优先级相同，则比较其IP地址，较大的称为Master设备。\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> 主备切换触发机制和过程</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n</div><div id=\"outline-container-sec-4-1\" class=\"outline-3\">\n<h3 id=\"sec-4-1\"><span class=\"section-number-3\">4.1</span> 概述</h3>\n<div class=\"outline-text-3\" id=\"text-4-1\">\n<p>\n按VRRP协议的做法，主备切换的目的就是让虚拟路器的所有设备从不稳定状态达到稳定状态。所以问题有两个：\n</p>\n<ol class=\"org-ol\">\n<li>不稳定状态有哪些？\n</li>\n<li>状态如何切换？\n</li>\n</ol>\n<p>\n我暂时将不稳定状态分成了三种：\n</p>\n<ol class=\"org-ol\">\n<li>无主：没有一个设备处于Master状态，通常发生在HA刚刚启动时，或者主设备发生故障时。\n</li>\n<li>多主：多个设备处于Master状态，发生在相同优先级的设备之间。\n</li>\n<li>未抢占：当前Master设备的优先级低于一个开启了抢占的设备，通常发生在加入新设备或设备恢复正常时。\n</li>\n</ol>\n<p>\n主备切换的目标就是离开这些状态直到达到稳定状态，可以用下图来描述主备切换触发机制和过程：\n</p>\n<p>\n<img src=\"HA模块代码分析/election.png\" alt=\"election.png\">\n代码需要实现这个图中的节点和边的概念。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-4-2\" class=\"outline-3\">\n<h3 id=\"sec-4-2\"><span class=\"section-number-3\">4.2</span> 状态识别和切换</h3>\n<div class=\"outline-text-3\" id=\"text-4-2\">\n</div><div id=\"outline-container-sec-4-2-1\" class=\"outline-4\">\n<h4 id=\"sec-4-2-1\"><span class=\"section-number-4\">4.2.1</span> 无主状态和切换</h4>\n<div class=\"outline-text-4\" id=\"text-4-2-1\">\n<p>\n为了识别当前的VR的状态，HA模块主要借助了两个内核定时器：vrrp_send_timer和ms_down_timer，以及一个vrrp报文处理函数ha_vrrp_recv(struct tos_buff *tb)来更新状态切换的时间。有两个条件可以识别无主状态：\n</p>\n<ol class=\"org-ol\">\n<li>设备维护的ms_down_time超时\n</li>\n<li>原主设备发送优先级为0的vrrp报文\n</li>\n</ol>\n<p>\n每个设备在一个VR内都会维护一个ms_down_time变量，ms_down_timer会定时检查它的值来确定状态。一旦发现超过了ms_down_time的值就说明就说明此时的虚拟路由器已经不是稳定状态了。另外，如果Master设备检测到接口异常时，会发送priority值为0的vrrp报文。来让其他设备快速脱离无主状态，这时为了再次达到稳定状态，设备需要自己进入Master状态，随之而来的可能是进入多主或者稳定状态，\n</p>\n<p>\n<img src=\"HA模块代码分析/election_line.png\" alt=\"election_line.png\">\nms_down_timer的处理函数：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">ms_down_timer_expired</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> unused)</span></span><br><span class=\"line\"></span>{  </span><br><span class=\"line\">\t<span class=\"keyword\">int</span> vrid;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tos_ha_config.mode == MODE_AS || tos_ha_config.mode == MODE_AA) {</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>( vrid = BASE_VRID; vrid &lt;= MAX_VRID; vrid++)</span><br><span class=\"line\">\t\t{  </span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tos_ha_config.vrcfg[vrid].valid &amp;&amp; </span><br><span class=\"line\">\t\t\t\t(tos_ha_config.vrcfg[vrid].state == VRRP_STATE_BACKUP)) {</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (tos_run_flag == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t\ttos_ha_config.vrcfg[vrid].ms_down_time = jiffies + <span class=\"number\">3</span> * tos_ha_config.hello_interval * HZ;  </span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (time_is_before_jiffies(tos_ha_config.vrcfg[vrid].ms_down_time))</span><br><span class=\"line\">\t\t\t\t\t\tgoto_master(vrid);</span><br><span class=\"line\">\t\t\t} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//begin add for D3121</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (tos_ha_config.vrcfg[vrid].valid &amp;&amp; </span><br><span class=\"line\">\t\t\t\t    (tos_ha_config.vrcfg[vrid].state == VRRP_STATE_MASTER)) {</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (tos_run_flag == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t\t\t\ttos_ha_config.vrcfg[vrid].bk_down_time = jiffies + <span class=\"number\">3</span> * tos_ha_config.hello_interval * HZ;  </span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (time_is_before_jiffies(tos_ha_config.vrcfg[vrid].bk_down_time)) {</span><br><span class=\"line\">\t\t\t\t\t\t\ttos_ha_config.vrcfg[vrid].backup_heartbeat_status = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\ttos_ha_config.vrcfg[vrid].backup_monitor_status = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\t\t}</span><br><span class=\"line\">\t\t\t\t}</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//end add for D3121</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// <span class=\"label\">XXX do what? </span></span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//HADBG(\"master\\n\");</span></span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t}</span><br><span class=\"line\"></span><br><span class=\"line\">out:</span><br><span class=\"line\">\tmod_timer(&amp;ms_down_timer, jiffies + <span class=\"number\">100</span> * HZ / <span class=\"number\">1000</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n一般无主状态的会随着同一VR的其他设备的ms_down_time到期后结束，不同优先级的设备的ms_down_time是这样设定的：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*vrrp报文的priority不为0时*/</span></span><br><span class=\"line\">delay = <span class=\"number\">3</span> * tos_ha_config.hello_interval * HZ + (<span class=\"number\">256</span> - tos_ha_config.vrcfg[vrid].priority) * HZ / <span class=\"number\">256</span>;</span><br><span class=\"line\">tos_ha_config.vrcfg[vrid].ms_down_time = jiffies + delay;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*vrrp报文的priority为0时*/</span></span><br><span class=\"line\">delay = (<span class=\"number\">256</span> - tos_ha_config.vrcfg[vrid].priority) * HZ / <span class=\"number\">256</span>;</span><br><span class=\"line\">tos_ha_config.vrcfg[vrid].ms_down_time = jiffies + delay;</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n这样优先级高设备就有较大的概率成为主设备。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-4-2-2\" class=\"outline-4\">\n<h4 id=\"sec-4-2-2\"><span class=\"section-number-4\">4.2.2</span> 多主状态和切换</h4>\n<div class=\"outline-text-4\" id=\"text-4-2-2\">\n<p>\n<img src=\"HA模块代码分析/election_duo.png\" alt=\"election_duo.png\">\n判断多主状态的条件是 <b>处于Master状态的设备也能收到来自Master设备发来的vrrp包</b> ，其处理逻辑在函数master_vrrp_recv()：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">master_vrrp_recv</span><span class=\"params\">(<span class=\"keyword\">struct</span> vrrphdr *vrrphd)</span></span><br><span class=\"line\">      </span>{</span><br><span class=\"line\">\t  <span class=\"comment\">/*省略。。。*/</span></span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (peer_priority == VRRP_PRIO_STOP)</span><br><span class=\"line\">\t\t      <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t      <span class=\"comment\">/* ha master recv peer higher priority adv, goto backup not consider local peermpt enable or not! */</span></span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> ((peer_preempt == <span class=\"number\">1</span> || peer_state == VRRP_STATE_MASTER) &amp;&amp;</span><br><span class=\"line\">\t\t      (peer_priority &gt; tos_ha_config.vrcfg[vrid].priority ||</span><br><span class=\"line\">\t\t\t      (peer_priority == tos_ha_config.vrcfg[vrid].priority &amp;&amp; peer_ip &gt; tos_ha_config.local))) {</span><br><span class=\"line\">\t\t      goto_backup(vrid);</span><br><span class=\"line\">\t\t      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t      }           </span><br><span class=\"line\">      }</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n从代码看到离开这个状态的方法是比较优先级和ip，决定进入Backup状态的设备，最后会只剩下一个进入Master状态的设备，这样就达到了稳定状态。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-4-2-3\" class=\"outline-4\">\n<h4 id=\"sec-4-2-3\"><span class=\"section-number-4\">4.2.3</span> 未抢占状态和切换</h4>\n<div class=\"outline-text-4\" id=\"text-4-2-3\">\n<p>\n<img src=\"HA模块代码分析/election_ww.png\" alt=\"election_ww.png\">\n未抢占状态的条件是 <b>当前主设备的优先级低于抢占设备</b> 。其切换方式和使用了和多主切换同样的一段逻辑。抢占设备发送的vrrp报文会使得当前主设备进入Backup状态。同时其ms_down_time不会被原主设备的报文触发更新。所以之后抢占设备会成为主设备。\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">master_vrrp_recv</span><span class=\"params\">(<span class=\"keyword\">struct</span> vrrphdr *vrrphd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">    <span class=\"comment\">/*省略。。。*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (peer_priority == VRRP_PRIO_STOP)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* ha master recv peer higher priority adv, goto backup not consider local peermpt enable or not! */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((peer_preempt == <span class=\"number\">1</span> || peer_state == VRRP_STATE_MASTER) &amp;&amp;</span><br><span class=\"line\">\t(peer_priority &gt; tos_ha_config.vrcfg[vrid].priority ||</span><br><span class=\"line\">\t (peer_priority == tos_ha_config.vrcfg[vrid].priority &amp;&amp; peer_ip &gt; tos_ha_config.local))) {</span><br><span class=\"line\">\tgoto_backup(vrid);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }             </span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backup_vrrp_recv</span><span class=\"params\">(<span class=\"keyword\">struct</span> vrrphdr *vrrphd)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">\t__u8 vrid = vrrphd-&gt;vrid;</span><br><span class=\"line\">\t__u8 peer_priority = vrrphd-&gt;priority;</span><br><span class=\"line\">\t__u8 peer_state = vrrphd-&gt;state;</span><br><span class=\"line\">\t__u32 peer_metric = ntohl(vrrphd-&gt;ha_metric);</span><br><span class=\"line\">\t__u32 peer_ip = vrrphd-&gt;ip;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> local_monitor_interface_state = NET_STAT_GOOD;</span><br><span class=\"line\">\t__u32 local_metric = vrid_metric_get(vrid);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> delay;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (vrid_monitor_interface_check(vrid) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\tlocal_monitor_interface_state = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//begin add for D3121</span></span><br><span class=\"line\">\ttos_ha_config.vrcfg[vrrphd-&gt;vrid].backup_heartbeat_status = <span class=\"number\">0</span>;</span><br><span class=\"line\">\ttos_ha_config.vrcfg[vrrphd-&gt;vrid].backup_monitor_status = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//end add for D3121</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对端设备离开集群</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (peer_state == VRRP_STATE_NORUN) {</span><br><span class=\"line\">\t\tdelay = (<span class=\"number\">256</span> - tos_ha_config.vrcfg[vrid].priority) * HZ / <span class=\"number\">256</span>;</span><br><span class=\"line\">\t\ttos_ha_config.vrcfg[vrid].ms_down_time = jiffies + delay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;           </span><br><span class=\"line\">\t}</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//如果本地是备份状态，对端设备也是备份状态不做任何处理</span></span><br><span class=\"line\">\t<span class=\"comment\">//主设备定时器的超时处理只能由主设备发出的VRRP报文更新</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (peer_state == VRRP_STATE_BACKUP)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//对端监控接口异常</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (peer_priority == VRRP_PRIO_STOP) {</span><br><span class=\"line\">\t\t<span class=\"comment\">//本地接口异常</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (local_monitor_interface_state != NET_STAT_GOOD) {</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (peer_state == VRRP_STATE_MASTER &amp;&amp; </span><br><span class=\"line\">\t\t\t\t(peer_metric &gt; local_metric ||</span><br><span class=\"line\">\t\t\t\t(peer_metric == local_metric &amp;&amp; peer_ip &gt; tos_ha_config.local))) {</span><br><span class=\"line\">\t\t\t\tdelay = <span class=\"number\">3</span> * tos_ha_config.hello_interval * HZ + (<span class=\"number\">256</span> - tos_ha_config.vrcfg[vrid].priority) * HZ / <span class=\"number\">256</span>;</span><br><span class=\"line\">\t\t\t\ttos_ha_config.vrcfg[vrid].ms_down_time = jiffies + delay;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t}</span><br><span class=\"line\">\t\t}</span><br><span class=\"line\">\t\t<span class=\"comment\">//本地接口正常，对端接口异常，立刻切换成主设备。</span></span><br><span class=\"line\">\t\tdelay = (<span class=\"number\">256</span> - tos_ha_config.vrcfg[vrid].priority) * HZ / <span class=\"number\">256</span>;</span><br><span class=\"line\">\t\ttos_ha_config.vrcfg[vrid].ms_down_time = jiffies + delay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t} </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//集群中已有主设备，保持备份状态，更新主设备超时计时器</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (peer_state == VRRP_STATE_MASTER &amp;&amp; </span><br><span class=\"line\">\t    (tos_ha_config.vrcfg[vrid].preempt != <span class=\"number\">1</span> ||<span class=\"comment\">//本地抢占关闭</span></span><br><span class=\"line\">\t     local_monitor_interface_state != NET_STAT_GOOD ||<span class=\"comment\">//本地接口异常</span></span><br><span class=\"line\">\t     peer_priority &gt;= tos_ha_config.vrcfg[vrid].priority)) {<span class=\"comment\">//对端优先级比本地高</span></span><br><span class=\"line\">\t    delay = <span class=\"number\">3</span> * tos_ha_config.hello_interval * HZ + (<span class=\"number\">256</span> - tos_ha_config.vrcfg[vrid].priority) * HZ / <span class=\"number\">256</span>;</span><br><span class=\"line\">\t    tos_ha_config.vrcfg[vrid].ms_down_time = jiffies + delay;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">\t<span class=\"comment\">/*</span><br><span class=\"line\">\t* 收到优先级低的VRRP报文，不更新主设备超时计时器，</span><br><span class=\"line\">\t* 连续三次没收到，定时器自动超时</span><br><span class=\"line\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n</div><div id=\"outline-container-sec-5-1\" class=\"outline-3\">\n<h3 id=\"sec-5-1\"><span class=\"section-number-3\">5.1</span> modprobe和insmod区别</h3>\n<div class=\"outline-text-3\" id=\"text-5-1\">\n<p>\n这两个命令都是用来加载模块的链接程序，区别在于对模块“符号未解析”情况的处理方式，前者会尝试去模块搜索路径中查找其他模块，如果找到符号定义，则会加载改模块，若找不到再报错。这样有利于一次加载所有相关的模块。后者则直接报错。 <del>考虑到C语言的符号修饰功能十分简陋，在底层编程时全局符号更要精细地处理。防止名字空间污染的做法是自然而然的想法。</del>  然而Linux 2.6 之后符号要求要显式导出，这个问题已经小了很多。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5-2\" class=\"outline-3\">\n<h3 id=\"sec-5-2\"><span class=\"section-number-3\">5.2</span> </h3>\n</div>\n</div>\n\nLast Updated 2017-10-24 二 04:40.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
