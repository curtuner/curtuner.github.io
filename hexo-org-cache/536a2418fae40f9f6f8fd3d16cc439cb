{"md5":"22fc59048650664249a7d86db8298955","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 前言</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nxv6的一个麻烦的点是它支持多核处理器，所以代码要比一般的简单的操作系统项目要麻烦。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> xv6源码获取</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<div class=\"org-src-container\">\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/mit-pdos/xv6-public.git xv6</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> <span class=\"todo TODO\">TODO</span> xv6源码结构</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-sec-3-1\" class=\"outline-3\">\n<h3 id=\"sec-3-1\"><span class=\"section-number-3\">3.1</span> <span class=\"todo TODO\">TODO</span> 内核</h3>\n</div>\n<div id=\"outline-container-sec-3-2\" class=\"outline-3\">\n<h3 id=\"sec-3-2\"><span class=\"section-number-3\">3.2</span> <span class=\"todo TODO\">TODO</span> 用户态程序</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<ul class=\"org-ul\">\n<li>cat.c\n</li>\n<li>date.c\n</li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> <span class=\"todo TODO\">TODO</span> 多核的符号引用（似乎是通过段机制）</h2>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 物理地址空间</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n<p>\n虽然有页机制掩盖了物理地址，但是物理地址也不是杂乱无章的。物理地址按低地址到高地址分成三个部分：\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-6\" class=\"outline-2\">\n<h2 id=\"sec-6\"><span class=\"section-number-2\">6</span> 自旋锁的实现</h2>\n<div class=\"outline-text-2\" id=\"text-6\">\n<p>\n使用一个锁变量，不同的运行实体通过读取该变量来判断是否使用某个资源。看描述就知道这个锁变量满足了引起竞态条件的所有条件，一般的解决方案是使用x86提供的特殊指令xchg：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">static inline uint</span><br><span class=\"line\">xchg(volatile uint *addr, uint newval)</span><br><span class=\"line\">{</span><br><span class=\"line\">  uint result;</span><br><span class=\"line\"></span><br><span class=\"line\">  // The + in \"+m\" denotes a read-modify-write operand.</span><br><span class=\"line\">  asm volatile(\"lock; xchgl %0, %1\" :</span><br><span class=\"line\">\t       \"+m\" (*addr), \"=a\" (result) :</span><br><span class=\"line\">\t       \"1\" (newval) :</span><br><span class=\"line\">\t       \"cc\");</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\nlock前缀保证了多处理器系统中的某个处理器能独立使用共享内存，这里lock前缀不是必要的，xchg默认会设置lock信号。由于锁变量只是内存，所以主要的难点在于获取锁和释放锁的过程。这里先观察xv6中的实现：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Acquire the lock.</span></span><br><span class=\"line\"><span class=\"comment\">// Loops (spins) until the lock is acquired.</span></span><br><span class=\"line\"><span class=\"comment\">// Holding a lock for a long time may cause</span></span><br><span class=\"line\"><span class=\"comment\">// other CPUs to waste time spinning to acquire it.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">struct</span> spinlock *lk)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">  pushcli(); <span class=\"comment\">// disable interrupts to avoid deadlock.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(holding(lk))</span><br><span class=\"line\">    panic(<span class=\"string\">\"acquire\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The xchg is atomic.</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(xchg(&amp;lk-&gt;locked, <span class=\"number\">1</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class=\"line\">  <span class=\"comment\">// past this point, to ensure that the critical section's memory</span></span><br><span class=\"line\">  <span class=\"comment\">// references happen after the lock is acquired.</span></span><br><span class=\"line\">  __sync_synchronize();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Record info about lock acquisition for debugging.</span></span><br><span class=\"line\">  lk-&gt;cpu = cpu;</span><br><span class=\"line\">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n自旋锁采用的是忙等待的策略来获得锁，while的那一行是主要的逻辑。释放锁只有写入的操作，所以不需要考虑太多，直接用mov写入一个0即可。自旋锁的自旋描述的是获取锁的控制流不断试探的行为。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-7\" class=\"outline-2\">\n<h2 id=\"sec-7\"><span class=\"section-number-2\">7</span> <span class=\"todo TODO\">TODO</span> 多核CPU的理解</h2>\n</div>\n<div id=\"outline-container-sec-8\" class=\"outline-2\">\n<h2 id=\"sec-8\"><span class=\"section-number-2\">8</span> 内核写入内存后的启动流程</h2>\n<div class=\"outline-text-2\" id=\"text-8\">\n</div><div id=\"outline-container-sec-8-1\" class=\"outline-3\">\n<h3 id=\"sec-8-1\"><span class=\"section-number-3\">8.1</span> 开启分页机制</h3>\n<div class=\"outline-text-3\" id=\"text-8-1\">\n<p>\n分页机制是操作系统，\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-9\" class=\"outline-2\">\n<h2 id=\"sec-9\"><span class=\"section-number-2\">9</span> 不同模块的分析</h2>\n<div class=\"outline-text-2\" id=\"text-9\">\n</div><div id=\"outline-container-sec-9-1\" class=\"outline-3\">\n<h3 id=\"sec-9-1\"><span class=\"section-number-3\">9.1</span> 代码</h3>\n<div class=\"outline-text-3\" id=\"text-9-1\">\n<ul class=\"org-ul\">\n<li>bootasm.S\n</li>\n<li>bootmain.c\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-9-2\" class=\"outline-3\">\n<h3 id=\"sec-9-2\"><span class=\"section-number-3\">9.2</span> 系统初始化</h3>\n<div class=\"outline-text-3\" id=\"text-9-2\">\n</div><div id=\"outline-container-sec-9-2-1\" class=\"outline-4\">\n<h4 id=\"sec-9-2-1\"><span class=\"section-number-4\">9.2.1</span> BIOS</h4>\n<div class=\"outline-text-4\" id=\"text-9-2-1\">\n<p>\n计算机上电之后，第一条指令执行ROM中的BIOS，进行硬件自检，并读取第一个扇区，将其放入0x7c00处，一般情况下这就是bootloader。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-9-2-2\" class=\"outline-4\">\n<h4 id=\"sec-9-2-2\"><span class=\"section-number-4\">9.2.2</span> 设置A20地址线</h4>\n</div>\n<div id=\"outline-container-sec-9-2-3\" class=\"outline-4\">\n<h4 id=\"sec-9-2-3\"><span class=\"section-number-4\">9.2.3</span> 内核的初始化</h4>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-sec-10\" class=\"outline-2\">\n<h2 id=\"sec-10\"><span class=\"section-number-2\">10</span> 编译结果和调试</h2>\n<div class=\"outline-text-2\" id=\"text-10\">\n<p>\n我使用的是qemu来调试内核代码，所以编译的指令是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">make qemu</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n观察xv6的Makefile可以看到：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constant\">QEMUOPTS</span> = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp <span class=\"variable\">$(CPUS)</span> -m 512 <span class=\"variable\">$(QEMUEXTRA)</span></span><br><span class=\"line\">$(QEMU) -serial mon:stdio $(QEMUOPTS)a</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n所以我们要生成的文件是fs.img和xv6.img，一个是根文件系统，而另一个是内核镜像。先讨论内核镜像，即先分析xv6.img\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xv6.img: bootblock kernel fs.img</span><br><span class=\"line\">\tdd if=/dev/zero of=xv6.img count=10000</span><br><span class=\"line\">\tdd if=bootblock of=xv6.img conv=notrunc</span><br><span class=\"line\">\tdd if=kernel of=xv6.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n第一条指令相当有建立一个磁盘，大小是5120000字节。第二条指令是将bootblock写入虚拟磁盘的第一个扇区中。第三条指令代表跳过一个扇区后写入内核文件。\nxv6是直接使用第一个扇区的程序作为bootloader的：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bootblock: bootasm.S bootmain.c</span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class=\"line\">\t<span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class=\"line\">\t<span class=\"variable\">$(LD)</span> <span class=\"variable\">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class=\"line\">\t<span class=\"variable\">$(OBJCOPY)</span> -S -O binary -j .text bootblock.o bootblock</span><br><span class=\"line\">\t./sign.pl bootblock</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n从以上指令可以看出bootasm.S和bootmain共同定义了bootloader。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-11\" class=\"outline-2\">\n<h2 id=\"sec-11\"><span class=\"section-number-2\">11</span> <span class=\"todo TODO\">TODO</span> 异常和中断</h2>\n<div class=\"outline-text-2\" id=\"text-11\">\n</div><div id=\"outline-container-sec-11-1\" class=\"outline-3\">\n<h3 id=\"sec-11-1\"><span class=\"section-number-3\">11.1</span> 概念探究</h3>\n<div class=\"outline-text-3\" id=\"text-11-1\">\n<p>\n对异常和中断的概念往往比较容易混乱，所以先收集一下概念。首先是Intel的文档的内容：\n</p>\n<blockquote>\n<p>\nThe processor provides two mechanisms for interrupting program execution, interrupts and exceptions:\n• An interrupt is an asynchronous event that is typically triggered by an I/O device.\n• An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction. The IA-32 architecture specifies three classes of exceptions: faults, traps, and aborts.\n</p>\n</blockquote>\n<p>\n这是比较权威的解释了，按这个解释中断和异常都提供了打断程序运行的能力，中断是指由设备产生的异步事件，而异常是在处理器运行某个指令时探测到某些条件后产生的同步事件，异常分成了三种：故障、陷阱和终止。\n之后再对比一下，《深入理解计算机系统》，果然不大一样，也难怪一直混淆了。《深入理解计算机系统》中对于异常的定义是：\n</p>\n<blockquote>\n<p>\n异常（execption）是控制流中的突变，用来响应处理其状态的某些变化。\n</p>\n</blockquote>\n<p>\n这里对异常的定义是把它当打断程序运行的事件，必Intel的定义更广，它把异常又分成了4种：中断、故障、陷阱和终止。所以两种定义没有本质的区别！\n最后再来看看xv6文档的定义：\n</p>\n<blockquote>\n<p>\n术语 exception 指产生中断的非法程序操作,例如除以0,尝试访问 PTE 不存在的内存等等。术语 interrupt 指硬件产生的希望引起操作系统注意的信号。\n</p>\n</blockquote>\n<p>\n显然这xv6也采用Intel的定义，但表述还是模糊了一点。既然暂时还是和Intel的处理器打交道，我还是决定使用Intel\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-11-2\" class=\"outline-3\">\n<h3 id=\"sec-11-2\"><span class=\"section-number-3\">11.2</span> 系统调用</h3>\n<div class=\"outline-text-3\" id=\"text-11-2\">\n<p>\n系统调用是通过产生异常实现的，一般情况下，系统调用的中断号是64，在xv6中是用宏T<sub>SYSCALL。系统调用也叫陷阱</sub>\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-12\" class=\"outline-2\">\n<h2 id=\"sec-12\"><span class=\"section-number-2\">12</span> <span class=\"todo TODO\">TODO</span> 中断向量表和中断描述符表的区别</h2>\n<div class=\"outline-text-2\" id=\"text-12\">\n<p>\n在内存中\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-13\" class=\"outline-2\">\n<h2 id=\"sec-13\"><span class=\"section-number-2\">13</span> 调度</h2>\n<div class=\"outline-text-2\" id=\"text-13\">\n</div><div id=\"outline-container-sec-13-1\" class=\"outline-3\">\n<h3 id=\"sec-13-1\"><span class=\"section-number-3\">13.1</span> 引言</h3>\n<div class=\"outline-text-3\" id=\"text-13-1\">\n<p>\n多核CPU共享一个进程表，进程表可变，且读写是分开的，所以会造成竞争条件。这里一般的想法是用代价较小的锁，要不可能就要不断生成新的进程表了。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-13-2\" class=\"outline-3\">\n<h3 id=\"sec-13-2\"><span class=\"section-number-3\">13.2</span> swtch分析</h3>\n<div class=\"outline-text-3\" id=\"text-13-2\">\n<p>\nswtch是切换线程时必须使用的程序：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Context switch&#10;#&#10;#   void swtch(struct context **old, struct context *new);&#10;# &#10;# Save current register context in old&#10;# and then load register context from new.&#10;&#10;.globl swtch&#10;swtch:&#10;  movl 4(%esp), %eax&#10;  movl 8(%esp), %edx&#10;&#10;  # Save old callee-save registers&#10;  pushl %ebp&#10;  pushl %ebx&#10;  pushl %esi&#10;  pushl %edi&#10;&#10;  # Switch stacks&#10;  movl %esp, (%eax)&#10;  movl %edx, %esp&#10;&#10;  # Load new callee-save registers&#10;  popl %edi&#10;  popl %esi&#10;  popl %ebx&#10;  popl %ebp&#10;  ret</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n该函数是内核线程调用的，用于保存内核线程自身的上下文并切换到另一个内核线程。这个函数可以和一般的函数的汇编代码对比，可以发现这个汇编程序的一开始并没有保存%ebp的值来建立一个帧，原因是这个函数并不需要返回，在保存了内核线程的%eip和被调用者保存寄存器后就可以切换到另一个程序了，ret时返回地址已经和调用时不同了。通过改变%esp来改变返回地址，这算是一个对初学者来说比较巧妙的做法。这个程序页暗示，内核线程的栈在切换后是一直保留在内存中的。swtch的第一个参数的含义也就明了了，是一个proc实例的context字段的地址。context其实是内核线程栈的栈顶地址\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> context {</span><br><span class=\"line\">  uint edi;</span><br><span class=\"line\">  uint esi;</span><br><span class=\"line\">  uint ebx;</span><br><span class=\"line\">  uint ebp;</span><br><span class=\"line\">  uint eip;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">enum</span> procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Per-process state</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> proc {</span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"keyword\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> procstate state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> proc *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> trapframe *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> context *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> file *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> inode *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-13-3\" class=\"outline-3\">\n<h3 id=\"sec-13-3\"><span class=\"section-number-3\">13.3</span> scheduler分析</h3>\n<div class=\"outline-text-3\" id=\"text-13-3\">\n<p>\nscheduler是xv6进程调度的核心代码，它是永远不会返回的函数。xv6的实现代码是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PAGEBREAK: 42</span></span><br><span class=\"line\"><span class=\"comment\">// Per-CPU process scheduler.</span></span><br><span class=\"line\"><span class=\"comment\">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class=\"line\"><span class=\"comment\">// Scheduler never returns.  It loops, doing:</span></span><br><span class=\"line\"><span class=\"comment\">//  - choose a process to run</span></span><br><span class=\"line\"><span class=\"comment\">//  - swtch to start running that process</span></span><br><span class=\"line\"><span class=\"comment\">//  - eventually that process transfers control</span></span><br><span class=\"line\"><span class=\"comment\">//      via swtch back to the scheduler.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">scheduler</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> proc *p;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;;){</span><br><span class=\"line\">    <span class=\"comment\">// Enable interrupts on this processor.</span></span><br><span class=\"line\">    sti();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Loop over process table looking for process to run.</span></span><br><span class=\"line\">    acquire(&amp;ptable.lock);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state != RUNNABLE)</span><br><span class=\"line\">\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Switch to chosen process.  It is the process's job</span></span><br><span class=\"line\">      <span class=\"comment\">// to release ptable.lock and then reacquire it</span></span><br><span class=\"line\">      <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">      proc = p;</span><br><span class=\"line\">      switchuvm(p);</span><br><span class=\"line\">      p-&gt;state = RUNNING;</span><br><span class=\"line\">      swtch(&amp;cpu-&gt;scheduler, p-&gt;context);</span><br><span class=\"line\">      switchkvm();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">      <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\">      proc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    release(&amp;ptable.lock);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n可以看到，这个调度器其实很简单，只是不断重复地遍历进程表，直到看到一个RUNNABLE的进程项，这是首次适配算法。中间使用了swtch，这是之后再次进入到scheduler的起点，也就是说进程切换之前关键的三步是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proc = p;</span><br><span class=\"line\">switchuvm(p);</span><br><span class=\"line\">p-&gt;state = RUNNING;</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n将全局的变量proc赋值为当前将要运行的进程数据结构，之后调用switchuvm()，所以接下来在分析switchuvm()：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">switchuvm</span><span class=\"params\">(<span class=\"keyword\">struct</span> proc *p)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p == <span class=\"number\">0</span>)</span><br><span class=\"line\">    panic(<span class=\"string\">\"switchuvm: no process\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kstack == <span class=\"number\">0</span>)</span><br><span class=\"line\">    panic(<span class=\"string\">\"switchuvm: no kstack\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pgdir == <span class=\"number\">0</span>)</span><br><span class=\"line\">    panic(<span class=\"string\">\"switchuvm: no pgdir\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  pushcli();</span><br><span class=\"line\">  cpu-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;cpu-&gt;ts, <span class=\"keyword\">sizeof</span>(cpu-&gt;ts)-<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  cpu-&gt;gdt[SEG_TSS].s = <span class=\"number\">0</span>;</span><br><span class=\"line\">  cpu-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">  cpu-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;</span><br><span class=\"line\">  <span class=\"comment\">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class=\"line\">  <span class=\"comment\">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class=\"line\">  cpu-&gt;ts.iomb = (ushort) <span class=\"number\">0xFFFF</span>;</span><br><span class=\"line\">  ltr(SEG_TSS &lt;&lt; <span class=\"number\">3</span>);</span><br><span class=\"line\">  lcr3(V2P(p-&gt;pgdir));  <span class=\"comment\">// switch to process's address space</span></span><br><span class=\"line\">  popcli();</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n从函数名就知道主要是切换虚拟地址空间的\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-14\" class=\"outline-2\">\n<h2 id=\"sec-14\"><span class=\"section-number-2\">14</span> 进程调度</h2>\n<div class=\"outline-text-2\" id=\"text-14\">\n<p>\n进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供独立的内存空间和CPU。对于进程间的通信看作是不同机器的通信其实是最自然的一种做法，这也是进程间通信使用。\n通常我们为进程提供一个独占处理器的假象，而处理器的数目其实是有限的，所以这里同内存一样也是使用有限的资源来模拟大量的资源的一种做法。这里的资源有限不是处理器速度的有限，而是每个处理器核心一次只能处理一个控制流。进程独占处理器的抽象其实只要保证它的行为和中断运行的行为效果是相同的即可。所以这其实页取决域进程的定义，不可过于爆漏资源。一个进程独占处理器和内存资源主要通过进程调度器、内存分配其、页表来实现的。\n实现处理器的多路复用有几个难点：\n</p>\n<ol class=\"org-ol\">\n<li>普通的上下文切换\n</li>\n<li>上下文切换如何透明化\n</li>\n<li>如何避免多核处理器的切换问题\n</li>\n<li>如何释放占用的内存和资源\n</li>\n</ol>\n<p>\n另外，进程的协作可以降低软件编写的复杂度。所以IPC机制的实现也十分重要。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-15\" class=\"outline-2\">\n<h2 id=\"sec-15\"><span class=\"section-number-2\">15</span> <span class=\"todo TODO\">TODO</span> xv6和Linux的进程定义的区别</h2>\n<div class=\"outline-text-2\" id=\"text-15\">\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> proc {</span><br><span class=\"line\">  uint sz;                     <span class=\"comment\">// Size of process memory (bytes)</span></span><br><span class=\"line\">  <span class=\"keyword\">pde_t</span>* pgdir;                <span class=\"comment\">// Page table </span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *kstack;                <span class=\"comment\">// Bottom of kernel stack for this process</span></span><br><span class=\"line\">  <span class=\"keyword\">enum</span> procstate state;        <span class=\"comment\">// Process state</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> pid;                     <span class=\"comment\">// Process ID</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> proc *parent;         <span class=\"comment\">// Parent process</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> trapframe *tf;        <span class=\"comment\">// Trap frame for current syscall</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> context *context;     <span class=\"comment\">// swtch() here to run process</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *chan;                  <span class=\"comment\">// If non-zero, sleeping on chan</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> killed;                  <span class=\"comment\">// If non-zero, have been killed</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> file *ofile[NOFILE];  <span class=\"comment\">// Open files</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> inode *cwd;           <span class=\"comment\">// Current directory</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> name[<span class=\"number\">16</span>];               <span class=\"comment\">// Process name (debugging)</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n需要对所有进程进行处理时需要考虑\n首先是进程标识，进程名、pid，用于定位进程，kill 一个进程时可以通过进程来。构成集合的结构，一般的集合数据结构，parent 字段代表这是一个树形结构或者链表型结构。进程的运行信息字段包括sz，pgdir,kstack, state tf context\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-16\" class=\"outline-2\">\n<h2 id=\"sec-16\"><span class=\"section-number-2\">16</span> <span class=\"todo TODO\">TODO</span> x86的寄存器</h2>\n<div class=\"outline-text-2\" id=\"text-16\">\n<p>\n由于任务切换时要保留CPU大部分寄存器的值，所以对于寄存器还是需要有总体的了解。寄存器分成了几种：\n</p>\n<ul class=\"org-ul\">\n<li>标志寄存器\n</li>\n<li>内存管理寄存器（GDTR、LDTR、IDTR和TR）\n</li>\n<li>控制寄存器（CR0、CR1、CR2、CR3）\n</li>\n<li>通用寄存器\n</li>\n<li>段寄存器\n</li>\n<li>程序指针\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-17\" class=\"outline-2\">\n<h2 id=\"sec-17\"><span class=\"section-number-2\">17</span> 用户空间和内核空间</h2>\n<div class=\"outline-text-2\" id=\"text-17\">\n<p>\n它们指的是操作系统的运行模式，内核空间中可以执行系统级ISA，并且可以有自己的地址空间\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-18\" class=\"outline-2\">\n<h2 id=\"sec-18\"><span class=\"section-number-2\">18</span> 任务管理</h2>\n<div class=\"outline-text-2\" id=\"text-18\">\n</div><div id=\"outline-container-sec-18-1\" class=\"outline-3\">\n<h3 id=\"sec-18-1\"><span class=\"section-number-3\">18.1</span> 概述</h3>\n<div class=\"outline-text-3\" id=\"text-18-1\">\n<p>\n任务由两个部分组成：\n</p>\n<ul class=\"org-ul\">\n<li>任务执行空间\n</li>\n<li>任务状态段（TSS）\n</li>\n</ul>\n<p>\nTSS管理任务执行空间，任务执行空间包括代码段、数据段、堆栈段，虽然在Linux中只是走一个过场，主要是权限的管理\n如果操作系统使用了处理器提供的特权级保护机制，那么就需要为每个特权级提供独立的堆栈空间。\n一般任务的切换直接影响的寄存器状态是寄存器TR和CR3（如果使用了页机制，一般会使用）。这里的任务管理是处理器提供的，也可以用软件实现，就是不知效率如何。现代Linux似乎没有依赖x86的任务管理功能，只是稍微用到而已。需要注意的是返回信息是保存在切换后的任务执行空间中的。\n似乎xv6开始就对任务切换功能不是很在意了。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-18-2\" class=\"outline-3\">\n<h3 id=\"sec-18-2\"><span class=\"section-number-3\">18.2</span> 任务寄存器（TR）</h3>\n<div class=\"outline-text-3\" id=\"text-18-2\">\n<p>\nTR存放着16位的段寄存器以及当前任务TSS段的整个描述符（作为缓存），访问TR的指令是LTR和STR指令，其中LTR一般只是在系统初始化时使用。\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-19\" class=\"outline-2\">\n<h2 id=\"sec-19\"><span class=\"section-number-2\">19</span> 思考</h2>\n<div class=\"outline-text-2\" id=\"text-19\">\n<ul class=\"org-ul\">\n<li>Linux 有很多复杂的结构体，但实际上处理结构体的复杂度未必有多高，每个处理程序可能只是处理有限的字段，对大的处理复杂度可以根据最复杂的处理程序而定。\n</li>\n<li>进程调度需要多少字段\n</li>\n<li>这里处理集合的算法又是一个类别\n</li>\n<li>如何表示集合，有哪些集合数据结构，\n</li>\n<li>段寄存器的指是否是不变的\n</li>\n<li>锁就实现的方式来看属于系统资源一级的东西。模块化的一个基本手段是函数，不幸的是函数调用链是在一个进程中的。所以每个函数都可以拥有锁。相当域有增加了不固定的全局资源，编程难度有进一步增加了。函数副作用太大。\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-20\" class=\"outline-2\">\n<h2 id=\"sec-20\"><span class=\"section-number-2\">20</span> <span class=\"todo TODO\">TODO</span> 文件系统</h2>\n<div class=\"outline-text-2\" id=\"text-20\">\n</div><div id=\"outline-container-sec-20-1\" class=\"outline-3\">\n<h3 id=\"sec-20-1\"><span class=\"section-number-3\">20.1</span> 前言</h3>\n<div class=\"outline-text-3\" id=\"text-20-1\">\n<p>\n这里的文件系统自然指xv6磁盘文件系统，它解决了几个问题：\n</p>\n<ol class=\"org-ol\">\n<li>设计的磁盘上的数据结构，用于表示目录树和文件，记录每个文件的数据块以及磁盘上哪些空间是空闲的。\n</li>\n<li>崩溃恢复（这个一般的想法是要有日志来保证操作是原子性）\n</li>\n<li>支持在并发访问是保持一致性（大概要用锁）\n</li>\n<li>磁盘读写速度过慢（使用缓存加速）\n</li>\n</ol>\n<p>\nxv6将实现分成了6层：\n<img src=\"./xv6源码分析/xv6_fs.png\" alt=\"xv6_fs.png\">\n每一层分别实现，xv6采用自底向上的分析方法。所以这里我也想从底层的代码开始阅读。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-20-2\" class=\"outline-3\">\n<h3 id=\"sec-20-2\"><span class=\"section-number-3\">20.2</span> 块缓冲层</h3>\n<div class=\"outline-text-3\" id=\"text-20-2\">\n<p>\n作为缓冲层最基本的当然是缓冲区和磁盘数据的交换了。首先了解对于缓冲区的数据结构如何，这个在代码中只有一处：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> {</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> spinlock lock;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf buf[NBUF];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Linked list of all buffers, through prev/next.</span></span><br><span class=\"line\">  <span class=\"comment\">// head.next is most recently used.</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf head;</span><br><span class=\"line\">} bcache;</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n缓冲的结构体只使用一次，所以没必要命名，同时可以看到这是一个全局的结构体变量，所以缓冲区在内核固定的（静态的）数据段中。这种实现的话要增加缓存的大小就得在编译内核时修改宏的值，不知道其他的文件系统是否有其他做法。从bcache可以看到代码，除了同步使用了锁以外就是head成员比较特别，大约可以估计使用的是下次适配的做法。所以要点还在buf的定义上:\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> BSIZE <span class=\"number\">512</span>  <span class=\"comment\">// block size</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> buf {</span><br><span class=\"line\">  <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">  uint dev;</span><br><span class=\"line\">  uint blockno;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> sleeplock lock;</span><br><span class=\"line\">  uint refcnt;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf *prev; <span class=\"comment\">// LRU cache list</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf *next;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf *qnext; <span class=\"comment\">// disk queue</span></span><br><span class=\"line\">  uchar data[BSIZE];</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> B_VALID <span class=\"number\">0x2</span>  <span class=\"comment\">// buffer has been read from disk</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">define</span> B_DIRTY <span class=\"number\">0x4</span>  <span class=\"comment\">// buffer needs to be written to disk</span></span></span><br></pre></td></tr></table></figure>\n</div>\n<p>\n磁盘块的数据存储在data成员中，其他的都是管理的数据。这里flags只用到了两个位，留下其他位估计是方便扩展。dev是设备号，这意味者即使有几个磁盘也只是使用同一个缓冲区。refcnt用于引用计数，对于资源的释放这是常用的做法，之后的三个buf指针，目前还看不出作用。lock则表示这个块是否被其他进程使用。实际上lock这个锁是避免把代码简化的关键，否则处理起来是很麻烦的。\n那么可以开始看bread的代码了，涉及到了bget()的实现：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"comment\">// Return a locked buf with the contents of the indicated block.</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">struct</span> buf*</span><br><span class=\"line\">     <span class=\"title\">bread</span><span class=\"params\">(uint dev, uint blockno)</span></span><br><span class=\"line\">     </span>{</span><br><span class=\"line\">       <span class=\"keyword\">struct</span> buf *b;</span><br><span class=\"line\"></span><br><span class=\"line\">       b = bget(dev, blockno);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!(b-&gt;flags &amp; B_VALID)) {</span><br><span class=\"line\">\t iderw(b);</span><br><span class=\"line\">       }</span><br><span class=\"line\">       <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">     }</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Look through buffer cache for block on device dev.</span></span><br><span class=\"line\">     <span class=\"comment\">// If not found, allocate a buffer.</span></span><br><span class=\"line\">     <span class=\"comment\">// In either case, return locked buffer.</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> buf*</span><br><span class=\"line\">     <span class=\"title\">bget</span><span class=\"params\">(uint dev, uint blockno)</span></span><br><span class=\"line\">     </span>{</span><br><span class=\"line\">       <span class=\"keyword\">struct</span> buf *b;</span><br><span class=\"line\"></span><br><span class=\"line\">       acquire(&amp;bcache.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// Is the block already cached?</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(b = bcache.head.next; </span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"types.h\"</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"defs.h\"</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"param.h\"</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"spinlock.h\"</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"sleeplock.h\"</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"fs.h\"</span></span></span><br><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">\"buf.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> {</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> spinlock lock;</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf buf[NBUF];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Linked list of all buffers, through prev/next.</span></span><br><span class=\"line\">  <span class=\"comment\">// head.next is most recently used.</span></span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf head;</span><br><span class=\"line\">} bcache;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span><br><span class=\"line\"><span class=\"title\">binit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf *b;</span><br><span class=\"line\"></span><br><span class=\"line\">  initlock(&amp;bcache.lock, <span class=\"string\">\"bcache\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PAGEBREAK!</span></span><br><span class=\"line\">  <span class=\"comment\">// Create linked list of buffers</span></span><br><span class=\"line\">  bcache.head.prev = &amp;bcache.head;</span><br><span class=\"line\">  bcache.head.next = &amp;bcache.head;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++){</span><br><span class=\"line\">    b-&gt;next = bcache.head.next;</span><br><span class=\"line\">    b-&gt;prev = &amp;bcache.head;</span><br><span class=\"line\">    initsleeplock(&amp;b-&gt;lock, <span class=\"string\">\"buffer\"</span>);</span><br><span class=\"line\">    bcache.head.next-&gt;prev = b;</span><br><span class=\"line\">    bcache.head.next = b;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Look through buffer cache for block on device dev.</span></span><br><span class=\"line\"><span class=\"comment\">// If not found, allocate a buffer.</span></span><br><span class=\"line\"><span class=\"comment\">// In either case, return locked buffer.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> buf*</span><br><span class=\"line\"><span class=\"title\">bget</span><span class=\"params\">(uint dev, uint blockno)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">  <span class=\"keyword\">struct</span> buf *b;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;bcache.lock);b != &amp;bcache.head; b = b-&gt;next){</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno){</span><br><span class=\"line\">\t   b-&gt;refcnt++;</span><br><span class=\"line\">\t   release(&amp;bcache.lock);</span><br><span class=\"line\">\t   acquiresleep(&amp;b-&gt;lock);</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t }</span><br><span class=\"line\">       }</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// Not cached; recycle some unused buffer and clean buffer</span></span><br><span class=\"line\">       <span class=\"comment\">// \"clean\" because B_DIRTY and not locked means log.c</span></span><br><span class=\"line\">       <span class=\"comment\">// hasn't yet committed the changes to the buffer.</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev){</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(b-&gt;refcnt == <span class=\"number\">0</span> &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == <span class=\"number\">0</span>) {</span><br><span class=\"line\">\t   b-&gt;dev = dev;</span><br><span class=\"line\">\t   b-&gt;blockno = blockno;</span><br><span class=\"line\">\t   b-&gt;flags = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t   b-&gt;refcnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t   release(&amp;bcache.lock);</span><br><span class=\"line\">\t   acquiresleep(&amp;b-&gt;lock);</span><br><span class=\"line\">\t   <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t }</span><br><span class=\"line\">       }</span><br><span class=\"line\">       panic(<span class=\"string\">\"bget: no buffers\"</span>);</span><br><span class=\"line\">     }</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-21\" class=\"outline-2\">\n<h2 id=\"sec-21\"><span class=\"section-number-2\">21</span> 磁盘高速缓存</h2>\n<div class=\"outline-text-2\" id=\"text-21\">\n<p>\n磁盘高速缓机制存把磁盘上的一些数据保留在RAM中\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22\" class=\"outline-2\">\n<h2 id=\"sec-22\"><span class=\"section-number-2\">22</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-22\">\n<ul class=\"org-ul\">\n<li>cli是通过清除IF位来屏蔽中断\n</li>\n<li>x86提供了分页和分段机制，所以地址有三种类型，虚拟地址、线性地址和物理地址。在xv6中，除了每个CPU独立的数据有非0的基址意外，其他的如内核数据段、代码段一般都是从基址0开始的，这样大大简化的地址操作的程序的编程。所以一般我们只需要考虑分页的地址映射而已。\n</li>\n<li>加载内核时是没有loader的所以我们要自己利用elf格式手动加载内核。\n</li>\n<li>进程的地址空间的控制并不再进程的数据结构中，而是在每次切换进程时，改变cr0的物理地址。\n</li>\n<li>分页机制下，物理地址空间被分为一个个页帧，所以如果只是索引叶帧的话只需要20位地址而已。cr0指向页目录表的基址，页目录每一项用20位指向一个子页表，由于一个页目录项指向的页表只有4k所以也是使用20位就可以了，其他位可以作为控制位。\n</li>\n<li>所有CPU核心共用一个进程表\n</li>\n<li>allocproc在进程表中找到一个标记为UNUSED的槽位\n</li>\n<li>进程有内核线程的用户线程，每个线程要有栈\n</li>\n<li>看linux源码时要注意组成内核的部分一般是不会出现在根文件系统中的，也就是自己要理清内核和通常意义上的操作系统的区别。\n</li>\n<li>进程表是用于调度一个计算机中所有的进程，所以用一个表统一管理\n</li>\n<li>进程的线程一般是交替使用内核栈和用户栈的\n</li>\n<li>第一个程序是操作系统内核来运行的，但是还是使用了对于操作系统来说比较统一的方法。\n</li>\n<li>在x64中一般是先call压如pc的返回地址，再由被调用者管理栈帧。但这其实也不是必须的，实际上调用者管理也是可以的，当然我觉得还是前者的汇编代码好看一点。当然参数还是调用者来管理\n</li>\n<li>x64之后寄存器多了，函数参数可以直接保存在寄存器里了\n</li>\n<li>x86中的leave是一个语法糖，被调用者用于栈帧管理。等价于movl %ebp %esp; popl %ebp\n</li>\n<li>x86中调用者保存寄存器是被过程认为是易失，所以被调用者可以直接使用，如果要要使用则要求调用者保存。被调用者保存的寄存器包括ebx, edi和esi，其中esp和ebp是必须要维护的。\n</li>\n<li>Unix的一大优点是大部分资源都可以用文件来表示\n</li>\n<li>文件操作是对设备操作的组织和抽象，设备操作则是文件操作最终实现。\n</li>\n<li>层次的划分取决于使用了使用了哪些元语，依赖哪些实现\n</li>\n<li>抽象的结果是我们可以忽略哪些东西了\n</li>\n<li>传统的设备文件包括块设备和字符设备，之后设备变得越来越复杂，像网络接口这种不能确定属于那一类的设备就被独立出来了。所以一般区分设备包括块设备，字符设备和网络接口。\n</li>\n<li>由于设备的多样性，设备驱动是一个需要正本专著讨论的大课题\n</li>\n<li>PCI已经成为通用的标准总线，\n</li>\n<li>通过修改EFLAG的IF位可以屏蔽中断，但只能屏蔽硬件中断\n</li>\n<li>时钟中断由时钟芯片产生，可能是每100ms产生一个中断\n</li>\n<li>int指令类似域call，但做的事情更多，对于的返回指令是iret\n</li>\n<li>任务段指定了栈\n</li>\n<li>当处理器有多个级别时，Unix/Linux只使用两个级别，而处理器最少有两个级别\n</li>\n</ul>\n</div>\n<div id=\"outline-container-sec-22-1\" class=\"outline-3\">\n<h3 id=\"sec-22-1\"><span class=\"section-number-3\">22.1</span> 可安装模块（module）</h3>\n<div class=\"outline-text-3\" id=\"text-22-1\">\n<p>\nmoule可以在系统运行时动态安装和拆卸的内核软件，实际上它的作用不限于设备驱动\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-2\" class=\"outline-3\">\n<h3 id=\"sec-22-2\"><span class=\"section-number-3\">22.2</span> 将内核频文件载入</h3>\n<div class=\"outline-text-3\" id=\"text-22-2\">\n<p>\nC函数需要使用栈，所以bootloader先用0x7c00作为栈的开始，\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-3\" class=\"outline-3\">\n<h3 id=\"sec-22-3\"><span class=\"section-number-3\">22.3</span> bootloader的理解</h3>\n<div class=\"outline-text-3\" id=\"text-22-3\">\n<p>\nIntel的CPU一开始运行在实模式之上，为了进入保护模式我们要在实模式中构建保护模式的运行环境，最后通过一个jmp正式进入保护模式。内核运行在保护模式中，页机制对于保护模式而言不是必须的，第一步先要启动的是段机制。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-4\" class=\"outline-3\">\n<h3 id=\"sec-22-4\"><span class=\"section-number-3\">22.4</span> <span class=\"todo TODO\">TODO</span> i386的内存管理</h3>\n<div class=\"outline-text-3\" id=\"text-22-4\">\n<p>\nCPU对于内存管理其实设定了不少,\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-5\" class=\"outline-3\">\n<h3 id=\"sec-22-5\"><span class=\"section-number-3\">22.5</span> 虚拟地址空间</h3>\n<div class=\"outline-text-3\" id=\"text-22-5\">\n<p>\nx86其实提供了二维的地址空间，不过Linux似乎没有使用。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-6\" class=\"outline-3\">\n<h3 id=\"sec-22-6\"><span class=\"section-number-3\">22.6</span> 段寄存器</h3>\n<div class=\"outline-text-3\" id=\"text-22-6\">\n<p>\n段寄存器有6个，一个程序一般至少需要3个CS、DS和SS，还有三个辅助的数据段寄存器ES、FS、GS。另外段寄存器还包含不可见的缓存来保存段描述符。对于描述符表做改动后立刻重新加载6个段寄存器\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-7\" class=\"outline-3\">\n<h3 id=\"sec-22-7\"><span class=\"section-number-3\">22.7</span> 利用有限的资源模拟无限的资源</h3>\n</div>\n<div id=\"outline-container-sec-22-8\" class=\"outline-3\">\n<h3 id=\"sec-22-8\"><span class=\"section-number-3\">22.8</span> types.h</h3>\n<div class=\"outline-text-3\" id=\"text-22-8\">\n<p>\n基本系统数据类型。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-9\" class=\"outline-3\">\n<h3 id=\"sec-22-9\"><span class=\"section-number-3\">22.9</span> <span class=\"todo TODO\">TODO</span> 不去使用递归锁的原因（理解不够）</h3>\n<div class=\"outline-text-3\" id=\"text-22-9\">\n<p>\n两个原因：\n</p>\n<ul class=\"org-ul\">\n<li>这会加大相关函数的副作用，加大编程的复杂性\n</li>\n<li>另一个原因是不变量可能被破坏，因为C函数本身无法从函数定义了解相关的实现。\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-22-10\" class=\"outline-3\">\n<h3 id=\"sec-22-10\"><span class=\"section-number-3\">22.10</span> 门描述符</h3>\n<div class=\"outline-text-3\" id=\"text-22-10\">\n<p>\n门描述符描述的是控制转移的入口点，它是通向另一段代码的门，可实现任务内特权级的变换和任务间的切换。任务\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-11\" class=\"outline-3\">\n<h3 id=\"sec-22-11\"><span class=\"section-number-3\">22.11</span> 任务调度（x86特有）</h3>\n<div class=\"outline-text-3\" id=\"text-22-11\">\n<p>\n任务是处理器可以分配调度、执行和挂起的一个工作单元。x86提供了一种机制来保存任务状态，算是x86特有的。估计不是通用的。任务切换操作不会把任何信息压入堆栈中，处理器的状态信息都被保存在内存中称为任务状态段的（TSS,Task State Segment）的数据结构中。当前指令的特权级CPL在保存在%cs（代码段寄存器）中。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-22-12\" class=\"outline-3\">\n<h3 id=\"sec-22-12\"><span class=\"section-number-3\">22.12</span> 有哪些中断处理程序没有关闭中断呢</h3>\n</div>\n</div>\n<div id=\"outline-container-sec-23\" class=\"outline-2\">\n<h2 id=\"sec-23\"><span class=\"section-number-2\">23</span> 思考</h2>\n<div class=\"outline-text-2\" id=\"text-23\">\n<ul class=\"org-ul\">\n<li>复杂的顺序结构和复杂的逻辑结构\n</li>\n<li>操作系统最重要的是进程管理，内存管理，文件系统。一些操作系统（嵌入式）可能没有文件系统也可能没有进程管理，进程管理和文件系统必须至少有一个才能\n</li>\n<li>对于硬件如磁盘来说，有不少动作，但是这些动作的模式却不多，硬件抽象的目的在于提取所有的模式，保证其内容都是完全的\n</li>\n<li>xv6中比较重要的结构体是proc，里面应该包含一个进程运行下去的所有内容。计算机是一状态机，根据当前的状态，计算出下一个状态，并具有可以完全丢弃当前状态的无后效性。proc设计的要点也在此。关键在于足够支持下一步的计算。\n</li>\n<li>处理器提供的很多功能或者指令本身没有特别东西，尤其是描述符的含义，其实可以自己去想象如何编写程序来处理，这样也就没有问题了，\n</li>\n<li>构建内核时先从可以运行开始，之后在增加功能，抽象的顺序大概就能理清了。\n</li>\n<li>有了一定感觉后把程序从开机到运行，并能够运行程序执行系统调用的做的事情理清。\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-24\" class=\"outline-2\">\n<h2 id=\"sec-24\"><span class=\"section-number-2\">24</span> 参考</h2>\n<div class=\"outline-text-2\" id=\"text-24\">\n<ul class=\"org-ul\">\n<li><a href=\"http://blog.csdn.net/qq_25426415/article/category/6684908\">xv6源码分析</a>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html\">地址空间分布</a>\n</li>\n<li>xv6文档\n</li>\n<li><a href=\"https://segmentfault.com/a/1190000008308764\">xv6中存储cpu和进程信息的技巧</a>\n</li>\n<li>Intel 64 and IA-32 Architectures Developer's Manual: Vol.1\n</li>\n<li>Linux内核完全注释\n</li>\n</ul>\n</div>\n</div>\n\nLast Updated 2018-03-04 日 03:01.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
