{"md5":"fa92f2670d407354dfbb1ca4c1f0c8b3","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 前言</h2>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> hello模块示例</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\n先尝试编写一个模块：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hello_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>{</span><br><span class=\"line\">    printk(KERN_ALERT <span class=\"string\">\"Hello, world\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">hello_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>{</span><br><span class=\"line\">    printk(KERN_ALERT <span class=\"string\">\"goodbye, world\\n\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(hello_init);</span><br><span class=\"line\">module_exit(hello_exit);</span><br><span class=\"line\"></span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">\"GPL\"</span>);</span><br></pre></td></tr></table></figure>\n</div>\n<p>\nmodule注册的初始化函数要求类型是int (*)(void)的。这个模块的功能是在加载的时候打印hello world，而在卸载的时候打印goodbye。另一方面，内核模块的编译不同域普通程序。以下是Makefile：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj-m := hello.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">all:</span></span><br><span class=\"line\">\tmake -C /lib/modules/<span class=\"variable\">$(shell uname -r)</span>/build M=<span class=\"variable\">$(PWD)</span> modules</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">clean:</span></span><br><span class=\"line\">\tmake -C /lib/modules/<span class=\"variable\">$(shell uname -r)</span>/build M=<span class=\"variable\">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n要注意的是/lib/modules/$(shell uname -r)/build一般系统默认是不存在的，所以需要安装：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pacman -S linux-headers</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 重要的数据结构</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-sec-3-1\" class=\"outline-3\">\n<h3 id=\"sec-3-1\"><span class=\"section-number-3\">3.1</span> file结构</h3>\n<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\n这是一个在用户空间无法看到的一个结构\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> 字符设备驱动编写实例</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\n其中定义了结构和相关的\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 在/proc建立虚拟文件</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n<p>\n/proc是内核导出的的一个虚拟文件系统，是古老的用户态和内核态交换数据的方式(通过read和write操作)，设定proc文件的接口已经改变了，所以必须要设置，这个需要注意。1\n一般这类文件是模拟的是只读的文件，使用/proc的模块必须使用&lt;linux/proc<sub>fs</sub>&gt;。模块必须实现一个函数，这样我们读取该文件时，读取请求也会发送到这个模块。实际调用的是模块定义的一个函数，接口是:\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*read_proc)(<span class=\"keyword\">char</span>* page, <span class=\"keyword\">char</span>** <span class=\"keyword\">char</span>, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> count,</span><br><span class=\"line\">\t\t <span class=\"keyword\">int</span>* eof, <span class=\"keyword\">void</span>* data);</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n创建和删除proc文件（包括目录文件）的接口分别是 <code>proc_create()</code> 和 <code>proc_remove()</code> 理解\n</p>\n</div>\n\n<div id=\"outline-container-sec-5-1\" class=\"outline-3\">\n<h3 id=\"sec-5-1\"><span class=\"section-number-3\">5.1</span> 用户空间和内核空间传递数据</h3>\n<div class=\"outline-text-3\" id=\"text-5-1\">\n</div><div id=\"outline-container-sec-5-1-1\" class=\"outline-4\">\n<h4 id=\"sec-5-1-1\"><span class=\"section-number-4\">5.1.1</span> get<sub>user</sub></h4>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-sec-6\" class=\"outline-2\">\n<h2 id=\"sec-6\"><span class=\"section-number-2\">6</span> 实用函数</h2>\n<div class=\"outline-text-2\" id=\"text-6\">\n</div><div id=\"outline-container-sec-6-1\" class=\"outline-3\">\n<h3 id=\"sec-6-1\"><span class=\"section-number-3\">6.1</span> kmalloc和kfree</h3>\n<div class=\"outline-text-3\" id=\"text-6-1\">\n<p>\n这两个函数是用于内核模块分配内存使用的，它的特点是得到的内存是在物理上连续的。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-6-2\" class=\"outline-3\">\n<h3 id=\"sec-6-2\"><span class=\"section-number-3\">6.2</span> 关闭中断和打开中断</h3>\n<div class=\"outline-text-3\" id=\"text-6-2\">\n<p>\n一般情况下使用local<sub>irq</sub><sub>save</sub>(flags)和local<sub>irq</sub><sub>restore</sub>(flags)这两个宏来分别关闭和打开中断，flags是当前中断状态。当然还提供了无条件打开和关闭中断的方法，但是其实很少使用，分别是local<sub>irq</sub><sub>disable</sub>(void)和local<sub>irq</sub><sub>enable</sub>(void).\n</p>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-sec-7\" class=\"outline-2\">\n<h2 id=\"sec-7\"><span class=\"section-number-2\">7</span> 时间、延迟及延缓操作</h2>\n<div class=\"outline-text-2\" id=\"text-7\">\n<p>\n内核通过定时器中断来跟踪时间流。时钟中断由系统定时硬件以周期性的间隔产生，这个间隔根据HZ的值设定，HZ是频率的意思，代表每秒中断几次。HZ不同平台上不同，不应该有所假定，使用默认值即可。如果要修改HZ就要重新编译一遍内核了。\njiffies<sub>64是内核的计数器，它的值是自从上次操作系统引导以来的时钟滴答数数，我们一般使用jiffies变量来访问它，因为足够块。当然这个变量是会溢出的。用户程序虽然也可以获得HZ的值，但实际上这个值被设定100，相应的于时间相关的函数也已经做了转化。</sub>\n</p>\n</div>\n<div id=\"outline-container-sec-7-1\" class=\"outline-3\">\n<h3 id=\"sec-7-1\"><span class=\"section-number-3\">7.1</span> 定时器api</h3>\n<div class=\"outline-text-3\" id=\"text-7-1\">\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/timer.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> timer_list {</span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> expires;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*function)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>);</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> data; <span class=\"comment\">// function指向的函数的参数</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init_timer</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mod_time</span><span class=\"params\">(<span class=\"keyword\">struct</span> timer_list* timer, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> expires)</span></span>;</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n其中mod<sub>timer用于修改一个已经调度的定时器的到期时间，</sub>\ndel<sub>timer用于在定时器到期前禁止一个已注册的定时器。有些</sub>\ndel<sub>timer</sub><sub>sync</sub> 在单核时和del<sub>timer行为相同，多核时要使用前者，所以我们在代码中一般要使用前者</sub>\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-8\" class=\"outline-2\">\n<h2 id=\"sec-8\"><span class=\"section-number-2\">8</span> 设备驱动</h2>\n<div class=\"outline-text-2\" id=\"text-8\">\n<p>\n主设备号标识设备的驱动，现代Linux允许多个驱动程序对应一个设备号，但一般还是一个驱动对应一个设备号的原则。次设备号是设备本地数组的索引，可以获得指向内核设备的直接指针，用于获得实际实现的设备。\n设备类型dev<sub>t在</sub>&lt;linux/types.h&gt;中定义，目前是32位，主设备号占12位，次设备号占10位，获取编号的方法是:\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAJOR(<span class=\"keyword\">dev_t</span> dev);</span><br><span class=\"line\">MINOR(<span class=\"keyword\">dev_t</span> dev);</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n构造设备号的方法是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">MKDEV(<span class=\"keyword\">int</span> major, <span class=\"keyword\">int</span> minor);</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-9\" class=\"outline-2\">\n<h2 id=\"sec-9\"><span class=\"section-number-2\">9</span> 网络驱动程序</h2>\n<div class=\"outline-text-2\" id=\"text-9\">\n<p>\n网络接口不像其他设备，在/dev下没有对应的节点。网络接口异步地处理数据包。一般而言，网络世界中，网络接口和协议能理解的最小单元叫octet，它是8个数据位。数据经过协议栈是会被打上不同的协议头。\n网络设备和驱动设备最重要的不同是：块设备只响应来自内核的请求，而网络驱动程序异步地接收来自外部的数据包。内核每次处理的是一个数据包。\n</p>\n</div>\n<div id=\"outline-container-sec-9-1\" class=\"outline-3\">\n<h3 id=\"sec-9-1\"><span class=\"section-number-3\">9.1</span> 连接到内核</h3>\n<div class=\"outline-text-3\" id=\"text-9-1\">\n<p>\n网络接口没有设备号的说法，那么它仍然需要被\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-9-2\" class=\"outline-3\">\n<h3 id=\"sec-9-2\"><span class=\"section-number-3\">9.2</span> 数据包传输</h3>\n<div class=\"outline-text-3\" id=\"text-9-2\">\n<p>\n传输是指将数据包通过网络连接发送出去的行为，内核要发送一个数据包时，它会自动调用驱动程序的hard<sub>start</sub><sub>transmit函数将数据放入外发队列。内核处理的每个数据包都放在sk</sub><sub>buff中，结构定义于</sub>&lt;linux/skbuff&gt;中。\n当sk<sub>buff的的出口设备，下一跳地址，以及链路层的地址填充后，最终发送数据时，就会调用该函数来dev</sub><sub>queue</sub><sub>xmit函数，该函数是驱动程序执行传输的接口。不同的设备驱动程序实现不同。</sub>\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-10\" class=\"outline-2\">\n<h2 id=\"sec-10\"><span class=\"section-number-2\">10</span> 内核通知链</h2>\n<div class=\"outline-text-2\" id=\"text-10\">\n<p>\nLinux内核的子系统相互依赖，当某些子系统的状态发生改变时，需要提供机制通知其他子系统，以便其他子系统采取相应的措施，于是有了通知链（notification chain）。Linux网络子系统的通知链有三个，ipv4地址变化\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-11\" class=\"outline-2\">\n<h2 id=\"sec-11\"><span class=\"section-number-2\">11</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-11\">\n<ul class=\"org-ul\">\n<li>THIS<sub>MODULE代表这个模块对象的地址，它是在编译是确定值的</sub>\n</li>\n<li>ssize<sub>t</sub> 是signed size<sub>t的意思</sub>\n</li>\n<li>内核源码中char _<sub>user</sub>* 的<sub>user指的是，用于修饰用户区的指针，内核态可以访问用户内存，但是用户态内存是不可靠的，所以要特别处理，这个应该是告诉编译器的。</sub>\n</li>\n<li>一般编写使用系统调用的时候，我们只是解析错误码，但是在编写内核程序的时候，我们需要自己涉及错误码，确定要返回的错误码。\n</li>\n<li>为什么说每个网络数据包属于更高的网络层的某个套接字\n</li>\n<li>一个设备接口被定义为以太网接口的优点是可以调用tcpdump来查看数据包。\n</li>\n<li><code>list_for_each(pos, head)</code> 用于遍历链表，pos作为循环变量，同时head是头节点，指向链表第一个节点，同时被最后一个节点指向\n</li>\n<li>内核主要通过两种方法和进程打交道，一种是通过设备文件，一种是通过proc文件系统。\n</li>\n<li>所有的设备都是由mknod，\n</li>\n<li>内核中的代码有三个调用在三种情况下会被调用:\n<ol class=\"org-ol\">\n<li>进程通过系统调用（异常）\n</li>\n<li>中断\n</li>\n<li>被内核其他代码调用\n</li>\n</ol>\n</li>\n<li>C语言没有封装，所以有时即使我们不想变量被使用也不可能\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-12\" class=\"outline-2\">\n<h2 id=\"sec-12\"><span class=\"section-number-2\">12</span> 参考</h2>\n<div class=\"outline-text-2\" id=\"text-12\">\n<ul class=\"org-ul\">\n<li>《Linux设备驱动程序》\n</li>\n</ul>\n</div>\n</div>\n\nLast Updated 2017-10-10 二 11:27.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
