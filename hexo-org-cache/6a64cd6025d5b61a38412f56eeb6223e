{"md5":"1861f403434090097f27c21f953be790","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 协议栈处理包的过程</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n</div><div id=\"outline-container-sec-1-1\" class=\"outline-3\">\n<h3 id=\"sec-1-1\"><span class=\"section-number-3\">1.1</span> 协议栈发送包</h3>\n<div class=\"outline-text-3\" id=\"text-1-1\">\n</div><div id=\"outline-container-sec-1-1-1\" class=\"outline-4\">\n<h4 id=\"sec-1-1-1\"><span class=\"section-number-4\">1.1.1</span> 把包写入套接字</h4>\n<div class=\"outline-text-4\" id=\"text-1-1-1\">\n<p>\n使用 <code>write()</code> 向套接字描述符发送数据，之后调用文件对象的write方法，对于套接字来说，这个由 <code>sock_write()</code> 函数来实现，执行如下操作：\n</p>\n<ol class=\"org-ol\">\n<li>确定嵌入在文件的索引节点的套接字对象的地址\n</li>\n<li>分配和初始化“消息头”，也就是msghdr数据结构，该结构存放各种控制信息\n</li>\n<li>条用 <code>sock_sendmsg()</code> 函数，给它传递套接字对象的地址和msghdr数据结构，这个函数又执行如下操作：\n<ol class=\"org-ol\">\n<li>调用套接字\n</li>\n</ol>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2\" class=\"outline-3\">\n<h3 id=\"sec-1-2\"><span class=\"section-number-3\">1.2</span> 协议栈接收包</h3>\n<div class=\"outline-text-3\" id=\"text-1-2\">\n<ol class=\"org-ol\">\n<li>数据包到达网卡后，网卡芯片将数据包通过DMA方式写入到指定的内存地址，该地址有网卡芯片分配并初始化。\n</li>\n<li>网卡通过硬件中断的方式通知CPU有数据到来\n</li>\n</ol>\n</div>\n</div>\n<div id=\"outline-container-sec-1-3\" class=\"outline-3\">\n<h3 id=\"sec-1-3\"><span class=\"section-number-3\">1.3</span> NAPI的基本思想</h3>\n<div class=\"outline-text-3\" id=\"text-1-3\">\n<p>\n混合使用中断和轮询，而不使用纯粹的事件驱动模型。内核事件驱动模型带来的问题是，中断处理开销是比较大的。NAPI是让内核处理输入队队列时，让驱动程序不去产生事件。\n</p>\n</div>\n</div>\n</div>\n\nLast Updated 2018-03-04 日 03:01.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
