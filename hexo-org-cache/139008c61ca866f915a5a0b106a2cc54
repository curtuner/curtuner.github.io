{"md5":"f7ac9fee100aae5aff7ebc7d8e7c8b32","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> <span class=\"todo TODO\">TODO</span> socket编程</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n</div><div id=\"outline-container-sec-1-1\" class=\"outline-3\">\n<h3 id=\"sec-1-1\"><span class=\"section-number-3\">1.1</span> 套接字</h3>\n<div class=\"outline-text-3\" id=\"text-1-1\">\n<p>\n套接字在内核看来是通信的一个端点，而对于用户程序而言是一个文件。一般调用了socket()函数后，某种地址类型的socket已经被创建了，其中sockaddr是16字节的。\nsocket函数只是创建一个socket文件的描述符，此时还不能作为一个完全打开的文件来使用，只有connect和bind/listen才可以。\n首先需要理清套接字、文件描述符和套接字地址的关系。套接字对于内核来说是一个通信的端点，从Linux程序的角度上来讲是一个有相应描述符的打开文件，这个文件打开的方式是建立连接。所以对应socket原语，有connect和accept来打开一个文件。关闭文件则使用close或者shutdown。至于socket是一个建立一个文件描述符，这个只是一个占用着的文件描述符，这个文件描述符是socket的一部分。socket还有socket地址（通用的结构是struct sockaddr），以及其他的socket属性。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2\" class=\"outline-3\">\n<h3 id=\"sec-1-2\"><span class=\"section-number-3\">1.2</span> 地址</h3>\n<div class=\"outline-text-3\" id=\"text-1-2\">\n<p>\nso\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-3\" class=\"outline-3\">\n<h3 id=\"sec-1-3\"><span class=\"section-number-3\">1.3</span> getaddrinfo和getnameinfo</h3>\n<div class=\"outline-text-3\" id=\"text-1-3\">\n<p>\n<b>这两个接口是专门为socket设计的</b> ，比较重要的一点是，getaddrinfo会得到一个以addrinfo为节点的链表，由于这是动态分配内存的，事后要自己来释放内存。addrinfo的定义是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> addrinfo {</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ai_flags;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ai_family; <span class=\"comment\">// socket的第一个参数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ai_socktype;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ai_protocol;</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-sec-1-4\" class=\"outline-3\">\n<h3 id=\"sec-1-4\"><span class=\"section-number-3\">1.4</span> accept</h3>\n<div class=\"outline-text-3\" id=\"text-1-4\">\n<p>\n这个函数的一个特点是会一种阻塞直到被连接。\n需要注意的是如何accept被中断，会返回-1, errno设置为 EINTR\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-5\" class=\"outline-3\">\n<h3 id=\"sec-1-5\"><span class=\"section-number-3\">1.5</span> socket接口和TCP状态转移图的关系</h3>\n<div class=\"outline-text-3\" id=\"text-1-5\">\n<p>\nclient调用socket和connect后，由connect引起了三次握手，当三次握手完成后，client的connect和server中的accept均返回。更具体地，当client受到第二次握手的报文后，connect其实已经返回了，而服务器要等到最后一次握手后accept才返回。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-6\" class=\"outline-3\">\n<h3 id=\"sec-1-6\"><span class=\"section-number-3\">1.6</span> 僵死进程和exit</h3>\n<div class=\"outline-text-3\" id=\"text-1-6\">\n<p>\nexit的系统调用只能是进程退出，但是进程的数据结构没有被销毁，进程号还会被占用。如果一直没有被处理，进程号可能会被用完。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-7\" class=\"outline-3\">\n<h3 id=\"sec-1-7\"><span class=\"section-number-3\">1.7</span> 僵死进程的处理</h3>\n<div class=\"outline-text-3\" id=\"text-1-7\">\n<p>\n大体有两种处理方式：\n</p>\n<ol class=\"org-ol\">\n<li>由父进程处理。\n</li>\n<li>由init进程（1号进程，现在应该是systemd）处理。\n</li>\n</ol>\n<p>\n父进程处理的方式又分为同步处理和异步处理。init的处理就比较简单，只要让进程编程孤儿进程就可以了。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-8\" class=\"outline-3\">\n<h3 id=\"sec-1-8\"><span class=\"section-number-3\">1.8</span> nonblock socket</h3>\n</div>\n<div id=\"outline-container-sec-1-9\" class=\"outline-3\">\n<h3 id=\"sec-1-9\"><span class=\"section-number-3\">1.9</span> <span class=\"todo TODO\">TODO</span> 哪类的应用要使用哪类socket</h3>\n</div>\n<div id=\"outline-container-sec-1-10\" class=\"outline-3\">\n<h3 id=\"sec-1-10\"><span class=\"section-number-3\">1.10</span> select的基本知识</h3>\n<div class=\"outline-text-3\" id=\"text-1-10\">\n<p>\nselect的timeout设置为NULL时，会一直等待，设置为0时，则立刻返回。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-11\" class=\"outline-3\">\n<h3 id=\"sec-1-11\"><span class=\"section-number-3\">1.11</span> bind</h3>\n</div>\n<div id=\"outline-container-sec-1-12\" class=\"outline-3\">\n<h3 id=\"sec-1-12\"><span class=\"section-number-3\">1.12</span> 检查一个socket是否可以接收数据</h3>\n<div class=\"outline-text-3\" id=\"text-1-12\">\n<p>\n可以使用select\n</p>\n</div>\n<div id=\"outline-container-sec-1-12-1\" class=\"outline-4\">\n<h4 id=\"sec-1-12-1\"><span class=\"section-number-4\">1.12.1</span> 如何使用bind比较好？</h4>\n<div class=\"outline-text-4\" id=\"text-1-12-1\">\n<p>\n这里看看xrdp的包装\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"title\">g_tcp_bind_address</span><span class=\"params\">(<span class=\"keyword\">int</span> sck, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* port, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* address)</span></span><br><span class=\"line\"></span>{</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> sockaddr_in s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;s, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> sockaddr_in));</span><br><span class=\"line\">    s.sin_family = AF_INET;</span><br><span class=\"line\">    s.sin_port = htons((tui16)atoi(port));</span><br><span class=\"line\">    s.sin_addr.s_addr = INADDR_ANY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inet_aton(address, &amp;s.sin_addr) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    {</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>; <span class=\"comment\">/* bad address */</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bind(sck, (<span class=\"keyword\">struct</span> sockaddr*)&amp;s, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> sockaddr_in));</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n这里要知道atoi出错的时候返回0，\n这里的接口要好一点，\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-1-13\" class=\"outline-3\">\n<h3 id=\"sec-1-13\"><span class=\"section-number-3\">1.13</span> epoll</h3>\n<div class=\"outline-text-3\" id=\"text-1-13\">\n</div><div id=\"outline-container-sec-1-13-1\" class=\"outline-4\">\n<h4 id=\"sec-1-13-1\"><span class=\"section-number-4\">1.13.1</span> 概述</h4>\n<div class=\"outline-text-4\" id=\"text-1-13-1\">\n<p>\n只有三个接口：\n</p>\n<ol class=\"org-ol\">\n<li>int epoll<sub>create</sub>(int size)\n</li>\n<li>int epoll<sub>ctl</sub>(int epfd, int op, int fd, struct epoll<sub>event</sub> *event)\n</li>\n<li>int epoll<sub>wait</sub>(int epfd, struct epoll<sub>event</sub> * events, int maxevents, int timeout)\n</li>\n</ol>\n</div>\n</div>\n<div id=\"outline-container-sec-1-13-2\" class=\"outline-4\">\n<h4 id=\"sec-1-13-2\"><span class=\"section-number-4\">1.13.2</span> epoll<sub>create</sub></h4>\n<div class=\"outline-text-4\" id=\"text-1-13-2\">\n<p>\n创建一个epoll的handle，它能够监控的fd数目只受到机器资源限制\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-13-3\" class=\"outline-4\">\n<h4 id=\"sec-1-13-3\"><span class=\"section-number-4\">1.13.3</span> epoll<sub>event</sub></h4>\n</div>\n</div>\n<div id=\"outline-container-sec-1-14\" class=\"outline-3\">\n<h3 id=\"sec-1-14\"><span class=\"section-number-3\">1.14</span> unix域套接字</h3>\n<div class=\"outline-text-3\" id=\"text-1-14\">\n<p>\nUnix域套接字的效率比位于同一主机的TCP套接字的两端通信速度要快得多。X Window System就是实例，当发现server和client是在同一台主机上的时候，就会使用Unix域套接字。Unix域中用于标识client和server的协议地址是普通文件系统中断路径名。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-15\" class=\"outline-3\">\n<h3 id=\"sec-1-15\"><span class=\"section-number-3\">1.15</span> TCP nodelay的作用</h3>\n<div class=\"outline-text-3\" id=\"text-1-15\">\n<p>\nTCP连接默认使用Nagle算法来处理小包。Nagle算法是为了提高带宽利用率的算法。关闭的方法是设定NO<sub>DELAY</sub>\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-16\" class=\"outline-3\">\n<h3 id=\"sec-1-16\"><span class=\"section-number-3\">1.16</span> TCP keepalive</h3>\n</div>\n<div id=\"outline-container-sec-1-17\" class=\"outline-3\">\n<h3 id=\"sec-1-17\"><span class=\"section-number-3\">1.17</span> 关于socket接口的封装</h3>\n<div class=\"outline-text-3\" id=\"text-1-17\">\n<p>\n原始的socket接口基本的使用基本都不算合适，我一大家都不约而同地进行包装\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> signal和sigaction的区别</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\n两者是相同的\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 一个输入操作涉及的阶段</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n<ul class=\"org-ul\">\n<li>等待数据准备好\n</li>\n<li>将数据从内核缓冲区复制到进程缓冲区，\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> 关于连接状态</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\n如果\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 有限状态机</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n</div><div id=\"outline-container-sec-5-1\" class=\"outline-3\">\n<h3 id=\"sec-5-1\"><span class=\"section-number-3\">5.1</span> 前言</h3>\n<div class=\"outline-text-3\" id=\"text-5-1\">\n<p>\nsocket处理的是字节流，一个可能的做法是，如果一个程序完全由数据流驱动，那么作为一个状态机来思考其实非常有用。而在数据报交流的时候状态机的意义其实更大。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-5-2\" class=\"outline-3\">\n<h3 id=\"sec-5-2\"><span class=\"section-number-3\">5.2</span> 有限状态机的定义（如何抽象的基础）</h3>\n</div>\n<div id=\"outline-container-sec-5-3\" class=\"outline-3\">\n<h3 id=\"sec-5-3\"><span class=\"section-number-3\">5.3</span> 用于编程的一个要点</h3>\n<div class=\"outline-text-3\" id=\"text-5-3\">\n<p>\n使用过程式语言编写状态机的一大问题是，过程式语言本身可以模拟成一个状态机\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-6\" class=\"outline-2\">\n<h2 id=\"sec-6\"><span class=\"section-number-2\">6</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-6\">\n<ul class=\"org-ul\">\n<li>ip<sub>mreq</sub>\n</li>\n<li>目前socket函数一般和getaddrinfo\n</li>\n<li>相比之下，字符串作为参数显得更加通用，大不了写个parser。\n</li>\n<li>lladdr 代表link-level address\n</li>\n<li>回收进程的一个常用做法是把SIGCHLD设定为SIG<sub>IGN，这样它的子进程不会变成僵死进程，不过这种方法不通用</sub>\n</li>\n<li>socket nodelay\n</li>\n</ul>\n</div>\n<div id=\"outline-container-sec-6-1\" class=\"outline-3\">\n<h3 id=\"sec-6-1\"><span class=\"section-number-3\">6.1</span> 如何建立UDP套接字</h3>\n</div>\n<div id=\"outline-container-sec-6-2\" class=\"outline-3\">\n<h3 id=\"sec-6-2\"><span class=\"section-number-3\">6.2</span> tcpdump的使用</h3>\n<div class=\"outline-text-3\" id=\"text-6-2\">\n<p>\n混杂模式下网络接口会截获经过接口的每个分组。一般是广播的分组，单播的除非是发送给自己的，否则一般不会被收到。但某种程度上可以了解网络的一些信息。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-6-3\" class=\"outline-3\">\n<h3 id=\"sec-6-3\"><span class=\"section-number-3\">6.3</span> 为什么要实现僵死进程</h3>\n<div class=\"outline-text-3\" id=\"text-6-3\">\n<p>\n方便父进程获取子进程的信息，当然这样很多时候会造成资源的浪费，所以一个比较好的做法是每次调用fork后要执行wait来回收。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-6-4\" class=\"outline-3\">\n<h3 id=\"sec-6-4\"><span class=\"section-number-3\">6.4</span> accept能有的东西</h3>\n<div class=\"outline-text-3\" id=\"text-6-4\">\n<p>\naccept如何接收不同种类的socket，\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-7\" class=\"outline-2\">\n<h2 id=\"sec-7\"><span class=\"section-number-2\">7</span> 参考</h2>\n<div class=\"outline-text-2\" id=\"text-7\">\n<ul class=\"org-ul\">\n<li>《计算理论导引》\n</li>\n</ul>\n</div>\n</div>\n\nLast Updated 2018-03-04 日 03:01.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
