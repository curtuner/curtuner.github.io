{"md5":"2902a1fcab6e45f15d383c6316dbbf65","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> HTTP报文</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n</div><div id=\"outline-container-sec-1-1\" class=\"outline-3\">\n<h3 id=\"sec-1-1\"><span class=\"section-number-3\">1.1</span> 报文的组成</h3>\n<div class=\"outline-text-3\" id=\"text-1-1\">\n<p>\n报文分成了三部分，分别是起始行、首部和以及可选的、包含数据的主体。起始行由CRLF作为行的终止，当然一般的web服务器都会接受使用\\n作为终止。主体可以是文本也可以是二进制数据。而首部会包含主体的元信息。\n</p>\n</div>\n<div id=\"outline-container-sec-1-1-1\" class=\"outline-4\">\n<h4 id=\"sec-1-1-1\"><span class=\"section-number-4\">1.1.1</span> 报文的语法</h4>\n<div class=\"outline-text-4\" id=\"text-1-1-1\">\n<p>\n报文大体分成了两种：\n</p>\n<ol class=\"org-ol\">\n<li>请求报文\n</li>\n<li>响应报文\n</li>\n</ol>\n\n<p>\n请求报文的格式是：\n</p>\n\n<p>\n&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;\n</p>\n\n<p>\n&lt;headers&gt;\n</p>\n\n<p>\n&lt;entity-body&gt;\n</p>\n\n<p>\n响应报文的格式是：\n</p>\n\n<p>\n&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;\n</p>\n\n<p>\n&lt;headers&gt;\n</p>\n\n<p>\n&lt;entity-body&gt;\n</p>\n\n<p>\n各个部分代表的含义是：\n</p>\n<ul class=\"org-ul\">\n<li>method：客户端希望服务器执行的动作。\n</li>\n<li>request-URL：命名了请求的资源，或者URL路径组件。\n</li>\n<li>version：HTTP版本号，很多协议都会在格式中加一个版本号，但最终用的基本不多\n</li>\n<li>status：三位数字描述了请求过程中发生的情况。状态码的每一位都用来描述状态的一般类型。\n</li>\n<li>reason-phrase：状态码的可读版本，机器不会关心这个，主要给人看。\n</li>\n<li>headers：首部，可以有一个或者多个header，每行是一个 &lt;name&gt;: &lt;value&gt; ，用CRLF作为结尾。headers的结尾是一个CRLF。\n</li>\n<li>entity-body：包含任意的数据块。并不是所有的报文都包含实体的主体部分。\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-1-1-2\" class=\"outline-4\">\n<h4 id=\"sec-1-1-2\"><span class=\"section-number-4\">1.1.2</span> 起始行</h4>\n<div class=\"outline-text-4\" id=\"text-1-1-2\">\n<p>\n请求报文的起始行说明了服务器要 <i>做什么</i> ，而响应报文的起始行说明了 <i>发生了什么</i> 。为了方便起见接下来请求报文的起始行称为请求行，响应报文的起始行称为响应行。\n</p>\n</div>\n<ol class=\"org-ol\"><li><a id=\"sec-1-1-2-1\" name=\"sec-1-1-2-1\"></a>请求行<br><div class=\"outline-text-5\" id=\"text-1-1-2-1\">\n<p>\n请求报文请求服务器对资源进行一些操作。\n</p>\n</div>\n</li>\n<li><a id=\"sec-1-1-2-2\" name=\"sec-1-1-2-2\"></a>响应行<br><div class=\"outline-text-5\" id=\"text-1-1-2-2\">\n<p>\n响应报文承载了状态信息和操作产生的所有结果数据\n</p>\n</div>\n</li>\n<li><a id=\"sec-1-1-2-3\" name=\"sec-1-1-2-3\"></a>方法<br><div class=\"outline-text-5\" id=\"text-1-1-2-3\">\n<p>\n响应报文\n</p>\n</div>\n</li></ol>\n</div>\n\n<div id=\"outline-container-sec-1-1-3\" class=\"outline-4\">\n<h4 id=\"sec-1-1-3\"><span class=\"section-number-4\">1.1.3</span> 首部</h4>\n<div class=\"outline-text-4\" id=\"text-1-1-3\">\n<p>\n首部本质上时名/值对的列表，大体上分成了一下几类：\n</p>\n<ol class=\"org-ol\">\n<li>通用首部\n</li>\n<li>请求首部\n</li>\n<li>响应首部\n</li>\n<li>实体首部\n</li>\n<li>扩展首部\n</li>\n</ol>\n\n<p>\n通用首部既可以出现了响应报文也可以出现在请求报文中，其他的首部的归属就很明显了，扩展首部是规范中没有的首部。一般的名/值对都在一行内表示，也可以在几行内描述，这个做法叫做首部延续行。多出来的每行要有一个空格或者tab。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-1-4\" class=\"outline-4\">\n<h4 id=\"sec-1-1-4\"><span class=\"section-number-4\">1.1.4</span> 实体</h4>\n<div class=\"outline-text-4\" id=\"text-1-1-4\">\n<p>\n这个HTTP的负荷，可以时各种类型的数据：有数字数据、图片、视频等。\n</p>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-sec-1-2\" class=\"outline-3\">\n<h3 id=\"sec-1-2\"><span class=\"section-number-3\">1.2</span> 方法</h3>\n<div class=\"outline-text-3\" id=\"text-1-2\">\n<p>\nHTTP提供了不少方法，不过一般服务器不需要提供所有方法。类似HTTP 1.1，服务器只要提供GET和HEAD方法就够了。GET和HEAD被称为 <b>安全方法</b> 。因为它们 <b>不需要</b> 服务器产生什么结果（这要看服务器的实现）。\n</p>\n</div>\n<div id=\"outline-container-sec-1-2-1\" class=\"outline-4\">\n<h4 id=\"sec-1-2-1\"><span class=\"section-number-4\">1.2.1</span> GET</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-1\">\n<p>\n客户端要求服务器发送某个资源。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-2\" class=\"outline-4\">\n<h4 id=\"sec-1-2-2\"><span class=\"section-number-4\">1.2.2</span> HEAD</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-2\">\n<p>\nHEAD方法的要点是它返回的东西除了没有实体，其他的和GET方法返回的一样\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-3\" class=\"outline-4\">\n<h4 id=\"sec-1-2-3\"><span class=\"section-number-4\">1.2.3</span> PUT</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-3\">\n<p>\nPUT是和GET相反的行为，请求报文中就包含实体，它请求服务器用实体部分创建一个有请求URL命名的新文档。说白了他是用于上传资源的。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-4\" class=\"outline-4\">\n<h4 id=\"sec-1-2-4\"><span class=\"section-number-4\">1.2.4</span> POST</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-4\">\n<p>\nPOST用于向服务器输入数据，服务器会处理这些数据。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-5\" class=\"outline-4\">\n<h4 id=\"sec-1-2-5\"><span class=\"section-number-4\">1.2.5</span> TRACE</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-5\">\n<p>\n由于HTTP请求在到达目标服务器前会经过网关、防火墙、代理等中间设备，这些设备可能会改变这些请求。为了看到我们的报文最终被如何修改了，就可以使用TRACE方法，它会让服务器在响应主体中包含收到的请求报文。当然这个方法能做到的有限。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-6\" class=\"outline-4\">\n<h4 id=\"sec-1-2-6\"><span class=\"section-number-4\">1.2.6</span> OPTIONS</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-6\">\n<p>\n我们知道服务器支持的方法还是有不少差别的，OPTIONS方法会请求服务器告知其支持的各种功能。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-7\" class=\"outline-4\">\n<h4 id=\"sec-1-2-7\"><span class=\"section-number-4\">1.2.7</span> DELETE</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-7\">\n<p>\n请求服务器上删除URL指定的资源。不一定会被执行，而且规范不要求服务器通知客户端是否满足了请求。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-1-2-8\" class=\"outline-4\">\n<h4 id=\"sec-1-2-8\"><span class=\"section-number-4\">1.2.8</span> 扩展方法</h4>\n<div class=\"outline-text-4\" id=\"text-1-2-8\">\n<p>\n扩展的方法指的是没有在HTTP 1.1中定义的方法\n</p>\n</div>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> Tinyhttp源码解析</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<ul class=\"org-ul\">\n<li>Tinyhttp回收结束的线程，这样只要连接次数一多就会导致资源不足，不过这只是一个建议的http服务器代码，所以也不用太在意\n</li>\n<li>需要注意的是http是文本协议，所以涉及到对于字符串的处理。\n</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 零散</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-sec-3-1\" class=\"outline-3\">\n<h3 id=\"sec-3-1\"><span class=\"section-number-3\">3.1</span> 小点</h3>\n<div class=\"outline-text-3\" id=\"text-3-1\">\n<ul class=\"org-ul\">\n<li>http的url中第一个域名之后以及‘？’之前就是资源路径，\n</li>\n<li>TCP可以看作一个无限的流，但我们的内存是不能支持无限的流的，所以需要有缓存，先得到数据（如从磁盘，或者通过计算），再从缓存块中发送到网络接口中。\n</li>\n<li>多线程和fork虽然需要特别注意，但是一般用来exec一个新的程序其实不会有什么问题\n</li>\n<li>HTTP 1.0之前不会要求请求行中版本号，\n</li>\n<li>HTTP 1.0之前还有0.9这个版本，要简单得多。看到不要奇怪了。\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-3-2\" class=\"outline-3\">\n<h3 id=\"sec-3-2\"><span class=\"section-number-3\">3.2</span> 管道的使用</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\n由于管道要当作是单向的，所以如果要通过管道完成父进程和子进程的沟通就要通过就要使用两个管道。\n</p>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> <span class=\"todo TODO\">TODO</span> 问题</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<ul class=\"org-ul\">\n<li>URL的语法\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 参考</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n<ul class=\"org-ul\">\n<li>《HTTP权威指南》\n</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Tools\">Firefox 开发工具</a>\n</li>\n</ul>\n</div>\n</div>\n\nLast Updated 2017-11-26 日 22:36.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
