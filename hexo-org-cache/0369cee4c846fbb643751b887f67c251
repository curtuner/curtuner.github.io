{"md5":"ccd786709cd59f66f05254b2df19850c","content":"\n\n\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 前言</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n这里主要介绍ELF文件如何加载，一个比较重要的问题是，ELF文件中的代码段、数据段、BSS段在进程地址空间是如何分布的。加载的过程可以当作一个parsing的过程\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> 页映射</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\n该机制先将内存和所有磁盘中的数据和指令按照“页”为单位划分，\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 创建进程的过程</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n</div><div id=\"outline-container-sec-3-1\" class=\"outline-3\">\n<h3 id=\"sec-3-1\"><span class=\"section-number-3\">3.1</span> 创建一个虚拟地址空间，除了init程序，都是线通过fork来得到的。</h3>\n<div class=\"outline-text-3\" id=\"text-3-1\">\n<p>\n一开始，只要创建一个页目录即可\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3-2\" class=\"outline-3\">\n<h3 id=\"sec-3-2\"><span class=\"section-number-3\">3.2</span> 读取可执行文件头，并建立虚拟空间和可执行文件的映射关系。</h3>\n<div class=\"outline-text-3\" id=\"text-3-2\">\n<p>\n用数据结构表示\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-3-3\" class=\"outline-3\">\n<h3 id=\"sec-3-3\"><span class=\"section-number-3\">3.3</span> 将CPU的指令寄存器设置为可执行文件的入口地址，启动运行。</h3>\n</div>\n</div>\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> elf文件结构解析</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\nELf文件有数据结构叫程序头表（Program Header Table），可以通过readelf -l 来查看\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-5\" class=\"outline-2\">\n<h2 id=\"sec-5\"><span class=\"section-number-2\">5</span> 思考</h2>\n<div class=\"outline-text-2\" id=\"text-5\">\n<ul class=\"org-ul\">\n<li>C语言的指针是虚拟内存地址，但是指针的访问是被限制的，Segmentation fault就是段保护带来的\n</li>\n<li>进程的虚拟地址空间其实是一个虚拟的概念，只是一个内存模型，并不对于实际内存的布局。操作系统通过elf文件头建立ELF文件和虚拟内存之间的映射关系。\n</li>\n<li>有趣的一点是程序一开始执行就会遇到第一个缺页错误。\n</li>\n<li>通过对段机制的学习，我们知道操作系统并不关心各个段的内容，主要关心段的权限。段的权限种类并不多，重要的是读写执行3个属性，不可读写是没意义的，基本只有几种：\n<ul class=\"org-ul\">\n<li>以代码段为代表的可读可执行段\n</li>\n<li>以数据段和BSS段为代表的可读写段\n</li>\n<li>以只读数据段为代表的权限为只读的段\n</li>\n</ul>\n</li>\n<li>我们虽然一般只考虑数据结构的逻辑，但已知逻辑段的内存块有时我们也叫数据结构，不宜过于拘谨。\n</li>\n<li>BSS段要求的权限和.data的权限相同，所以属于同一个segment，一般通过把程序头表的p<sub>memsz来增加为0的部分</sub>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-6\" class=\"outline-2\">\n<h2 id=\"sec-6\"><span class=\"section-number-2\">6</span> <span class=\"todo TODO\">TODO</span> 问题</h2>\n<div class=\"outline-text-2\" id=\"text-6\">\n<ul class=\"org-ul\">\n<li><code>[&#xa0;]</code> 页是如何实现划分的，是依靠忽略二进制的后几位吗？\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-sec-7\" class=\"outline-2\">\n<h2 id=\"sec-7\"><span class=\"section-number-2\">7</span> FAQ</h2>\n<div class=\"outline-text-2\" id=\"text-7\">\n</div><div id=\"outline-container-sec-7-1\" class=\"outline-3\">\n<h3 id=\"sec-7-1\"><span class=\"section-number-3\">7.1</span> 可执行文件为什要有时被称为映像文件？</h3>\n<div class=\"outline-text-3\" id=\"text-7-1\">\n<p>\n可执行文件在被装载时是被映射的虚拟空间。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-7-2\" class=\"outline-3\">\n<h3 id=\"sec-7-2\"><span class=\"section-number-3\">7.2</span> 可执行文件的section和segment的区别？</h3>\n<div class=\"outline-text-3\" id=\"text-7-2\">\n<p>\n两个在中文中都翻译成段，但实际是不同的概念。section是划分目标文件的概念，像.init、.BSS就是指的section。链接的时候主要是section在其作用。Segment是装载时才有的概念，节约物理内存，所以将相同权限的section划分到了一起。是装载时的基本单位。实际上，section和segment不一定要区分，只是我们选择的方案注定了我们要区分这个概念而已。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-7-3\" class=\"outline-3\">\n<h3 id=\"sec-7-3\"><span class=\"section-number-3\">7.3</span> ELf文件的View（视图）是什么？</h3>\n<div class=\"outline-text-3\" id=\"text-7-3\">\n<p>\n从section角度看ELf文件称为链接视图，从segment的角度看就是执行视图。\n在Linux下查看链接视图的方法是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">readelf -S a.elf</span><br></pre></td></tr></table></figure>\n</div>\n<p>\n而查看执行视图的方法是：\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">readelf <span class=\"operator\">-l</span> a.elf</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-7-4\" class=\"outline-3\">\n<h3 id=\"sec-7-4\"><span class=\"section-number-3\">7.4</span> VMA是什么？</h3>\n<div class=\"outline-text-3\" id=\"text-7-4\">\n<p>\nVirtual Memory Area，虚拟内存区域。虚拟内存分为很多区域，包括可读可运行的段，可读可写的段，堆、栈等。\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-7-5\" class=\"outline-3\">\n<h3 id=\"sec-7-5\"><span class=\"section-number-3\">7.5</span> elf文件、线性地址和虚拟地址的关系？</h3>\n<div class=\"outline-text-3\" id=\"text-7-5\">\n<p>\nlinux下不主张将程序分段，而主张分页，所以段基址一般是0，所以在linux虚拟地址是相同的\n</p>\n</div>\n</div>\n<div id=\"outline-container-sec-7-6\" class=\"outline-3\">\n<h3 id=\"sec-7-6\"><span class=\"section-number-3\">7.6</span> 为什么在Linux没有看到段机制起作用？</h3>\n<div class=\"outline-text-3\" id=\"text-7-6\">\n<p>\n段机制在Linux的实现下只是走走形式而已，实际上我们把逻辑地址看作线性地址也不会有什么问题\n</p>\n</div>\n</div>\n</div>\n<div id=\"outline-container-sec-8\" class=\"outline-2\">\n<h2 id=\"sec-8\"><span class=\"section-number-2\">8</span> 参考</h2>\n</div>\n\nLast Updated 2018-03-04 日 03:01.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.3.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)\n"}
