#+TITLE: 关于C语言问题和改进
#+DATE: 2017-08-10
#+LAYOUT: post
#+TAGS: C语言
#+CATEGORIES: C语言

* 前言
  上班在车上无聊就看了一下《C++语言的设计和演化》，虽说目前主要用C，但看一下C++之父对编程语言（主要对C和C++）的思考还是大有裨益的。一旦语言要编译成机器码，就不得不了解一些底层的惯例。这些东西其实在学习C语言的过程中经常会接触到。C语言程序的链接约定估计是在C语言出现之前就有了雏形。
* 链接模型
  C语言是使用分别编译之后再链接的方式来生成可执行文件的，这算是历史传统。单独编译一个文件时为了保证之后能域其他模块顺利链接，必须要有其他模块的信息，一般我们把这些信息写在头文件中。C语言和C++的兼容指的是链接兼容的，即它们的链接模型是相同的。所谓的二进制兼容大约是在这个层次了。有了链接的兼容，代码的兼容是否重要又是另一回事了。最终的结果是C++其实早就和C在源码级别上不兼容了，一般所说的兼容其实是链接模型兼容。但其实对于符号的命名规范还是有所不同。
  C语言的类型系统很比较弱，尤其到了链接的时候就能发现，因为C语言的符号修饰规则并不包含类型信息。而对于包含了符号信息的C++来说，链接时出现函数类型不匹配时，可以报未定义的引用这个错误，另一方面，这也是实现重载的手段。方法很简单，可以C语言从大规模使用开始就注定了不能这样改进了。
* 预处理器（Cpp）
** 前言
   由于历史原因，C语言对于名称的处理一直不好，这个从链接的过程就可以看出了，加上C语言是弱类型，这个已经很麻烦了。平时编程的时候要小心符号的污染问题。预处理器的做法又进一步减弱了我们把握符号的能力。
** #include
   这是预处理器的指示字，以前我一直觉得这是个比较智能的指令，可以根据文件使用的函数到相关文件中查找定义再插入生成.i文件。然而其实它只是单纯从其他文件里复制源文件正文，并且是整个文件复制。这样的结果是会给编译其前端带来巨大的负担。要体会一下，可以用指令生成.i文件来查看：
   #+BEGIN_SRC sh
   gcc -E -o test.i test.c
   #+END_SRC
   多#include几个文件就千行了，考虑到很多头文件都被重复引用，代价还是比较大的。
** #define（可部分替代）
   这个指示字可以进行简单的文本替换。比较常用的是定义开子程序，和定义常量。目前这两个功能已经可以被const，enum和inline大部分替代。
** #ifdef
   目前还是不可缺的功能：
   - 版本控制
   - 注释代码（可以提供嵌套的注释）
** #progma
   - 布局控制
   - 为编译程序提供非常规的控制流信息
* 关于静态分配内存
  C语言用于存放结构化数据的内存大体分成了三种：栈、数据段、堆。我过去编程的时候比较在意堆和栈的内存使用，而忽略了数据段这个在初始化时就分配的内存，相比其他两个，合理使用数据段能带来更多的好处。
* 语法
  #+BEGIN_SRC C
    a; // 默认类型是int
    f(); // 默认返回类型是int
    int main(void) {
	a =5;
    }
  #+END_SRC
  这样的程序居然编译过了，只有一个警告。第一次知道C
* 关于使用goto语言的要点
** 分析状态来消去goto
   内核以及系统编程总是能看到goto语句的实现，类似资源释放这种事情暂时还没找到更好的办法。但是偶然在《Unix网络编程 卷一》看到一段代码：
   #+BEGIN_SRC C
     #include "unp.h"

     void
     str_echo(int sockfd)
     {
	 ssize_t n;
	 char buf[MAXLINE];
     again:
	 while ((n = read(sockfd, buf, MAXLINE)) > 0)
	     Writen(sockfd, buf, n);

	 if (n < 0 && errno == EINTR)
	     goto again;
	 else if (n < 0)
	     err_sys("str_echo: read error");
     }
   #+END_SRC
   这里使用了goto跳转，其使用实在是没必要地增加了代码的阅读难度。由于能力所限，还是用自动机来将代码理清。个人目前对于while的理解还是如下图：
   #+BEGIN_SRC dot :file 关于C语言问题和改进/while.png :cmdline -Kdot -Tpng :exports results
     digraph g {
	     rankdir = LR

	     a -> b
	     a -> a

	     a [shape = circle]
	     b [shape = doublecircle]
     }
   #+END_SRC

   #+RESULTS:
   [[file:关于C语言问题和改进/while.png]]
   
   这是一个比较笼统的图，表示不断重复一个循环体，直到达到终止条件，所以使用while的关键是要把终止条件描述完整。前面之所以要用goto，是因为上面哪个while不能完整描述终止条件。去掉goto的做法是：
   #+BEGIN_SRC C
     #include "unp.h"

     void
     str_echo(int sockfd)
     {
	 ssize_t n;
	 char buf[MAXLINE];
	 while ((n = read(sockfd, buf, MAXLINE)) != 0) {
	     if (n > 0) {
		 Writen(sockfd, buf, n);
	     } else if (n < 0 && errno != EINTR) {
		 err_sys("str_echo: read error");
	     }
	 }
     }
   #+END_SRC
   这样就好看多了。当然，这样还有一个问题，对于C语言编程，我一直希望 *计算* 和 *写* 操作可以比较明显的分开。可惜在while中这种在判断语句中还是有点让人迷惑，毕竟判断语句有副作用，这不算是好的判断语句，虽然在C语言里不用太在意就是了。我换了一种形式：
   #+BEGIN_SRC C
     #include "unp.h"

     void
     str_echo(int sockfd)
     {
	 char buf[MAXLINE];
	 for (ssize_t n = read(sockfd, buf, MAXLINE); n; n = read(sockfd, buf, MAXLINE)) {
	     if (n > 0) {
		 Writen(sockfd, buf, n);
	     } else if (n < 0 && errno != EINTR) {
		 err_sys("str_echo: read error");
	     }
	 }
     }
   #+END_SRC
   这样就把判断和副作用分开了，这个算是for的一个作用。至少个人觉得代码美观了不少。需要额外注意的是代码的对于异常处理，我的理解是不把它当作执行流的一部分。
* TODO 关于减少使用#define的问题
  使用宏定义的问题在于我们定义的名字是无法被编译器看到的，这意味这我们和编译器的交流过程存在信息的损失，这对我们报错会造成很大的影响
* 阅读源码中学习到的一些小技巧
  - 使用基本数据类型或者系统数据类型的别名，别名的作用是提供了多一层抽象。这样可以提高可移植性，如可能会域到不同的系统应该使用不同的类型来提高效率的情况。
  - 有时我们用一个结构体来表示不同的类型，一般情况下结构体会变得十分大，所以我们需要对公共的部分进行抽象。设定宏来强调并快速访问
* 零散
  - 相比之下，Python、Java、Lua这类语言代表是有自己完整系统和环境（虚拟机）的语言，这样限制了语言的角色，而不必去做它不擅长的事情。
  - 相比之下llvm是如何做到的？
  - 类型检查发生编译器运行过程中，然而C语言本身是弱类型，所以可能使用const，enum，inline来替代#define的动力没那么大？
  - 当分支不会在合并时，最好记得使用else，不带else的if应该暗示它的分支最终会合并，即最终没有分支的时候可以。对于continue而言分支其实最终会合并，所以可以不是用else
  - 编程中对于类型其别名，本身是一种抽象。主要为了应对对于不同平台上的不同类型，或者之后要增大类型的情况，
* 参考
  - 《C++语言的设计和演化》
  - 《Effective C++》
  
