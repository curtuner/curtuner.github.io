#+TITLE: 编程思考
#+DATE: 2017-07-07
#+LAYOUT: post
#+TAGS: 编程
#+CATEGORIES: 编程

* TODO 计算模型
** 概要
   计算模型不只一种，而在不同的计算模型下对于计算过程有不同的描述。程序语言出现的目的在于压缩这些描述。压缩这些描述的技巧在于尽量找出重复的元素。我们成这种做法叫提取复用元素。一般可以复用的元素包括：
   - 变量（复用内存）
   - 函数（复用计算过程）
   - 类型
   - 对象（同时复用内存和计算过程）
   同时各个编程语言对于相同的复用元素的复用能力有不同的设定。类似过程式编程，函数一般不是第一类对象，不能作为参数或返回值。在函数的复用能力上不如函数式语言。
   然而，编程语言的复用能力并不是衡量一门语言的唯一因素。由于程序员是容易犯错的人，这在C/C++的使用中已经被证明了，所以压缩格式并不是单纯以压缩率来确定的，尽管不同的压缩方式（语言特性的组合）确实有区别，但我们可以在保证一个压缩等级的情况下选择更加适用于程序员编写程序的压缩格式。所以另一个问题是如何构造安全和简洁的压缩格式，也即程序语言。后一个目标其实更为重要，因为现代语言能提供压缩等级不多。
** 一般过程式语言的函数和函数式语言的函数
   过程式语言是依靠改变状态来实现运算的，但函数也有返回值，如果我们不使用该返回值，这个值也就不会其作用，但是这个值有时也可以像函数式语言一样控制计算。在过程式语言中返回值可以反映部分状态信息。过程式语言读取并改变状态就是全部了。而函数式语言比较简单，只有映射一说。
   对于过程式编程语言来说函数的返回值可以看做当前状态的映射，所以对于改变状态之后值也可能会不同。
** 学习语言的思路
   首先是要明白这门语言提供了什么来支持计算，一般该有的都有。
** C语言
   作为典型的过程式语言，这个语言能描述的东西分成了三类，读、写、运算（读和写的对象是内存，而运算是不会改变内存的，这样就分成了三类）。当然从函数式语言的角度上看，也可以分成两类，写和运算（读也是当作一种运算）。个人在编写C语言的过程中最大感觉是但这三者分得比较开时，往往能降低一定的编程复杂度。无副作用的函数可以看作是运算。而有副作用则应看作过程，这类过程的接口需要比较多的说明才能被理解。相比之下无副作用需要的额外说明相对较少。
   另外，把读看作运算可以提高抽象程度，所以C++可能也倾向于此。当然，过程才是编程的重点和难点，区分好写和运算只是降低了复杂度而已。
* 关于子任务和父任务
* 面向对象
* 编程语言的特性和共性
  一般编程语言都有自己的特性，先总结一下这些特性，首先要知道这门语言使用的计算模型，是图灵机还是lambda演算（还是其他，不过主流就这两种）。无论是图灵机还是lambda演算，它们都离不开计算（否则怎么叫计算机呢）所以最基本的是语言如何进行算数运算，计算机运行的过程其实全部都是算数运算（可执行代码都是二进制的）。最基本的是四则运算，其他更加复杂的运算都可以基于这些和语言的其他机制来模拟，当然有些语言可能把它作为我基础的语言元素，这个也需要学习。有了计算当然不能离开计算的对象了，所以需要有基本的类型系统，一开始是先是初级的类型系统，符合类型要之后再看。接下来就是抽象了，否则写出的复杂一点的程序都不能看了。首先只有计算和数据写出来的叫计算过程。我们需要有东西来为这个计算过程命名，之后复用，这就是函数命名，或者说过程抽象。同时我们操作的运算对象可能十分复杂，所以还需要对数据进行抽象，也就是变量命名。另一方面，我们编写计算过程的时候，如果只是一条指令一条指令地编写，那样是不能描述类似无限这样的情况，对于不知道合适要停止运算的情况就无法描述了，所以需要一种可以描述无限的代码结构，或者通过跳转（如C语言的goto）来达成，或者通过循环，或者通过递归，具体要看语言采用的方案了。需要注意的是递归拥有的能力远不止如此。可以独立作为一种特性来看待。
  
* 关于抽象和函数定义（符号定义的思考）
  一般的思考是，对于一个符号的定义如果使用了其他符号，则可以认为该符号的抽象层次可以高于其他符号。然而，没那么简单，符号的定义可能是相互的。虽然一般不至于循环定义但是如果几个定义间相聚很远的话十分难以理解，而且要认为它们的抽象层次是一样的。但我们认为一个符号的抽象层次高于另一个符号时，可能又有一个符号的定义同时使用了这两个符号，所以其实抽象层次是意义的，所以当一个符号的定义涉及到了另一个符号时，如果哪个符号也是全局的，那么这两个符号的抽象层次其实是一样的。那如果用到的符号是局部的呢（如C语言的static）？在外面不存在两个符号的比较，所以也不是问题吧。。。所以啊。。。抽象的关键还是在于隐藏。同时暴露的符号还是属于同一个抽象层的。但这是C语言的偷懒方法。。。。同一个抽象层的划分还是必要的。按抽象层次划分已经试过了，太过复杂，所以可以按功能、副作用相关行什么的来划分。所以之后的研究方向就是在一个抽象层对各个符号进行划分。
* 数据类型的理解
  数据类型的理解其实没有足够的，
* 关于接口继承和抽象到具体的过程
* 自动内存管理
  其实C语言也有自动内存管理，虽然这是由编译器提供的，它属于管理可以在编译期确定生命周期的内容。如为了支持函数调用而使用的堆栈。
  自动内存管理的直接目的是让名称的生命周期和内存保持一致，也就是说只要实现了这一点就称得上自动内存管理。至于使用的是引用计数还是垃圾回收那又是另一回事了。
* 关于模块化
  对于过程式语言，不得不使用作用域比较大的变量，如全局变量或者静态全局变量。由于函数的副作用无法重接口就看出来，所以看到一个模块中的函数就可能需要考虑其是否会对一个全局变量造成修改，全局变量越多造成的负担越大。所以模块化的目标是降低这个复杂度。并不是所有函数都会修改所有全局变量，而且不同的全局变量往往值是正交的，同时也不是所有函数都有副作用。
** TODO 可能的方案 [20%]
   果然全局变量的问题还是无解的，一个变量被设定为全局的本身意味着要写函数来改变它的值，所以问题是要如何选择是否将一个变量设定为全局的。所以关键是对静态变量的作用域的设定。模块化的关键是限制某些要设为静态变量的作用范围，宏观上看，全局变量的改变是运算的目的，而静态全局变量是支持运算。对于单进程程序而言这样不会造成问题。
   问题变成了如何减少一个函数需要 *考虑的变量数量* ，为了这个目的而模块化。
   如果全局变量之间是正交的，分开为不同的模块是可行的
   - [ ] 减少符号的做法只是缓解C语言的问题，不可太过执着。
   - [X] 全局变量在一个文件中可行吗？
   - [ ] 一个过程依赖的变量要最小化，也就是最小化其可能的最大副作用。
   - [ ] 如何利用功能模块化，有副作用的模块和无副作用的模块是分得比较开的。
* 概念到实现
  现实的概念中有很多联系，我们先把能直接用数据表示的概念用内存表示，之后再使用粘合剂将各种内容联系起来。
* 解答
** 全局变量放在一个文件可行吗？
   不可行，这样还要static全局变量做什么？一个函数的符号本身，
* 关于大型结构体的思考和化简
  大型结构体中各个字段如果都是正交还好，但是很多时候存在结构体间的值是相关的，也就是你改变一个值就需要改变另一个字段的值。能把相关的字段合并为一个字段最好，有时甚至可以消去，有时甚至可以消去（当它是可以从其他字段直接计算的时候），如果不能，要区分开与其正交的字段，同时要理清于其相关的字段的依赖关系，哪个在前，哪个在后，没有依赖的字段要先修改，之后慢慢计算楚依赖它的字段的新值。
* 编程语句块的独立性和建立计算
* 关于多进程和多线程
  但前计算机的进程仍然是一个自动机的动态运行的概念，所以目标仍然是收敛于某个状态。多进程编程要考虑不同进程的状态的相互影响，而多线程编程则是有共有的状态，相互影响的部分和多进程一样。目前还想不出两者在概念上有和区别。或者只是代价的区别而已？
  Linux下的fork()复用了Linux环境，这是个优点。不过它同一个代码中，会有一些代码是不会被父进程使用的，也就是有只属于子进程的代码。父进程无所谓，只是增加了一段不会运行的代码而已，其他的和编写单进程程序没有太大区别。如果在运行完独有的代码之后还要运行公共代码，此时相当于要考虑两个后条件，复杂度似乎会增加。
* 关于如何阅读模块
  肯定是先知道模块的接口
  代码本来就不是线性阅读的，更接近树形
* 如何确定程序逻辑
  其实要从我们知道的入手，而不去做太多的假设
* 关于类型的制约
  一个函数的类型是确定的，所以其内容不稳定。范型函数可以可以描述更多的行为，何乐而不为呢?可以没有模板的C语言只能用宏来代替先了。
* 动态类型和模板
  
* 设计数据结构时如何先把结构的设想补全，细致的和大体的
* 关联数据结构和数据库
  关联的对象是什么，一般而言是正交的两个数据居，索引的结果是软水。
* 关于虚拟设备
  我们知道我们对于设备的认知，或者任何对象的认知取决于我们能获取的信息和改变的状态。对象也完全如此，我们完全可以只定义对象的接口，而使用不同的实现，而这个也是虚拟对象的前提，虚拟对象的前提。虚拟对象，所以没有可以想象的所有。
* 关于扩展结构体的理解
  结构体对字段需要有哪些假设呢？这要看接口，有些接口必须要使用这个，一般是在最前面和最后面有假设，所以为结构体增加字段并不会导致结构体出现问题。 
* 关于对象复用的概念
  对象复用其实引进了复杂度，而且往往是后续添加的优化，所以一般要保证复杂度相同。
* 关于阅读代码
  阅读之前肯定需要理解程序的运行逻辑，也就是至少需要知道代码的运行方式，有一定的运行例子来支持。之后下一步就是阅读运行逻辑的代码。很多时候这个东西并不是一个程序的最重要的地方，但却是我们阅读代码的起点。需要注意的是我们阅读到那个深度停止。虽然问题就是这个问题。`我的想法是需要一定的文档支持，最为重要的是看到我们需要阅读的模块就差不多了。即便只有我们需要的模块和其他模块的关系其实也是足够的了。只有知道我们对于这个模块的修改会对实际的运行有那些影响，就可以了。如同我们看待函数一样，我们只要知道它是做什么的就可以了，这就是模块化。所以关键是先知道有那些模块，模块的功能和交流方式。之后才是我们需要深入的部分。
* 关于一个函数的编写
  一个函数的实现在不考虑调用的函数的情况下，其实我们需要在意的是算法层面的，而算法又有很多可以分成子算法。所以我们要看我们的理解，即便是主函数也应该这样。只是绑定的过程要比较多。有一点需要注意，函数的复杂度的问题。O(n)
* 算法实现
  算法的主要逻辑往往会比较简单，即便有些复杂，也可以把大的问题分解成为小的问题。一个算法往往一个最大的问题是简短，同时描绘足够的东西，这就要通过循环或者递归来达成，递归的分析相对简单。而循环需要完成对于循环不变量的分析。本质上没什么区别，都是使用归纳法的推理。其中循环在处理条件上有很多的麻烦点。
  一个需要顾虑的点是如果有多个可能的终止条件，类似判断对错的算法可能有两种终止条件。
  还有一个问题，就是对于当前状态，循环是要先检查还是后检查，目前大家倾向于先检查，原因是检查的代码不会有多少开销，即便重复也不会有多大问题，而如果后检查可能会导致有一个状态没有检查（初状态），当然偶尔也存在某些数据需要在检查时重复计算的情况，这个时候使用后检查可以降低开销。这个时候使用后检查也没什么不可以的，就是需要额外注意一下。
* 关于闭包
  闭包是函数的一种实现，Lua就是选用了这个策略的例子。
* 开发
  开发的一般情况不是从零开始完成，而是通常阅读别人写的代码，之后通过扩展这些代码完成自己的需求。
* 关于并发
** 竞态条件
   过程式语言维护各种状态，在状态切换时时还有许多局部状态要维护，问题是在并发的情况下，状态切换过程一般是通用的不同的状态会产生不同的切换结果，而在并发条件下，如果切换结果可能被改变，那么就产生了竞态条件。关键就是状态切换过程被破坏。
** 并发程序的正确行为
   在过程式语言中改变状态的操作只有一个，就是复制，也就是对于一般计算机结构的写内存的过程，由于这个操作一般指对应一条不可分割的指令，所以我们可以直接在编程语言层面对并发做限制。最严格的限制是对共享变量的操作不允许同时发生。但我们常常会5嫌弃这种做法的低效性，加锁的开销和风险常常困扰我们。所以又有不那么严格的限制，保证并发系统产生的结果与各个进程按照某种方式顺序运行长生出的结果一样，有时可以允许产生多于一个正确的结果。最后，类似于模拟扩散的过程我们完全可以不需要对变量作出任何限制，因为结果一定是收敛的。
** 控制并发的机制
   我们把每个访问共享变量的行为看作一个事件，并发系统中这些事件可以交错执行，只要分析每种交错执行的结果就可以了，然而这种方法随着事件和进程数量的增加而变得无法控制。为了可以控制，我们拥有方法可以限制交错的行为，大大降低排列顺序的数目。从而保证程序有正确行为。
** 根本困难
   时间和状态的问题，一直是一个比较麻烦的问题。
* 关于包装和抽象
  看过对于socket的包装和对于线程的包装，可惜如果作为包装来考虑，其实不好理解，因为必须要考虑socket或者线程的底层行为，但这样和抽象相悖。包装应该指的是接口级别的包装，不应该和抽象相互混淆。
* 数据结构的操作
  对于过程式语言来说数据结构的操作其实比较简单，只要提供基本的几个就可以了。下面确定数据结构的状态集合，之后确定所有可行的状态转移。
  对于查询而言，基本的复杂度是 $O(n)$ ，然而，查询操作太过普遍，于是又出现了查询数据结构，但查询数据结构本身需要付出代价的，所以对于查询机会很少的应用，没必要使用查询数据结构。
  数据结构存在状态变化，无论是结构还是内容，我们设计接口的目标是将状态变化都表现出来。接口的目标就是如此，然而状态的变化在没有合适的状态机来表示，而计算机是一个精细得多的计算设备，所以用汇编表述的时候免存在中间状态。 而中断会发生在这之间，这也是存在并发问题的原因。如果建立的每个状态机模型都是原子操作的也就没有了问题。或者只在一个进程中。单线程程序中其实不会有各种程序。
  一个有趣的点是读和写，一个算法可以有读和写，但这是不方便的，编写程序的时候我们往往需要初始化的过程，这个过程其实就是之后读写的对象，同时运行的时候的局部作用域有时也需要我们构建，如果这个环境在栈中，就可以自动管理，如果在堆中要手动管理，这个就是自动变量，一般还是推荐使用函数的局部局部作用域，如果不影响代码的可读性，就可以使用块作用域。如果要把这个纳入考量，就是是否需要
* 状态驱动的编程
  
* 关于数据结构的简单分析
  数据结构都有关键状态变化，只要把握关键状态变化即可其他的都是次要的，或者随之改变的。一个数据结构（容器比较重要），尤其是比较通用的数据结构要包含足够的定义信息，关键是你提供的数据结构需要多大的灵活性，哪些需要在在定义时就设置，对于外部来说数据结构有哪些状态变化。
* TODO 关于函数调用链条如何达成所谓的分层？
  数据是如何传输的？
* TODO 关于运行，抽象运行这个概念需要的最少概念
* 错误
  过早考虑软件的类似名字空间和符号的管理这个东西其实有些不好，一般依照一般的组织原则就可以了。
* 关于粘合剂量
  
* 关于编写项目
  最根本的当然是完成一个虚拟机，达成对于计算机的所有抽象，而平常编写程序无非只是其中的一个部件或者整个虚拟机而已。最高级别的当然是一个可以执行的虚拟机。
* 开发的原因
  
* 关于阅读项目代码结构
  - 如何分模块（这是基本组件）
  - 如何通信（这是粘合剂）
* 前条件需要需要处理
  一个不能预知外界环境的系统会需要大量能检测前条件的接口，剩下的只能依靠计算机了。
* 不要重复自身
  这个其实不是一开始决定的
* 核心的问题是关系，各种对象的关系，问题
  问题经常有不同的层面，类似树，读的时候就是内部状态变化，树是状态转移表，而如果是add这种操作，我们操作的状态就是树了。                             
* 自底向上
  现在看来传统的自底向上和自顶向下的争论意义不大，关键是状态的构建和状态的转化，如果状态转化的基础构建不行，那么何从测试呢？所以先是基础状态机的构建，至于某些基础接口的设计是之后的事情。
* 关于状态转移和接口
  内部的恶状态状态转移要清晰，但是接口是否要暴露这是后面的事情。一开始全部清晰一点比较好。
  本质上接口都会对于对象状态有限制，我们包装的时候要注意这一点。
* 前条件就是状态
  条件的选择其实要复杂地多
* TODO 能构建状态的自动机是否算是图灵完备的机器
* 副作用和主逻辑
  很多时候问题并不是主逻辑能直接完成的问题，而是通常阅读别人写的代码
* 编写项目
  一开始还是以模仿为主，所以受限于这种思维，其实编程不是这样的，所以现在的想法是先搞清除主流程之后才是，处理各个模块。在不同的阶段考虑不同的东西，粒度也会有所不同。
  定义的位置应该和使用的位置相近。
* 异步和同步
  异步的eventloop其实类似于自动机，不断获取输入作为事件来推进状态转移。而同步代码则有所不同，其状态转移取决于当前状态是否“完全”（这里认为一个完全的状态是可以计算出下一个状态的），像如果需要用户输入，那么必须到得到了用户的数据之后状态才可以完全。
* 阅读代码以及二次开发
  直接开代码其实是不对的，要先运行，之后不断添加日志和输出才是最佳的阅读手段，而补充不断脑补，因为可能是错的。
* 协程
  协程是子程序的一个更加通用的形式，子程序可以在一个点进入，之后在另一个点离开。协程可以在任意一点进入、离开和重新开始。
* 接口
  一个接口的实现应该是当前是哪个或哪些状态，使用哪个状态转移，至于自动机的输入，就是函数的接口中了。
* 常态
  一个软件如何达到其常态是除了模块化之后最重要的部分了。
* 零散
  - 现代语言的运行和语言的特性息息相关，以C语言为例，变量的定义带来的是运行时它可以占有一个固定的内存空间。
  - 现代编程语言的编译结果是运行时描述，这是最基础的描述
  - 表达式的特性是只有一个返回值
  - 其实现代的设备的编译结果：汇编语言已经是最灵活的压缩格式了。最重要的是对于内存地址的直接访问，可以实现足够细的粒度上的代码复用
  - 异常的状态一个就够了。
  - 对于贴近操作系统的编程，没有副作用是不现实的。
  - 值传递和引用传递的区别，在于行为上的区别，传递一个变量的值还是传递一个表达式的值
  - 我们知道对象在创建时要调用构造函数，但是这其实会导致效率的问题，因为调用函数
  - C语言放回值为void的函数本身就意味着这不是一个计算过程，即使它使用的一个计算过程。
  - 一个状态下不断进行的行为，如果不改变自身状态，就只是计算而已
  - 求值所依赖的条件是什么，同样一个求职的过程，如何使他求值的结果发生改变，如何使其不变。如果求值过程不变，就会导致就会导致。
  - 为什么要自己定义别名呢，原因是如果有什么改变，如类型或者数据结构定义，我们很多时候也只要改动部分而已，而且也往往只是抽象层次的较底层。
  - 单向链表的粘合剂是next指针。
  - 什么状态转移，有了异常检查状态转移的描述就简洁多了，不过问题就变成了是否要及。
  - 转移和状态识别不知道要不要放到一块。一开始还是不喜欢放到一块，这样比较自底向上。
  - 锁可以在大范围内构建状态，比如独占的状态和松开的状态，这对于对象来说是全局状态之一。
  - 可以先只写转移，之后添加转移条件。
  - 读往往只会涉及到内部状态转移，而不会涉及到外部状态转移，所以条件由内部维护
  - 所谓不学无术啊。。。很多东西学习新概念自然就懂了。
* 参考
  - [[https://www.zhihu.com/question/28292740][什么是函数式编程思维 知乎]]
