#+TITLE: 编程思考
#+DATE: 2017-07-07
#+LAYOUT: post
#+tags: 编程
#+CATEGORIES: 编程

* TODO 计算模型
** 概要
   计算模型不只一种，而在不同的计算模型下对于计算过程有不同的描述。程序语言出现的目的在于压缩这些描述。压缩这些描述的技巧在于尽量找出重复的元素。我们成这种做法叫提取复用元素。一般可以复用的元素包括：
   - 变量（复用内存）
   - 函数（复用计算过程）
   - 类型
   - 对象（同时复用内存和计算过程）
   同时各个编程语言对于相同的复用元素的复用能力有不同的设定。类似过程式编程，函数一般不是第一类对象，不能作为参数或返回值。在函数的复用能力上不如函数式语言。
   然而，编程语言的复用能力并不是衡量一门语言的唯一因素。由于程序员是容易犯错的人，这在C/C++的使用中已经被证明了，所以压缩格式并不是单纯以压缩率来确定的，尽管不同的压缩方式（语言特性的组合）确实有区别，但我们可以在保证一个压缩等级的情况下选择更加适用于程序员编写程序的压缩格式。所以另一个问题是如何构造安全和简洁的压缩格式，也即程序语言。后一个目标其实更为重要，因为现代语言能提供压缩等级不多。
** 一般过程式语言的函数和函数式语言的函数
   过程式语言是依靠改变状态来实现运算的，但函数也有返回值，如果我们不使用该返回值，这个值也就不会其作用，但是这个值有时也可以像函数式语言一样控制计算。在过程式语言中返回值可以反映部分状态信息。过程式语言读取并改变状态就是全部了。而函数式语言比较简单，只有映射一说。
   对于过程式编程语言来说函数的返回值可以看做当前状态的映射，所以对于改变状态之后值也可能会不同。
** 学习语言的思路
   首先是要明白这门语言提供了什么来支持计算，一般该有的都有。
** C语言
   作为典型的过程式语言，这个语言能描述的东西分成了三类，读、写、运算（读和写的对象是内存，而运算是不会改变内存的，这样就分成了三类）。当然从函数式语言的角度上看，也可以分成两类，写和运算（读也是当作一种运算）。个人在编写C语言的过程中最大感觉是但这三者分得比较开时，往往能降低一定的编程复杂度。无副作用的函数可以看作是运算。而有副作用则应看作过程，这类过程的接口需要比较多的说明才能被理解。相比之下无副作用需要的额外说明相对较少。
   另外，把读看作运算可以提高抽象程度，所以C++可能也倾向于此。当然，过程才是编程的重点和难点，区分好写和运算只是降低了复杂度而已。
* 关于程序结构
  目前看来，偶尔看到有人用建筑来类比程序，因为建筑需要严格按照依赖顺序来完成。理解一个程序也是一样的，需要摸清依赖顺序，才能决定看到什么位置。
  C语言中main依赖进程全局环境，虽然不一定使用。
  一个过程运行的时候依赖，满足依赖条件的情况下才是完整的一个流程。设定接口的时候大体知道其依赖。单单摸清函数的顺序是无解的。
* 关于抽象化和具体化
  突然发现，编程其实是不断具体化的过程，解决问题的过程其实是抽象化的过程，一般完成了抽象化才可以开始具体化。实际编程的流程中其实很复杂。一般来说实现模块的行为是一个具体化的过程，但目的是抽象化，对于模块的实现者来说可能遇到抽象好的底层模块，这是就发生问题了。其实有各种各样的结构划分方法，独立的模块，自底
  一个模块的关键在于生命周期，无论有多少个循环或者分支，主要的状态变化不能缺少。
  
* 依赖和变化
  一般来说越容易变化的部分要让依赖它的尽量少，而且这种依赖要局限在局部。数据结构和对象的处理就是这么个道理，数据结构便于添加新函数或者新接口，而对象便于添加新类而不改变接口。不容易改变的东西越要在上层。
* 控制反转
  控制反转区别于一般的控制流程，这是用一个普通的程序就可以解释了，一般一个程序会import一些库来使用，使用库的接口来组成一个程序，但如果是框架的库就会导致这个程序被框架调用。程序还是依赖框架实现，但是控制流不是从程序进入框架，而是从框架进入程序。也就是静态的依赖和动态的依赖已经相反了，这就是控制反转。反转是相对于静态的情况。使用继承的时候很多时候就意味着控制反转。
  这里就涉及框架，框架和库的一大区别是框架定义了自己的控制流逻辑，使用框架的时候我们编写的逻辑会被注册到框架中之后被框架调用。（也就是程序依赖于框架，但是却是框架调用程序），所以进一步的，要实现依赖注入，我们定义的对象需要其他的机制来生成，类的编写依赖于注入的接口位置。这个类的对象最终由框架来建立，也就是控制反转的机制。依赖注入本身就意味着控制反转。
* 自底向上和子顶向下
  编程其实都是由抽象到具体的过程，基本上都是自底向上。除非是为了抽象出东西来使用。也就是为上层模块编写模块的时候。任何一个模块都要确定其底层是什么，如果这个底层离模块接口过于远的时候，大概无法直接自底顶下来解决这个问题。直接那样会有大量重复的代码。这个时候需要从函数的层面转化，把眼光从放到更宏观的模块层面，通过先定义小模块来实现大的模块。尤其是分层的模块。
* 编写基础
** 函数的实现
   一个函数一般会静态依赖很多其他组件，需要分析的依赖有两种，静态的和动态的。如果是控制反转那么之后这个函数就会被调用。但是内部实现用的很多还是静态的。如果控制反转了，那么一般就依赖倒置了。依赖什么的一般来说只要看这个函数的实现使用了什么就可以了。一般多数依赖都在下层。来自上层的接口一般在下层函数定义中直接使用的接口都是下层的依赖。本质上所有的名词都带有依赖的某个实体。这种依赖还是当作单向的比较好。要实现倒置，我倾向于使用依赖的的某个实体来完成间接的指向。
  
** 类的实现
   类是函数和数据的聚合体，使用的方式和函数不同，相比一般的函数。类最重要的是数据。而于数据强相关的是类的构造过程
* 关于一个函数的前条件和后条件
* c语言中弱化的引用透明性
  在C语言中没有闭包（当然过程式语言也是没有并发），
* 阅读代码和接口
  一个程序其实最上层的接口就是用户接口，这个接口一般不会有更多的被依赖，最多加一个GUI之类的，从这个点入手是最容易把握住程序模块划分的。
* 模块和数据流
  很多时候数据流的方向不能表示模块间的关系。本质上是依靠依赖关系来完成模块的组织的。
* 动态语言和静态语言的抽象
  动态语言的一个特点就是对于类型的约束其实很小，一个变量往往可以是任意类型，静态语言在声明变量的时候就需要明确其类型了，对于类来说暴露变量往往就意味着暴露实现，所以静态语言往往会有一些getter,setter一类的写法，但是对于动态语言来说不存在这个问题，暴露变量名其实和暴露函数接口差不多，都不会涉及到相关实现。
* 泛型和多态
  泛型也叫做参数多态，也就是说两者的目的是相同的。
* 关于一个模块的生命分析
  一个模块接口，各个接口一般会存在一定的依赖性，或者常用的使用组合（或者序列），区别于模块接口的还有内部的函数，这类函数有些特点，就是为了完成一件事情，很多时候只是被另一个接口调用。这类接口的特点是其前条件和后条件的描述特别简单。这样才有描述的必要，如果本身接口的设计就带有复杂的逻辑，就没有必要把逻辑分开。主要的关键就是问题描述的时候，
  首先对于模块的设计来说不会太多要求外部某些条件的满足，就算有也应该使用接口来描述这个满足的过程。用户能做的是使用接口的参数和返回值，或者副作用来通信，先忽略副作用，比如一个队列，用户先有需要存的值了才可以满足调用的依赖。也就是说生命周期的完成需要用户完成接口的依赖，副作用也类似。用户需要的是返回值或者副作用。大部分时候需要满足的是调用的前条件，也就是接口参数的完全可用状态才会调用接口。有时候是完全使用接口。
  从函数式编程的角度上看就是一个函数多数时候就是内部同类状态的变化过程的实现。使用条件来描述程序的问题就是比较理出一个同类状态的状态机的情况。保证状态机的简单性是编程的关键。
  C语言也好、C++也好，一个最大的问题是原有的类型不够丰富。通用类型不过多，所以想使用无副作用的函数表述也会比较困难。相比之下C++使用函数式编程的时候还是需要比较小心。
* 特殊的函数
  有些函数本身对于程序来说没有副作用，对于函数式语言来说，无副作用只是状态的一种描述。
* 描述的过程和目的
  一个过程中至少会有一个主要的目标，或者操作一个对象完成其生命周期，或者一步一步完成交互。一般来说都可以简化成操作某个对象完成器生命周期（不管是否有明确定义）。这种时候其实线性代码写多长都可以，只要生命周期完成的都可以了，只是一般可以还是简化一下，之后就是作为一类只是被模块调用的函数。有些函数是只被调用一次，有些是被调用多次。很多时候原来只是设计来只被调用一次的代码可能会被调用多次，这是就需要为这部分代码编写一个模块了。要不然没什么意义。当然还是会有很多独有的函数，这个没有问题，保证不要污染空间就可以了。
* 复杂度
  分析了很久，过程式编程的主要复杂度是状态一次需要处理的太多，所以需要使用函数来把这些东西分离。这样编写一个函数的时候就可以比较好的实现，也比较好设计单元测试。
  函数式编程没有这个问题，但是依旧会复杂性过大。这里
* 什么时候新写功能函数
* 依赖性、编程、副作用
  依赖性可以主要的目标就是摸清模块或者各个程序单元之间的关系，明确这个单元需要什么前条件，依赖它的模块需要满足其调用条件。这是依赖它的模块代码编写的主要任务。而这个模块依赖的内容则指明了其需要满足的条件，也是这个模块需要编写的主要内容。
  工业界主要使用过程式语言，依靠副作用来完成一个程序。比如对一个文件写内容，大体上分成三个状态：
  1) 打开文件
  2) 向文件写入内容
  3) 关闭文件
  
  也就是我们只要设计三个接口，在依赖它们的模块中依次调用即可，也就是走一个至少三个状态的状态机，达到终止状态就可以了。这之中会产生副作用。一般来说，依赖它们的模块就是实现一个自动机的过程，异常什么的，当然需要处理。达成状态机就可以使用。状态机的目标是达成最终条件。用状态来表示条件。
  静态的过程分析到了这里其实基本到头了，接下来就是如何编写程序了。而且有一个问题，纯函数式语言是如何完成原本需要副作用来完成的任务呢？
  编程大部分的程序状态的转移过程都需要简单，一个函数不能都太多的状态转移，一个函数里面的循环一般一个就足够了，递归一般由一个函数单独使用。如果是线性逻辑。接口显然都是线性逻辑，如果是程序则要使用分支和循环逻辑来组织代码，所以一个模块的设计主要还是在于算法。关键在于一个模块的任务要在主流程或者接口中显然地表现出来。有依赖就做不到引用透明。
* C语言和Python的比较
  函数式语言中必须有丰富的类型才可以，能用函数头表现足够的信息才是问题的关键，Python也好，C++也好，丰富类型系统是十分必要的。可以大大降低副作用的产生。副作用带来的问题是程序的编写十分麻烦。好在C语言的可以使用文件作为一个单独的编写模块，除了本文件的变量以外其他文件的变量可以根据需要添加。稍微麻烦一点而已。丰富可扩展的类型系统可以减少副作用的影响。
* 引用透明性和无副作用
  引用不透明意味者依赖于外部的变量，原本在函数式语言中也会有这个问题，但是函数式语言变量不可变，所以也就不会出现引用不透明的问题。
* 关于子任务和父任务
* 面向对象
** 类的设计
   
* 生命周期的问题
  
* 编程语言的特性和共性
  一般编程语言都有自己的特性，先总结一下这些特性，首先要知道这门语言使用的计算模型，是图灵机还是lambda演算（还是其他，不过主流就这两种）。无论是图灵机还是lambda演算，它们都离不开计算（否则怎么叫计算机呢）所以最基本的是语言如何进行算数运算，计算机运行的过程其实全部都是算数运算（可执行代码都是二进制的）。最基本的是四则运算，其他更加复杂的运算都可以基于这些和语言的其他机制来模拟，当然有些语言可能把它作为我基础的语言元素，这个也需要学习。有了计算当然不能离开计算的对象了，所以需要有基本的类型系统，一开始是先是初级的类型系统，符合类型要之后再看。接下来就是抽象了，否则写出的复杂一点的程序都不能看了。首先只有计算和数据写出来的叫计算过程。我们需要有东西来为这个计算过程命名，之后复用，这就是函数命名，或者说过程抽象。同时我们操作的运算对象可能十分复杂，所以还需要对数据进行抽象，也就是变量命名。另一方面，我们编写计算过程的时候，如果只是一条指令一条指令地编写，那样是不能描述类似无限这样的情况，对于不知道合适要停止运算的情况就无法描述了，所以需要一种可以描述无限的代码结构，或者通过跳转（如C语言的goto）来达成，或者通过循环，或者通过递归，具体要看语言采用的方案了。需要注意的是递归拥有的能力远不止如此。可以独立作为一种特性来看待。
  
* 关于抽象和函数定义（符号定义的思考）
  一般的思考是，对于一个符号的定义如果使用了其他符号，则可以认为该符号的抽象层次可以高于其他符号。然而，没那么简单，符号的定义可能是相互的。虽然一般不至于循环定义但是如果几个定义间相聚很远的话十分难以理解，而且要认为它们的抽象层次是一样的。但我们认为一个符号的抽象层次高于另一个符号时，可能又有一个符号的定义同时使用了这两个符号，所以其实抽象层次是意义的，所以当一个符号的定义涉及到了另一个符号时，如果哪个符号也是全局的，那么这两个符号的抽象层次其实是一样的。那如果用到的符号是局部的呢（如C语言的static）？在外面不存在两个符号的比较，所以也不是问题吧。。。所以啊。。。抽象的关键还是在于隐藏。同时暴露的符号还是属于同一个抽象层的。但这是C语言的偷懒方法。。。。同一个抽象层的划分还是必要的。按抽象层次划分已经试过了，太过复杂，所以可以按功能、副作用相关行什么的来划分。所以之后的研究方向就是在一个抽象层对各个符号进行划分。
* 数据类型的理解
  数据类型的理解其实没有足够的，
* 关于接口继承和抽象到具体的过程
* 自动内存管理
  其实C语言也有自动内存管理，虽然这是由编译器提供的，它属于管理可以在编译期确定生命周期的内容。如为了支持函数调用而使用的堆栈。
  自动内存管理的直接目的是让名称的生命周期和内存保持一致，也就是说只要实现了这一点就称得上自动内存管理。至于使用的是引用计数还是垃圾回收那又是另一回事了。
* 关于模块化
  对于过程式语言，不得不使用作用域比较大的变量，如全局变量或者静态全局变量。由于函数的副作用无法重接口就看出来，所以看到一个模块中的函数就可能需要考虑其是否会对一个全局变量造成修改，全局变量越多造成的负担越大。所以模块化的目标是降低这个复杂度。并不是所有函数都会修改所有全局变量，而且不同的全局变量往往值是正交的，同时也不是所有函数都有副作用。
** TODO 可能的方案 [20%]
   果然全局变量的问题还是无解的，一个变量被设定为全局的本身意味着要写函数来改变它的值，所以问题是要如何选择是否将一个变量设定为全局的。所以关键是对静态变量的作用域的设定。模块化的关键是限制某些要设为静态变量的作用范围，宏观上看，全局变量的改变是运算的目的，而静态全局变量是支持运算。对于单进程程序而言这样不会造成问题。
   问题变成了如何减少一个函数需要 *考虑的变量数量* ，为了这个目的而模块化。
   如果全局变量之间是正交的，分开为不同的模块是可行的
   - [ ] 减少符号的做法只是缓解C语言的问题，不可太过执着。
   - [X] 全局变量在一个文件中可行吗？
   - [ ] 一个过程依赖的变量要最小化，也就是最小化其可能的最大副作用。
   - [ ] 如何利用功能模块化，有副作用的模块和无副作用的模块是分得比较开的。
* 关于编程的思维
  实际阅读代码的过程，很多代码其实更像是实现设定好了各种前条件，再零散地写出，没有过于在意顺序，对于阅读者来说非常麻烦，所以我倾向于使用比较简单的写法，如保持分支的树型。对于Python一类的动态语言，有需要的时候进行类型检查。
* 过程、模块、依赖性分析
  不同的语言提供了不同的封装方式，当然现代语言提供的封装方式都比较统一了，不像C语言，没有明确的语言级别的封装，还需要依靠在多个文件中编写或者使用静态变量的方式，还是比较麻烦的。有些语言还用闭包来做这个事情，也是比较扯。
* 概念到实现
  现实的概念中有很多联系，我们先把能直接用数据表示的概念用内存表示，之后再使用粘合剂将各种内容联系起来。
* 解答
** 全局变量放在一个文件可行吗？
   不可行，这样还要static全局变量做什么？一个函数的符号本身，
* 关于大型结构体的思考和化简
  大型结构体中各个字段如果都是正交还好，但是很多时候存在结构体间的值是相关的，也就是你改变一个值就需要改变另一个字段的值。能把相关的字段合并为一个字段最好，有时甚至可以消去，有时甚至可以消去（当它是可以从其他字段直接计算的时候），如果不能，要区分开与其正交的字段，同时要理清于其相关的字段的依赖关系，哪个在前，哪个在后，没有依赖的字段要先修改，之后慢慢计算楚依赖它的字段的新值。
* 编程语句块的独立性和建立计算
* 关于多进程和多线程
  但前计算机的进程仍然是一个自动机的动态运行的概念，所以目标仍然是收敛于某个状态。多进程编程要考虑不同进程的状态的相互影响，而多线程编程则是有共有的状态，相互影响的部分和多进程一样。目前还想不出两者在概念上有和区别。或者只是代价的区别而已？
  Linux下的fork()复用了Linux环境，这是个优点。不过它同一个代码中，会有一些代码是不会被父进程使用的，也就是有只属于子进程的代码。父进程无所谓，只是增加了一段不会运行的代码而已，其他的和编写单进程程序没有太大区别。如果在运行完独有的代码之后还要运行公共代码，此时相当于要考虑两个后条件，复杂度似乎会增加。
* 关于如何阅读模块
  肯定是先知道模块的接口
  代码本来就不是线性阅读的，更接近树形
* 如何增量编写代理
  一个可行的技巧是使用class的不断继承来完成代码细节的编写，一个特点是抓住代码的主要矛盾，完成代码的主要逻辑，之后通过。
  - 状态会有多细分，一个程序需要表达多少状态，大多数状态都不需要表达。
* 事件驱动的基础架构
  主要就是这么几个组件：
  - 事件生成器，作为一般作为状态生成的最后一步，但只是状态之一。
  - 事件处理器，根据事件调用相应的处理函数，是状态切换的一个步骤。
  - 状态转移的其余部分。
  之后就是选择相应的设计顺序，如事件处理器和生成器的实现顺序。
  之后就是理解其基本数据结构了。
* TODO 关于对象
* 如何确定程序逻辑
  其实要从我们知道的入手，而不去做太多的假设
* 关于类型的制约
  一个函数的类型是确定的，所以其内容不稳定。范型函数可以可以描述更多的行为，何乐而不为呢?可以没有模板的C语言只能用宏来代替先了。
* 动态类型和模板
  
* 设计数据结构时如何先把结构的设想补全，细致的和大体的
* 关联数据结构和数据库
  关联的对象是什么，一般而言是正交的两个数据居，索引的结果是软水。
* 关于虚拟设备
  我们知道我们对于设备的认知，或者任何对象的认知取决于我们能获取的信息和改变的状态。对象也完全如此，我们完全可以只定义对象的接口，而使用不同的实现，而这个也是虚拟对象的前提，虚拟对象的前提。虚拟对象，所以没有可以想象的所有。
* 关于扩展结构体的理解
  结构体对字段需要有哪些假设呢？这要看接口，有些接口必须要使用这个，一般是在最前面和最后面有假设，所以为结构体增加字段并不会导致结构体出现问题。 
* 关于对象复用的概念
  对象复用其实引进了复杂度，而且往往是后续添加的优化，所以一般要保证复杂度相同。
* 关于阅读代码
  阅读之前肯定需要理解程序的运行逻辑，也就是至少需要知道代码的运行方式，有一定的运行例子来支持。之后下一步就是阅读运行逻辑的代码。很多时候这个东西并不是一个程序的最重要的地方，但却是我们阅读代码的起点。需要注意的是我们阅读到那个深度停止。虽然问题就是这个问题。`我的想法是需要一定的文档支持，最为重要的是看到我们需要阅读的模块就差不多了。即便只有我们需要的模块和其他模块的关系其实也是足够的了。只有知道我们对于这个模块的修改会对实际的运行有那些影响，就可以了。如同我们看待函数一样，我们只要知道它是做什么的就可以了，这就是模块化。所以关键是先知道有那些模块，模块的功能和交流方式。之后才是我们需要深入的部分。
  模块有同步的模块，异步模块以及混合的模块。功能
* 模块化、继承、分层、过程
  模块化无处不再，核心的思想在忽略细节分开处理，一个软件的各个部分可以不会互相干扰。程序设计语言中发类继承之类的就是为了方便模块化，大体上模块化就是软件开发的一个结果了。继承的情况下就要看一个类为后来者留下了多少空位，那些是可以改变，那些是不可以改变的。每个模块都应该是一个能够独立变化的实体，需要按照程序的设计来完成。在运行时一个对象也可以看作一个模块。一般来说，模块需要能够通信。一个模块的状态信息，或者说运行结果需要从被外部了解。这里有几个问题，模块能否独立运行，一个模块如果能够占用一个进程，那么独立性非常高，如果只是在同一个进程中，那么一般需要被主线程来分配使用。
  一般来说模块化常常被用于分层的结构。作为上层模块的基础模块，其实不能算是一个分层的结构，个人更喜欢把它看作一个嵌套的结构。外层依赖于内层，不然有种脱离了下层上层还能独立运行的感觉，大部分时候还是不行的。
  同理继承的时候父类还是看作内层，而子类看作外层，这样子类依赖父类的关系才比较容易表达。子类可以重写父类的操作这一点比较麻烦，如果真的是模拟物种进化的程序还好说。但是很多时候只是为了表达这种依赖关系。接下来面对的问题就是一个层次有多少个。
  需要注意的是一个程序就可以看成一个模块。一个可执行程序如何分解，首先是调用了哪些过程，单一项目。
  这个程序除了各种变量以外，直接调用的各种过程就是下一层的模块，一般来说main过程就会调用有限的函数，也就是有限的过程。这些过程很多是联系在一起的，本质上属于同一个模块，有些是独立的。C语言里面这个比较难分清。不过一般来说main函数只是使用一个模块的内容而已，所以也正常。通过main了解模块的使用方式就可以了。至少状态的部分切换可以看清了。所以可执行程序往往比较容易可以变成的库。区别在于提供多细致的接口。过程的关联性是对于过程式语言来说是需要重点关注的问题。对于过程式语言来说，一个模块的不同过程。就是这个模块的生命周期的构成。一般来说跟模块声明周期相关的程序往往不会出现在内部又反复调用的问题，除非和生命周期无关。不推荐这样。
  *这里再引入一个概念，生命周期，区别于进程，运行这类概念，面向对象语言也喜欢用生命周期来表达类似的概念。*
  如果涉及了不同的对象，就涉及了不同的声明周期，同类的不同对象有独立的生命周期，如果是Python这类把类当作对象的语言，对象也会存在生命周期。main函数大部分时候的作用就是启动一个生命周期。单线程情况下，生命周期的推进是单行的，多进程生命周期。这里还要分析一个概念，一个程序的运行能使用相互关联的进程。但是一开始总有一个主要的进程。所以一开始也要从main出发，所以多进程的部分又是各个模块，分别维护不同对象的生命周期。暴露的模块则至少会复杂进程的建立之类的。
  main其实就是打开一个模块的生命周期。
  其实从内核层面来说，进程也是一个有生命周期的对象，CPU跳转到进程使用的代码段即可。。。调用函数也是，控制流跳到了函数使用的代码段就可以了。关键在于跳转。过程依赖跳转。
  这里还有一个问题，作为一个模块，通过模块通信来推进其生命周期，通信的方式不止一种，一个模块可能会提供不同种类的通信来完成生命周期的推进。如一般Web服务器，提供了处理TCP连接请求和手动关闭的能力。
  main一般只是启动某个对象，
  对于无副作用的函数，在过程式语言体系中，可以看作生命周期，开始于函数调用，结束于函数返回的对象。
  模块可以分成根据运行的方式可以分成同步模块和异步模块，或者两者的混合。同步模块的就是通过被调用相应的接口来完成的。调用（或者说使用模块）就是模块的通信方式，
  模块间的关联方式可以有很多种，一个模块可以由多个模块组成。有时也叫依赖，这些需要从模块间通信方式来区别，如果模块的通信是单向，同时通信的过程不会改变调用模块的状态，那么两个模块就是有层次的，主动调用的一方层次更高，被调用的一方更低。如果双方都可以直接改变对方的状态，这里又涉及主动和被动的问题。客户端服务器模型就涉及客户端和服务器模块，虽然都是双向通信，但是两边都在事先定义好的状态集中转换，至于是同步的还是异步的并不重要。一部分代码只要能作为一个独立的自动机来运行，那么就是一个独立的模块。
  模块的区分要关注的是依赖关系，而不是进程如何调用什么的。相互递归调用了也要清晰，不过一般人不会这么做，除非就是明确的算法。一般的依赖就是有向无环图。
  一个模块的生命周期，只是模块的界限，模块的用处还需要设计，我们需要那些状态，什么时候是没用的恶需要我们自己去理解。
* 接口继承和实现继承的区别
  继承的一大需求就是复用代码，接口继承对外，实现继承对内。
* 同步模块、异步模块
  如果模块的初始化接口也被包括了，异步模块一般都是混合模块，一般对于进程间通信才会有完全的异步模块。
    本质上没有完全的异步模块，异步模块总是有同步的部分，至少要包括初始化过程、结束过程。这些同步的过程。异步程序的实现一般是依靠事件循环来维护，这个循环需要同步的过程来维护，异步的处理流程则是要独立开来，一般就是为各个事件绑定回调函数来使用。
    
  这些组件是在一个模块中的内容，需要注意的一点是一个函数除了是否有副作用以外，还有是否依赖外部的变量，一个模块哪怕无副作用，至少也不是完全引用透明的。只要不是完全的。异步的编程部分和同步的编程部分最好要区分开来，哪怕要在同一个main完成所有设置也是同样。一般来说退出只要
  #+BEGIN_SRC plantuml :file 编程思考/coding_core.png
  @dot
  #+END_SRC
  一般来说进入了主循环之后，很多操作一般要纳入事件处理的体系中。
  之后的同步部分大体上就是销毁对象。编写代码的过程一个重要的点就是如何安排程序的设计，那些是异步代码的实现。从一个同步函数的角度上考虑，一旦调用了主循环的代码，就会等到这个主循环完成工作之后返回再进行进一步处理，也就是说对于上层来说，依旧是使用同步的逻辑来处理。
  有了事件循环之后其实个各种接口都可以纳入到事件循环的框架中，如果新加入的事件比简单，其实使用了也无所谓。
** 同步模块和异步模块的区分方式
   一般来说，这取决于如何被调用，无论那个模块都至少要被调用才会有效。通信方式很多，比如异步的程序一般都会有一个事件循环，调用响应的方法，但是一般都是等这个方法执行完毕才可以完成。那么对于这个事件循环来说这是一个同步的模块。（Java中一个类代表一个模块）。一般异步模块是响应形式的，通过进程间通信来出发，所以条件天然有所不同。
** 异步模块的编写
   需要注意的是，一个模块中的各种函数也会存在依赖，但是会有相同的全局环境。
   一个类中的成员可以访问所有变量，所以是占用公共的环境，这就是类设计的基础，如果不希望某些被使用，就不该放在同一个类中，而需要独立实现。
   接下来就是事件源，
* 模块内的构建
  一个模块可能会很大，所以要在模块内也有区别的能力。
* 关于闭包和匿名函数的使用
  实现匿名函数的基础是闭包
* 关于封装、阻止内部数据被访问的原理
  封装的目的是什么呢，比起不让人看到，导致写出不够抽象的代码，最大的危险其实是可能导致不可预知的状态。一个模块或者对象在使用的时候有他的生命周期，一般是一个有限状态机的模式。暴露内部实现的问题是容易不小心导致错误的和不可知的状态发生。C语言的结构体默认暴露，所以子能靠自己自觉，这就对编程人员的要求多了点。还有一种情况，C语言中这种情况很多，就是对象（结构体）的状态集其实足够大了，不会出现不可知的状态的现象。但是对于高层的应用，不隐藏状态其实仍然会造成很多问题。自定义状态越多，状态被破坏的可能性越大。
  对了，这种现象叫做耦合。
* 如果通过阅读接口的依赖来分清模块
  
* 耦合的价值
  
* 接口实现
  前面已经看到了其实接口是对象生命周期的一部分，接口实现则是为了达成状态转移的结束。从接口返回也就是达成了结束条件。接口的实现就是从初始状态达成目标状态。哪怕是一个无限的循环，或者说有无限的变化，也至少要有用，比如Web服务器处理的请求概念上是无限的，但是实际上每次都至少有用，可以认为是一个往无限收敛的函数。至少是有序的。
  从这里就可以看出，具体编码大部分是为了收敛，对象的接口最终要有达到收敛条件的接口（生命周期结束）。
  main函数结束条件之一就是关键对象的生命周期的结束。
* 关于一个函数的编写
  一个函数的实现在不考虑调用的函数的情况下，其实我们需要在意的是算法层面的，而算法又有很多可以分成子算法。所以我们要看我们的理解，即便是主函数也应该这样。只是绑定的过程要比较多。有一点需要注意，函数的复杂度的问题。O(n)
* 面向对象+动态语言的编程语义分析
  首先是类，Python中其实没必要弄抽象类，类是生成对象的依据，一个对象需要的东西。变量，方法，变量其实更加基础，但是变量的设定一般在确定了方法之后，公共的变量至少提供了三个接口，读接口，写接口。其中写接口需要纳入一个生命周期中。但是问题在于有时变量的生命周期并不合适纳入到，如果是动态语言，赋值的时候就是初始化了。初始化和赋值但做一个操作就可以了。至于内部使用的变量，由于没有包装，所以变量的生命周期也需要分析，如果是语言内置类型。内置类型系统可以看作一个基础的模块。

* 算法实现
  算法的主要逻辑往往会比较简单，即便有些复杂，也可以把大的问题分解成为小的问题。一个算法往往一个最大的问题是简短，同时描绘足够的东西，这就要通过循环或者递归来达成，递归的分析相对简单。而循环需要完成对于循环不变量的分析。本质上没什么区别，都是使用归纳法的推理。其中循环在处理条件上有很多的麻烦点。
  一个需要顾虑的点是如果有多个可能的终止条件，类似判断对错的算法可能有两种终止条件。
  还有一个问题，就是对于当前状态，循环是要先检查还是后检查，目前大家倾向于先检查，原因是检查的代码不会有多少开销，即便重复也不会有多大问题，而如果后检查可能会导致有一个状态没有检查（初状态），当然偶尔也存在某些数据需要在检查时重复计算的情况，这个时候使用后检查可以降低开销。这个时候使用后检查也没什么不可以的，就是需要额外注意一下。
* 关于闭包
  闭包是函数的一种实现，Lua就是选用了这个策略的例子。
* 开发
  开发的一般情况不是从零开始完成，而是通常阅读别人写的代码，之后通过扩展这些代码完成自己的需求。
* 关于并发
** 竞态条件
   过程式语言维护各种状态，在状态切换时时还有许多局部状态要维护，问题是在并发的情况下，状态切换过程一般是通用的不同的状态会产生不同的切换结果，而在并发条件下，如果切换结果可能被改变，那么就产生了竞态条件。关键就是状态切换过程被破坏。
** 并发程序的正确行为
   在过程式语言中改变状态的操作只有一个，就是复制，也就是对于一般计算机结构的写内存的过程，由于这个操作一般指对应一条不可分割的指令，所以我们可以直接在编程语言层面对并发做限制。最严格的限制是对共享变量的操作不允许同时发生。但我们常常会5嫌弃这种做法的低效性，加锁的开销和风险常常困扰我们。所以又有不那么严格的限制，保证并发系统产生的结果与各个进程按照某种方式顺序运行长生出的结果一样，有时可以允许产生多于一个正确的结果。最后，类似于模拟扩散的过程我们完全可以不需要对变量作出任何限制，因为结果一定是收敛的。
** 控制并发的机制
   我们把每个访问共享变量的行为看作一个事件，并发系统中这些事件可以交错执行，只要分析每种交错执行的结果就可以了，然而这种方法随着事件和进程数量的增加而变得无法控制。为了可以控制，我们拥有方法可以限制交错的行为，大大降低排列顺序的数目。从而保证程序有正确行为。
** 根本困难
   时间和状态的问题，一直是一个比较麻烦的问题。
* 关于包装和抽象
  看过对于socket的包装和对于线程的包装，可惜如果作为包装来考虑，其实不好理解，因为必须要考虑socket或者线程的底层行为，但这样和抽象相悖。包装应该指的是接口级别的包装，不应该和抽象相互混淆。
* 模式识别
* 数据结构的操作
  对于过程式语言来说数据结构的操作其实比较简单，只要提供基本的几个就可以了。下面确定数据结构的状态集合，之后确定所有可行的状态转移。
  对于查询而言，基本的复杂度是 $O(n)$ ，然而，查询操作太过普遍，于是又出现了查询数据结构，但查询数据结构本身需要付出代价的，所以对于查询机会很少的应用，没必要使用查询数据结构。
  数据结构存在状态变化，无论是结构还是内容，我们设计接口的目标是将状态变化都表现出来。接口的目标就是如此，然而状态的变化在没有合适的状态机来表示，而计算机是一个精细得多的计算设备，所以用汇编表述的时候免存在中间状态。 而中断会发生在这之间，这也是存在并发问题的原因。如果建立的每个状态机模型都是原子操作的也就没有了问题。或者只在一个进程中。单线程程序中其实不会有各种程序。
  一个有趣的点是读和写，一个算法可以有读和写，但这是不方便的，编写程序的时候我们往往需要初始化的过程，这个过程其实就是之后读写的对象，同时运行的时候的局部作用域有时也需要我们构建，如果这个环境在栈中，就可以自动管理，如果在堆中要手动管理，这个就是自动变量，一般还是推荐使用函数的局部局部作用域，如果不影响代码的可读性，就可以使用块作用域。如果要把这个纳入考量，就是是否需要
* 状态驱动的编程
  
* 关于数据结构的简单分析
  数据结构都有关键状态变化，只要把握关键状态变化即可其他的都是次要的，或者随之改变的。一个数据结构（容器比较重要），尤其是比较通用的数据结构要包含足够的定义信息，关键是你提供的数据结构需要多大的灵活性，哪些需要在在定义时就设置，对于外部来说数据结构有哪些状态变化。
* TODO 关于函数调用链条如何达成所谓的分层？
  数据是如何传输的？
* TODO 关于运行，抽象运行这个概念需要的最少概念
* 错误
  过早考虑软件的类似名字空间和符号的管理这个东西其实有些不好，一般依照一般的组织原则就可以了。
* 关于粘合剂量
  
* 关于编写项目
  最根本的当然是完成一个虚拟机，达成对于计算机的所有抽象，而平常编写程序无非只是其中的一个部件或者整个虚拟机而已。最高级别的当然是一个可以执行的虚拟机。
* 开发的原因
  
* 关于阅读项目代码结构
  - 如何分模块（这是基本组件）
  - 如何通信（这是粘合剂）
* 前条件需要需要处理
  一个不能预知外界环境的系统会需要大量能检测前条件的接口，剩下的只能依靠计算机了。
* 不要重复自身
  这个其实不是一开始决定的
* 核心的问题是关系，各种对象的关系，问题
  问题经常有不同的层面，类似树，读的时候就是内部状态变化，树是状态转移表，而如果是add这种操作，我们操作的状态就是树了。                             
* 关异常检查
  异常检查其实就是检查后条件了，返回值其实也没有太大问题，但是如果异常要不断向上传递，返回值可能会不好安排，所以还是使用有独立类型的异常来完成。异常检查其实检查的是后条件，而前条件也是重要，对于容易造成异常的代码来说后条件和前条件都是重要的。网络编程要特别注重前条件。
* 自底向上
  现在看来传统的自底向上和自顶向下的争论意义不大，关键是状态的构建和状态的转化，如果状态转化的基础构建不行，那么何从测试呢？所以先是基础状态机的构建，至于某些基础接口的设计是之后的事情。
* 关于状态转移和接口
  内部的恶状态状态转移要清晰，但是接口是否要暴露这是后面的事情。一开始全部清晰一点比较好。
  本质上接口都会对于对象状态有限制，我们包装的时候要注意这一点。
* 前条件就是状态
  条件的选择其实要复杂地多
* TODO 能构建状态的自动机是否算是图灵完备的机器
* 副作用和主逻辑
  很多时候问题并不是主逻辑能直接完成的问题，而是通常阅读别人写的代码
* 编写项目
  一开始还是以模仿为主，所以受限于这种思维，其实编程不是这样的，所以现在的想法是先搞清除主流程之后才是，处理各个模块。在不同的阶段考虑不同的东西，粒度也会有所不同。
  定义的位置应该和使用的位置相近。
* 异步和同步
  异步的eventloop其实类似于自动机，不断获取输入作为事件来推进状态转移。而同步代码则有所不同，其状态转移取决于当前状态是否“完全”（这里认为一个完全的状态是可以计算出下一个状态的），像如果需要用户输入，那么必须到得到了用户的数据之后状态才可以完全。
* 阅读代码以及二次开发
  直接开代码其实是不对的，要先运行，之后不断添加日志和输出才是最佳的阅读手段，而补充不断脑补，因为可能是错的。
* 单一权责原则（SRP，Single Responsibility Principle）
  类或者模块应该只有一个修改的理由，这也是类的长度的指导方针。这个原则基于这样一个结论，系统应该组织成许多短小的类而不是巨大的类，每个小类封装一个权责。
* 主程序的权责
  主程序的权责其实很小，就是负责处理执行环境。学习系统编程其实很大的目的就是完成对这个任务的处理。
* 类的内聚
  一般来说一个类内部的函数的使用的类的变量越多，越是内聚。
* 类
  初期的编程人员基于语句思考编程问题，后来是基于子程序，现在是基于类。类是有一组数据和子程序。类的接口应该是一组明显相关的子程序。
** 一致的抽象层次
   继承的合理性测试，就是是否是一直is-a关系。一般一个类是否合理就看这个。
** 抽象和封装为什么共存
   抽象提供一个管理复杂度的模型，而封装是强制阻止用户看到细节。由于抽象容易被破坏，所以两者往往共存。
* 协程
  协程是子程序的一个更加通用的形式，子程序可以在一个点进入，之后在另一个点离开。协程可以在任意一点进入、离开和重新开始。
* 接口
  一个接口的实现应该是当前是哪个或哪些状态，使用哪个状态转移，至于自动机的输入，就是函数的接口中了。
* 关于多态
  使用多态可以方便之后的各种实现，可以完成抽象。
* 常态
  一个软件如何达到其常态是除了模块化之后最重要的部分了。
* 编程实例
  学习一门语言需要进行练习，为了节省时间，可以进行熟悉项目的练习，也方便对比。同时也可以深化对某些概念的理解。
  - Web服务器
  - 编译器
  - 爬虫
  - 网络库
* 函数式编程的区别
  前面的讨论都是基于过程式语言的，很多结论对于纯函数式语言来说没什么用，那么问题就在于如何使用参数和返回值来表现所有的问题。一个值在不同的函数间传递，从而达到了最终的目标，从这点上看解决问题的思路其实差不多。最大的区别在于函数式语言编写的程序，每个单元都是表述的对象间的关系，通过使用小关系组成大的关系，进而完成各种问题。最终得到的程序就是这种关系。到了这里其实最大的问题也很明显了。函数式编程。无论是何种编程方式，都设计如何表示复杂的问题，过程式语言是如何表述复杂的状态，函数式语言类似，如何表示复杂的代数结构。这种表示方式本身不能太复杂。
* 复杂度
  一个程序的复杂度其实主要看理解的时候同一时间可以有多少个智力实体。其中控制流是最大的因素。
* 零散
  - 接口的形式多种多样，不要局限于函数接口
  - 现代语言的运行和语言的特性息息相关，以C语言为例，变量的定义带来的是运行时它可以占有一个固定的内存空间。
  - 现代编程语言的编译结果是运行时描述，这是最基础的描述
  - 表达式的特性是只有一个返回值
  - 其实现代的设备的编译结果：汇编语言已经是最灵活的压缩格式了。最重要的是对于内存地址的直接访问，可以实现足够细的粒度上的代码复用
  - 异常的状态一个就够了。
  - 对于贴近操作系统的编程，没有副作用是不现实的。
  - 值传递和引用传递的区别，在于行为上的区别，传递一个变量的值还是传递一个表达式的值
  - 我们知道对象在创建时要调用构造函数，但是这其实会导致效率的问题，因为调用函数
  - C语言放回值为void的函数本身就意味着这不是一个计算过程，即使它使用的一个计算过程。
  - 一个状态下不断进行的行为，如果不改变自身状态，就只是计算而已
  - 求值所依赖的条件是什么，同样一个求职的过程，如何使他求值的结果发生改变，如何使其不变。如果求值过程不变，就会导致就会导致。
  - 为什么要自己定义别名呢，原因是如果有什么改变，如类型或者数据结构定义，我们很多时候也只要改动部分而已，而且也往往只是抽象层次的较底层。
  - 单向链表的粘合剂是next指针。
  - 什么状态转移，有了异常检查状态转移的描述就简洁多了，不过问题就变成了是否要及。
  - 转移和状态识别不知道要不要放到一块。一开始还是不喜欢放到一块，这样比较自底向上。
  - 锁可以在大范围内构建状态，比如独占的状态和松开的状态，这对于对象来说是全局状态之一。
  - 可以先只写转移，之后添加转移条件。
  - 读往往只会涉及到内部状态转移，而不会涉及到外部状态转移，所以条件由内部维护
  - 所谓不学无术啊。。。很多东西学习新概念自然就懂了。
* 参考
  - [[https://www.zhihu.com/question/28292740][什么是函数式编程思维 知乎]]
