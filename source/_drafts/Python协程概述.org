#+TITLE: Python协程概述
#+DATE: 2018-02-27
#+LAYOUT: post
#+TAGS: Python, coroutine
#+CATEGORIES: coroutine

* 前言
  基于事件异步IO框架中，调度的单位是事件处理函数。基于协程的异步IO框架的调度单位是协程。而一个协程的往往可以包含多个事件处理函数。这里就可以粗略看出，使用协程降低了一定复杂度（至少不需要设置那么多事件）。
  目前，Python中的协程的实现有很多种，包括：
  1) 基于greenlet的协程，使用C实现协程调度。
  2) Python 3.5开始支持的原生async方法。
  3) 基于生成器的协程，如Python3.5之前的asyncio和Tornado。

  目前，asyncio已经成为官方支持的协程库，Tornado也转向了对原生协程的支持，虽然仍然可以使用原先的协程库，但是原生的协程会比基于yield的协程性能要好。
* 协程定义
  Donald Knuth是一个子例程是协程的特殊情况。子例程一般被称为函数，只有一个入口（函数调用）和一个出口（一般是return），而协程是可以有多个入口点的。
** 定义
* 生成器的实现
  生成器可以把控制权交给调用者，所以如果作为一个协程，需要有一个程序能不断分配控制权，作为一个生成器，一大问题是，需要有一个程序来将控制权交回给它。这就是顶调度 *子例程* ，由于是子例程，所以不存在控制权无法重新得到的问题。
* Future回调的模式
* TODO 零散
** TODO Tornado和asyncio的协程通信模式
   这里协程其实涉及到两个：
   1) Tornado和Python 3.5之前的协程。
   2) Python 3.5之后的协程。
   
   所幸两者的实现原理是一样的。都是基于生成器来实现的，Python 3.5本质上是使用了内部生成器来实现的。协程是通过程序自定义的调度器来进行调度的，以及一个通信机制。这里都是使用Promise-Future通信模型。
   Promise-Future通信模型的基本思路是
** TODO yield from的语义  
   yield from 可以获取一个协程（生成器最终的返回值），生成器最终会返回一个异常StopIteration，这个异常含有value。就是这个协程的最终返回值。
** TODO Tornado的协程实现
   future线程间同步模型，
