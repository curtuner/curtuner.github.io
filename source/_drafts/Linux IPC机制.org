#+TITLE: Linux IPC机制
#+DATE: 2017-06-30
#+LAYOUT: post
#+TAGS: Linux
#+CATEGORIES: Linux

* 前言
  使用多道程序设计的有点，可以将一个大型的应用程序系统的复杂性降低，通过小型的简单的进程相互协作构建一个大型系统。这点对于熟悉函数式编程的人来说不奇怪，躲过使用小函数构建大函数来实现功能是被证明可行的。早期的程序涉及倾向域设计一个复杂的单进程程序。多道程序设计在Linux下受到推崇。
* IPC机制的发展
** 早期的Unix的IPC机制
   早期的Unix提供了管道、信号（软中断）和跟踪（Trace），然而它们都只能在有关系的父子进程之间通信。为了实现在没有关系的进程间的通信，又增加了命名管道。命名管道通过在文件系统中建立一个FIFO文件来实现共享，说白了就是建立的贡献资源
** System V IPC
   AT&T为了更好支持商业应用中的事务处理又增加了3中IPC机制，报文、共享内存和信号量机制
** BSD Unix对IPC机制的扩充：Socket
   可以看作对于命名管道的进一步扩充，使其适用于不同计算机的进程间的通信。相比其他，Socket其实是最通用的IPC手段。现在的Unix系统中的管道机制改成了使用Socket来实现。
** POSIX标准
   如今IPC机制已经是POSIX标准的一部分了。
* 实例
** 存储映射I/O
   linux mmap可以将一个给定文件映射到存储区：
   #+BEGIN_SRC C
     void* mmap(void* addr, size_t len, )
   #+END_SRC
* 信号量
** 概述
   一般讲到信号量，默认时进程间通信的信号量。也叫有名信号量。线程使用无名信号量来通信。因为线程Linux。线程也可以使用有名信号量，线程也可以使用有名信号量，但是使用复杂
** 基本操作
   1) 测试控制该资源的信号量
   2) 若此资源为正，则进程可以使用该资源。这种情况下，进城会将信号量减1，表示使用一个资源单位。
   3) 否则，若此信号量的值为0,则进程进入休眠状态，直至信号量值大于0，。进程被唤醒后进入步骤1
** 接口
   信号量的值代表资源单位，如果取值只有0或者1，则其实和互斥量差不多，获取资源的接口包括：
   #+BEGIN_SRC C
     sem_wait()
     sem_trywait()
   #+END_SRC
   一个阻塞版本，一个非阻塞版本。
* 思考
  - 进程的无副作用性，保持是否重要呢？
  - 文件系统其实管理着系统大部分的资源，虽然有些特殊的文件系统
  - 网络接口也是一种资源，共享的是资源的话对进程的依赖也不会太严重
  - Linux本身喜欢把资源当作文件来管理
  - 进程间的通信
    closed 
* 参考
  - 《Linux内核源码情景分析》
  - 《Unix环境高级编程》
