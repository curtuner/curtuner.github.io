#+TITLE: 程序如何加载
#+DATE: 2017-06-27
#+LAYOUT: post
#+TAGS: Linux
#+CATEGORIES: Linux

* 前言
  这里主要介绍ELF文件如何加载，一个比较重要的问题是，ELF文件中的代码段、数据段、BSS段在进程地址空间是如何分布的。加载的过程可以当作一个parsing的过程
* 页映射
  该机制先将内存和所有磁盘中的数据和指令按照“页”为单位划分，
* 创建进程的过程
** 创建一个虚拟地址空间，除了init程序，都是线通过fork来得到的。
   一开始，只要创建一个页目录即可
** 读取可执行文件头，并建立虚拟空间和可执行文件的映射关系。
   用数据结构表示
** 将CPU的指令寄存器设置为可执行文件的入口地址，启动运行。
* elf文件结构解析
  ELf文件有数据结构叫程序头表（Program Header Table），可以通过readelf -l 来查看
  
* 思考
  - C语言的指针是虚拟内存地址，但是指针的访问是被限制的，Segmentation fault就是段保护带来的
  - 进程的虚拟地址空间其实是一个虚拟的概念，只是一个内存模型，并不对于实际内存的布局。操作系统通过elf文件头建立ELF文件和虚拟内存之间的映射关系。
  - 有趣的一点是程序一开始执行就会遇到第一个缺页错误。
  - 通过对段机制的学习，我们知道操作系统并不关心各个段的内容，主要关心段的权限。段的权限种类并不多，重要的是读写执行3个属性，不可读写是没意义的，基本只有几种：
    - 以代码段为代表的可读可执行段
    - 以数据段和BSS段为代表的可读写段
    - 以只读数据段为代表的权限为只读的段
  - 我们虽然一般只考虑数据结构的逻辑，但已知逻辑段的内存块有时我们也叫数据结构，不宜过于拘谨。
  - BSS段要求的权限和.data的权限相同，所以属于同一个segment，一般通过把程序头表的p_memsz来增加为0的部分
* TODO 问题
  - [ ] 页是如何实现划分的，是依靠忽略二进制的后几位吗？
* FAQ
** 可执行文件为什要有时被称为映像文件？
   可执行文件在被装载时是被映射的虚拟空间。
** 可执行文件的section和segment的区别？
   两个在中文中都翻译成段，但实际是不同的概念。section是划分目标文件的概念，像.init、.BSS就是指的section。链接的时候主要是section在其作用。Segment是装载时才有的概念，节约物理内存，所以将相同权限的section划分到了一起。是装载时的基本单位。实际上，section和segment不一定要区分，只是我们选择的方案注定了我们要区分这个概念而已。
** ELf文件的View（视图）是什么？
   从section角度看ELf文件称为链接视图，从segment的角度看就是执行视图。
   在Linux下查看链接视图的方法是：
   #+BEGIN_SRC sh
   readelf -S a.elf
   #+END_SRC
   而查看执行视图的方法是：
   #+BEGIN_SRC sh
   readelf -l a.elf
   #+END_SRC
** VMA是什么？
   Virtual Memory Area，虚拟内存区域。虚拟内存分为很多区域，包括可读可运行的段，可读可写的段，堆、栈等。
** elf文件、线性地址和虚拟地址的关系？
   linux下不主张将程序分段，而主张分页，所以段基址一般是0，所以在linux虚拟地址是相同的
** 为什么在Linux没有看到段机制起作用？
   段机制在Linux的实现下只是走走形式而已，实际上我们把逻辑地址看作线性地址也不会有什么问题
* 参考
  
