#+TITLE: idris入门
#+DATE: 2017-05-13
#+LAYOUT: post
#+TAGS: idris
#+CATEGORIES: idris

* 前言
  最近看了[[http://www.tuicool.com/articles/YRZvem][程序和证明]] ，觉得很有趣，对我的启发也很大。文中一些例子使用了idris来表达，为此，我想乘着有时间把idris学一下。
* first-class的概念
  first-class结构意味着这个结构是被当作是值来对待：
  1) 作为函数的参数和返回值
  2) 存储在变量中
* curry-ho
* 两个重要的特性
  - Holes：代表不完全的程序
  - 类型是first-class
* 类型驱动开发
* 直觉主义的构造行
* 程序是类型的证明
  编写程序的过程就是载做证明。
** 命题逻辑
*** 肯定前件
    $\neg Q$
* 定义函数
  函数使用模式匹配来实现，idris要求对于所有函数都有类型声明。可以看到类型的声明是currying的，借此函数的实现其实更
* 依赖类型
  依赖类型意味着类型的定义依赖于其他类型的 *值* ，idris中类型是作为第一类对象的，也就是说类型可以被计算和操作，我们可以写函数来操作类型。
* 自定义类型
** 定义类型的语法
   无论哪种类型定义的语法都是一样的，
** 枚举类型
** union类型
   枚举类型的扩展，
** 递归类型
** generic类型
   以其他类型作为参数的类型，具有更高的描述能力
* first class type
  在idris中type可以存储载变量中，也可以作为函数参数和返回值
* type-driven的开发方式
** 使用type-driven开发
   1) Type：编写函数的接口，编好足够的类型信息
      #+BEGIN_SRC idris
      allLengths : List String -> List Nat
      #+END_SRC
   2) Define: 定义函数，可以只是框架，保留一定的hole
   3) Type：查看hole的类型
   4) 
* total
  total的函数保证对于所有well-typed的输入都能在有限时间内终止
  一个 missing case 可能会导致运行时出现无法预料的错误。
  idris默认情况下允许不完全定义的函数，这样可能产生错误的定义，所以可以通过指定编译选项来检查函数的完全性。
* IO
  IO是一个范型，表述了运行时系统的行为序列。我们不能编写直接和用户交流的程序，但可以编写函数描述交互的序列.
  do 引入了一个
* 接口：约束的范型
* 完全函数式编程（total functional programming）
  为了将公理体系纳入计算机中，构造出足够多的定理，语言的类型系统要扩充，同时要限制其能力，使其达不到图灵完备。要求：
  1) 所有的函数必须被完整地实现，即针对每一个可能的值都有定义
  2) 递归必终止（对应到命令式语言中，则循环必终止）；编译器有权拒绝一切它无法判断是否停机的计算。
  这种方法消除了停机不可判定问题，但表达能力受限。所以还需要其他的东西来修补。
  现实中不可判定是否停机的程序我们经常会写
  $\forall{n}{\in}\mathbf{N},0+n=n$
  $\Pi_{(n:{\mathbb N})}\ plus\ Z\ n=n$
* 在idris中处理副作用
  程序必须和外界交互，这时就需要有处理副作用的机制，而idris提供了处理副作用的库。一般来说，我们用一个idris函数处理数据时，要先读取用户输入，再检查输入是否有效，处理完成后还需要输出。
** 编写依赖状态的程序
   使用Control.ST库来编程和推理
* idris程序编写步骤
  先用一个简单的例子来描述：
  #+BEGIN_SRC idris
  double : Num a => a -> a
  double x = a * a
  #+END_SRC
  
* 思考
  - 类型系统的表达能力已经可以建模了
  - 一个概念的完备性总是让人厌烦
  - 程序的入口点是模块Main的main函数
  - 如果函数参数有表达式，则用括号括起
  - 一个程序的组成无非包括对其他模块或本模块的声明，数据结构的声明，函数
  - idris的目标是让我们用强大的类型系统来完成大部分程序的编写
  - 函数声明中，如果变量不声明类型则可以表示任何类型
  - 表达式和类型并没有严格区分，可以认为在idris中一切都是函数
  - data 之后声明一个construct
  - Type 视为一个命题，然而我们实际表示表达式来表达命题，在编程语言中要时时注意表达计算的语言和计算本身是分离的
  - 类型的定义过程就是引入表达式的过程
  - = 是一个依赖类型的构造器，代表一个”证明“的类型
  - 类型是命题，程序是证明
  - 保证程序正确性的关键是类型系统有足够的表达能力能表示我们的软件规范
  - 纯函数式编程中变量和函数不做什么区别，变量视为没有参数的函数，根据引用透明性，这个没有任何问题。当然如果允许副作用就不可行了。
  - 既然实现了一个抽象层就没必要记住它是如何实现的了
  - 类型声明中唯独不能出现字面值
  - 在设定类型变量上相当于载类型声明中就设定了实参名
* FAQ
** currying为什么是右结合的？
   每currying一个参数，就得到一个函数，所以是右结合的
** 如何对待原生数据类型？
   一般计算时使用，而做证明时则要小心，尽量不用
* 参考
  - [[http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html][官方文档]]
  - [[http://www.tuicool.com/articles/YRZvem][程序和证明]]
  - Type-Driven Development with idris
  - Programming and Reasoning with Side-Effects in idris 
