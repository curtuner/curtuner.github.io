<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[rdp代理概述]]></title>
      <url>/2017/11/15/rdp%E4%BB%A3%E7%90%86%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
本文只是一点学习的记录，对RDP协议数据的解析是实现对RDP会话的监控和审计的基础。本文的重点在对于RDP协议的介绍，以及xrdp和rdpproxy代理服务器模型的介绍。这是进一步开发RDP代理功能和堡垒机功能的基础。最后是一些个人对于堡垒机功能的开发的总结。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> RDP协议简单分析</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> RDP概述</h3>
<div class="outline-text-3" id="text-2-1">
<p>
RDP协议（Remote Desktop Protocol），是微软开发的私有协议<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>，让用户可以通过网络连接上远程的主机，并提供相应的图形界面。使用的时候，要求远程主机启动了RDP服务器，而本地使用RDP客户端连接。RDP默认会监听本机UDP和TCP端口3389<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>。目前大多数主流的操作系统都有RDP客户端软件，而RDP服务器软件少一点，但是Unix和OS X下也是有的。目前RDP协议已经出到10.0版<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>了。值得一提的是早期微软并不公开RDP协议，所以可以看到网络上一些早期的对RDP协议的研究都是破解的结果。目前连接远程Windows主机一般使用RDP来实现，所以如果堡垒机管理的机器中包括Windows主机，就有必要实现RDP代理功能。相对的，Linux虽然目前也可以运行RDP服务器，但是Linux的图形界面一直不是很稳定（这几年更是处于从X协议转向Wayland的过程，而Wayland暂时不支持RDP），所以对于Linux来说支持RDP倒不是很要紧。
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> RDP协议栈和实现分析</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> RDP协议层次</h4>
<div class="outline-text-4" id="text-2-2-1">
</div><ol class="org-ol"><li><a id="sec-2-2-1-1" name="sec-2-2-1-1"></a>概述<br><div class="outline-text-5" id="text-2-2-1-1">
<p>
RDP协议是建立在TCP协议之上的，和其他网络协议一样，RDP协议也采用分层的结构。其层次结构如下图：
</p>


<div class="figure">
<p><img src="./rdp代理概述/rdp.png" alt="rdp.png">
</p>
</div>

<p>
可以看到由上到下依次是：
</p>
<ol class="org-ol">
<li>功能数据层（RDP层）
</li>
<li>加密解密层（SEC层）
</li>
<li>虚拟通道层（MCS层）
</li>
<li>ISO数据层（ISO层）
</li>
<li>TCP层
</li>
</ol>
<p>
这个结构暗示了RDP软件需要实现协议栈<sup><a id="fnr.3.100" name="fnr.3.100" class="footref" href="#fn.3">3</a></sup>的来处理RDP协议的数据，事实也是如此。同时我们也可以看到这个协议栈和TCP/IP协议栈不同，它是遵循ISO七层模型的。
</p>

<p>
标准的TCP/IP协议栈一样，在传输RDP数据包时，一个协议层会对来自上层的数据进行包装，由于RDP协议层次从下到上依次是ISO层、MCS层、SEC层、RDP层，RDP数据包实际上是由TCP数据依次封装上ISO层数据头、MCS数据头、SEC数据头、RDP数据头的。下面对每层的数据进行简要的分析。
</p>
</div>
</li>
<li><a id="sec-2-2-1-2" name="sec-2-2-1-2"></a>ISO层<br><div class="outline-text-5" id="text-2-2-1-2">
<p>
ISO层使用了X.224协议，这个协议属于传输层的协议，但该协议只是ITU-T（国际电信联盟标准组）的建议，实际上它是借助TCP协议来实现。就提供的网络服务来说，两者基本是一致的，不同的是，TCP协议提供可靠面向连接 <b>流传输</b> 服务，而X.224协议要求提供可靠的面向连接的 <b>数据包传输</b> 服务。所以X.224协议使用了叫TKPT header的数据块对TCP流进行了定界。RDP数据包通过RDP协议栈后都会被TKPT头包裹。
</p>
</div>
</li>
<li><a id="sec-2-2-1-3" name="sec-2-2-1-3"></a>MCS层<br><div class="outline-text-5" id="text-2-2-1-3">
<p>
MCS（MultiPoint-Communication-Service），使用了T.122/T.125协议实现了多点通信，其目的是创建一个域并将用户加入该域，同时为域开辟不同的通道，以传输不同类型的数据。
</p>
</div>
</li>
<li><a id="sec-2-2-1-4" name="sec-2-2-1-4"></a>SEC层<br><div class="outline-text-5" id="text-2-2-1-4">
<p>
加密解密层，用于对RDP层数据进行加密，保证了通信的安全性，但也影响了RDP代理的实现，这个之后讲到。
</p>
</div>
</li>
<li><a id="sec-2-2-1-5" name="sec-2-2-1-5"></a>RDP层<br><div class="outline-text-5" id="text-2-2-1-5">
<p>
RDP层规定了连接初始化的顺序和格式、鼠标/键盘等输入信息的格式，图形命令的格式、某些常用通道数据的格式等，也是我们最为关注的一层，RDP的的主要作用是由这层定义的。也是我们理解RDP协议的关键。
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> xrdp协议栈代码简要分析</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
RDP协议是加密协议，从前面可以看到RDP层的下层就是SEC层，所以为了获得能够处理的数据至少要让数据通过SEC层的接口解密，同时这也意味着代理服务器的两条连接会保持两个密钥。所以是无法直接通过TCP连接直接转发的，RDP代理服务器必须使用协议栈来组包和解包。需要注意的是作者对于协议栈有一些优化，本文不会涉及到。
</p>

<p>
xrdp的协议栈的实现位于其xrdp源码的libxrdp目录中，首先看一下libxrdp/libxrdp.h文件中各层对象的定义：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* iso */</span></span><br><span class="line"><span class="keyword">struct</span> xrdp_iso</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_mcs *mcs_layer; <span class="comment">/* owner */</span></span><br><span class="line">    <span class="keyword">int</span> rdpNegData; <span class="comment">/* bool */</span></span><br><span class="line">    <span class="keyword">int</span> requestedProtocol;</span><br><span class="line">    <span class="keyword">int</span> selectedProtocol;</span><br><span class="line">    <span class="keyword">int</span> failureCode;</span><br><span class="line">    <span class="keyword">struct</span> trans *trans;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mcs */</span></span><br><span class="line"><span class="keyword">struct</span> xrdp_mcs</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_sec *sec_layer; <span class="comment">/* owner */</span></span><br><span class="line">    <span class="keyword">struct</span> xrdp_iso *iso_layer;</span><br><span class="line">    <span class="keyword">int</span> userid;</span><br><span class="line">    <span class="keyword">int</span> chanid;</span><br><span class="line">    <span class="keyword">struct</span> stream *client_mcs_data;</span><br><span class="line">    <span class="keyword">struct</span> stream *server_mcs_data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">list</span> *channel_list;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* sec */</span></span><br><span class="line"><span class="keyword">struct</span> xrdp_sec</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_rdp *rdp_layer; <span class="comment">/* owner */</span></span><br><span class="line">    <span class="keyword">struct</span> xrdp_mcs *mcs_layer;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_fastpath *fastpath_layer;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_channel *chan_layer;</span><br><span class="line">    <span class="keyword">char</span> server_random[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">char</span> client_random[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> client_crypt_random[<span class="number">256</span> + <span class="number">8</span>]; <span class="comment">/* 64 + 8, 256 + 8 */</span></span><br><span class="line">    <span class="keyword">struct</span> stream client_mcs_data;</span><br><span class="line">    <span class="keyword">struct</span> stream server_mcs_data;</span><br><span class="line">    <span class="keyword">int</span> decrypt_use_count;</span><br><span class="line">    <span class="keyword">int</span> encrypt_use_count;</span><br><span class="line">    <span class="keyword">char</span> decrypt_key[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> encrypt_key[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> decrypt_update_key[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> encrypt_update_key[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> crypt_method;</span><br><span class="line">    <span class="keyword">int</span> rc4_key_len; <span class="comment">/* 8 = 40 bit, 16 = 128 bit */</span></span><br><span class="line">    <span class="keyword">int</span> crypt_level;</span><br><span class="line">    <span class="keyword">char</span> sign_key[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">void</span> *decrypt_rc4_info;</span><br><span class="line">    <span class="keyword">void</span> *encrypt_rc4_info;</span><br><span class="line">    <span class="keyword">char</span> pub_exp[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">char</span> pub_mod[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> pub_sig[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> pri_exp[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> rsa_key_bytes; <span class="comment">/* 64 or 256 , 0 = no rdp security */</span></span><br><span class="line">    <span class="keyword">char</span> fips_encrypt_key[<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">char</span> fips_decrypt_key[<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">char</span> fips_sign_key[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">void</span> *encrypt_fips_info;</span><br><span class="line">    <span class="keyword">void</span> *decrypt_fips_info;</span><br><span class="line">    <span class="keyword">void</span> *sign_fips_info;</span><br><span class="line">    <span class="keyword">int</span> is_security_header_present; <span class="comment">/* boolean */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* rdp */</span></span><br><span class="line"><span class="keyword">struct</span> xrdp_rdp</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_session *session;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_sec *sec_layer;</span><br><span class="line">    <span class="keyword">int</span> share_id;</span><br><span class="line">    <span class="keyword">int</span> mcs_channel;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_client_info client_info;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_mppc_enc *mppc_enc;</span><br><span class="line">    <span class="keyword">void</span> *rfx_enc;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
<p>
以上每个结构体对应一个协议栈的通信层，可以看到这几个结构体的定义存在依赖，和协议栈层次顺序差不多，如下：
[[]]
接下来在看一下相关的接口（为了节省篇幅，所以只列出iso层）：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* xrdp_iso.c */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> xrdp_iso *</span><br><span class="line"><span class="title">xrdp_iso_create</span><span class="params">(<span class="keyword">struct</span> xrdp_mcs *owner, <span class="keyword">struct</span> trans *trans)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">xrdp_iso_delete</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_init</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_recv</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_send</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_incoming</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_detect_tpkt</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br></pre></td></tr></table></figure>
</div>
<p>
学过Python就知道这个和Python成员函数定义的接口相似，因为这个xrdp使用了面向对象的技巧来组织程序。可以看到这里存在构造函数（xrdp_iso_create）、析构函数（xrdp_iso_delete）、各个成员函数，self参数让他们的运行必须依赖于相应的对象（也就是前面的结构体实例）。
作者这么做大大提高了代码的模块化，使其更加容易和RDP协议的概念向对应。
</p>
</div>
<ol class="org-ol"><li><a id="sec-2-2-2-1" name="sec-2-2-2-1"></a>RDP协议栈接口<br><div class="outline-text-5" id="text-2-2-2-1">
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* xrdp_rdp.c */</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> xrdp_rdp *</span><br><span class="line"><span class="title">xrdp_rdp_create</span><span class="params">(<span class="keyword">struct</span> xrdp_session *session, <span class="keyword">struct</span> trans *trans)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">xrdp_rdp_delete</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_init</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_init_data</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_get_fastpath_bytes</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_init_fastpath</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_recv</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s, <span class="keyword">int</span> *code)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s, <span class="keyword">int</span> pdu_type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_data</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s,</span><br><span class="line">		   <span class="keyword">int</span> data_pdu_type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_fastpath</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s,</span><br><span class="line">		       <span class="keyword">int</span> data_pdu_type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_data_update_sync</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_incoming</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_process_data</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_disconnect</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_deactivate</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_session_info</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">const</span> <span class="keyword">char</span> *data,</span><br><span class="line">			   <span class="keyword">int</span> data_bytes)</span></span>;</span><br></pre></td></tr></table></figure>
</div>
</div>
</li>
<li><a id="sec-2-2-2-2" name="sec-2-2-2-2"></a>session<br><div class="outline-text-5" id="text-2-2-2-2">
<p>
为了审计，首先需要获取RDP协议栈解包后的数据。审计的数据应该是RDP客户端通过代理连接上目标主机后的整个会话的记录。xrdp使用对象实现了这个概念，会话对应了一个对象xrdp_session，下面是它的定义：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> xrdp_session</span><br><span class="line">{</span><br><span class="line">    tintptr id;</span><br><span class="line">    <span class="keyword">struct</span> trans *trans;</span><br><span class="line">    <span class="keyword">int</span> (*callback)(<span class="keyword">intptr_t</span> id, <span class="keyword">int</span> msg, <span class="keyword">intptr_t</span> param1, <span class="keyword">intptr_t</span> param2,</span><br><span class="line">		    <span class="keyword">intptr_t</span> param3, <span class="keyword">intptr_t</span> param4);</span><br><span class="line">    <span class="keyword">void</span> *rdp;</span><br><span class="line">    <span class="keyword">void</span> *orders;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_client_info *client_info;</span><br><span class="line">    <span class="keyword">int</span> up_and_running;</span><br><span class="line">    <span class="keyword">int</span> (*is_term)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> in_process_data; <span class="comment">/* inc / dec libxrdp_process_data calls */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> source_info si;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
</div>
</li>
<li><a id="sec-2-2-2-3" name="sec-2-2-2-3"></a>libxrdp接口<br><div class="outline-text-5" id="text-2-2-2-3">
<p>
本质上这个实现了session接口
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> RDP连接保持状态的通信</h3>
<div class="outline-text-3" id="text-2-3">
<p>
完成RDP协议连接初始化后，进入协议保持阶段。客户端会向服务器发送：
</p>
<ol class="org-ol">
<li>输入数据包。
</li>
<li>键盘状态在数据包。
</li>
</ol>
<p>
服务器向客户端发送响应：
</p>
<ol class="org-ol">
<li>服务端图形更新数据包。
</li>
<li>服务端鼠标更新数据包。
</li>
<li>服务端播放声音数据包。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> RDP协议图形命令分析</h3>
<div class="outline-text-3" id="text-2-4">
</div><div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> 图形的绘制</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
虽然很多人长期和各种图形界面打交道，但是对于计算机绘图的分工其实并不了解。而理解RDP协议实用性，离不开这方面的知识。首先，RDP客户端时如何如何显示桌面的呢?如果什么都不去想，那么当然是直接从远程计算机上返回图片，假设这个用位图显示，则如果一个桌面的分辨率是1024*768，像素深度16bp，那么更新一次桌面的内容都需要传输1.5MB的数据，这当然是不可接受的。实际上RDP协议（包括其他的远程图形协议），会对数据传输进行各种优化，包括对最重要的进行压缩、部分更新、多通道通信之类的优化。当然本质上这都是传输图形，那么还有个问题，图片是哪里来的？规则的图形还好，但实际上就是图形渲染是现代图形系统不可或缺的功能，同时也是开销较大的功能。现代操作系统中，有很多图形都是动态渲染生成的，需要记住RDP客户端不会进行渲染的操作。所以RDP服务器的运行还需要依赖于其他的图形绘制程序，Linux下面是Xorg等X server。同理VNC协议也是一样，协议本身没有包括图形渲染的部分，所以实际运行还是依赖于某个X server。总之RDP协议只是压缩和解压图形（这里不是常规的压缩和解压的概念，只是和图形渲染这类生成方式相区别，这个之后会讲到），它的后面还需要生成图形的程序。
</p>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> 图形的压缩</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
图形的传输是RDP协议这类远程图形协议最被关注的部分，尤其是以前带宽还不富裕的时候。这里简单介绍一下RDP协议压缩图形的思路。首先是基本的压缩功能。可以把桌面显示的图形分成两类：
</p>
<ol class="org-ol">
<li>规则图形
</li>
<li>不规则图形
</li>
</ol>
<p>
规则图形意味这可以用简单的规则和参数来表示，如屏幕上的圆形，只要知道圆心坐标、半径和颜色就可以在屏幕上绘制，这种描述已经是对图形的最简单描述了，再好的压缩算法也不会达到更好了，当然为了进一步压缩传输数据量，以节省带宽，RDP协议会根据历史数据，采用只描述变化的做法。又进一步降低了数据量。另外我们观察操作系统桌面就会发现，桌面本质上是以规则图形作为骨架，在规则图形内部再填上各种不规则图形或者更小的规则图形。所以将规则图形和不规则不行分开表示可以降低提升管理桌面的难度。对于不规则图形而言，相对处理起来简单一点，就是采用压缩率更高的算法来压缩图形。最终RDP协议对于规则图形的处理反而要多。我们可可以看一下xrdp的登录界面：
</p>


<div class="figure">
<p><img src="./rdp代理概述/xrdp_login.png" alt="xrdp_login.png">
</p>
</div>

<p>
xrdp自己返回的界面，这个时候再看就可以发现除了上方那个中微子图片，其他除了文字的都属于规则图形，基本就是矩形和三角形组成的，加上配色单调，基本可以肯定不会占用太多的带宽。
有了这个思路，就可以看看RDP协议的具体做法了。
</p>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> 图形命令分类</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
我们使用RDP协议提供的功能时，最直观的就是它的图片
RDP客户端使用图形命令来绘制图形，图形命令大体上分成两类：
</p>
<ol class="org-ol">
<li>第一类图形命令（PDO, Primary Drawing Order）
</li>
<li>第二类图形命令（SDO, Secondary Drawing Order）
</li>
</ol>
<p>
两者的区别在于前者能够被Windows GDI命令直接调用并绘制到屏幕上，而后者是缓冲的数据（主要缓冲不规则图形）。可以根据两者的关系对它们进行分类，接下来介绍几个典型的指令。
</p>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> 图形命令实例</h4>
<div class="outline-text-4" id="text-2-4-4">
</div><ol class="org-ol"><li><a id="sec-2-4-4-1" name="sec-2-4-4-1"></a>RECT命令<br><div class="outline-text-5" id="text-2-4-4-1">
<p>
RECT时RDP绘图程序最常用的命令之一，这个命令会根据左上角的坐标、矩形的宽度，高度以及矩形的颜色让客户端在桌面上绘制该矩形。
</p>
</div>
</li>
<li><a id="sec-2-4-4-2" name="sec-2-4-4-2"></a>RAW BITMAP命令<br><div class="outline-text-5" id="text-2-4-4-2">
<p>
这个命令是绘制位图的命令。位图命令不断更新，从RAW BITMAP命令到COMPRESSED BITMAP, COMPRESSED BITMAP V2 这些命令利用自己绘制的
</p>
</div>
</li>
<li><a id="sec-2-4-4-3" name="sec-2-4-4-3"></a>MEMBLT命令<br><div class="outline-text-5" id="text-2-4-4-3">
<p>
MEMBLT命令的作用是将保存的RAW BITMAP绘制道屏幕上，属于PDO。从RDP服务端图形跟新数据包中可以提取memblt命令的参数：所画位图的索引号1:cache_id、所画位图
</p>
</div>
</li></ol>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> RDP代理</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> XRDP代理软件概述</h3>
<div class="outline-text-3" id="text-3-1">
</div><div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> xrdp</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
xrdp的功能远远不只RDP代理功能，我们可以从架构中看到：
</p>


<div class="figure">
<p><img src="./rdp代理概述/xrdp_overview.png" alt="xrdp_overview.png">
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> rdpproxy</h4>
</div>
<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> xrdp和rdpproxy的对比</h4>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 代理实现</h3>
<div class="outline-text-3" id="text-3-2">
<p>
XRDP代理程序首先会启动一个监听线程在3389端口监听RDP连接请求，如果收到请求，就创建一个处理线程，由该线程将连接请求转发给RDP服务器，同时将RDP服务端的机器的应答信息转发给RDP客户端。这样就实现了对RDP会话的代理。
可以看到，我们需要需要处理的数据就是会话过程中交换的数据，包括RDP服务器响应的图形命令以及RDP客户端的输入，如鼠标键盘的输入。堡垒机需要实现的功能主要还是要基于这些数据。那么从这里开始就可以考虑如何实现堡垒机的功能了。
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> RDP协议栈</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> 协议栈接口</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
我们先处理到RDP层的数据，看一下xrdp中的RDP层提供了什么接口：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> xrdp_rdp *</span><br><span class="line"><span class="title">xrdp_rdp_create</span><span class="params">(<span class="keyword">struct</span> xrdp_session *session, <span class="keyword">struct</span> trans *trans)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">xrdp_rdp_delete</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_init</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_init_data</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_get_fastpath_bytes</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_init_fastpath</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_recv</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s, <span class="keyword">int</span> *code)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s, <span class="keyword">int</span> pdu_type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_data</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s,</span><br><span class="line">		   <span class="keyword">int</span> data_pdu_type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_fastpath</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s,</span><br><span class="line">		       <span class="keyword">int</span> data_pdu_type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_data_update_sync</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_incoming</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_process_data</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_disconnect</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_deactivate</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_rdp_send_session_info</span><span class="params">(<span class="keyword">struct</span> xrdp_rdp *self, <span class="keyword">const</span> <span class="keyword">char</span> *data,</span><br><span class="line">			   <span class="keyword">int</span> data_bytes)</span></span>;</span><br></pre></td></tr></table></figure>
</div>


<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* iso */</span></span><br><span class="line"><span class="keyword">struct</span> xrdp_iso</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_mcs *mcs_layer; <span class="comment">/* owner */</span></span><br><span class="line">    <span class="keyword">int</span> rdpNegData; <span class="comment">/* bool */</span></span><br><span class="line">    <span class="keyword">int</span> requestedProtocol;</span><br><span class="line">    <span class="keyword">int</span> selectedProtocol;</span><br><span class="line">    <span class="keyword">int</span> failureCode;</span><br><span class="line">    <span class="keyword">struct</span> trans *trans;</span><br><span class="line">};</span><br><span class="line"><span class="comment">/* xrdp_iso.c */</span></span><br><span class="line"><span class="comment">/* trans </span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> xrdp_iso *</span><br><span class="line"><span class="title">xrdp_iso_create</span><span class="params">(<span class="keyword">struct</span> xrdp_mcs *owner, <span class="keyword">struct</span> trans *trans)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">xrdp_iso_delete</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_init</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_recv</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_send</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_incoming</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_iso_detect_tpkt</span><span class="params">(<span class="keyword">struct</span> xrdp_iso *self, <span class="keyword">struct</span> stream *s)</span></span>;</span><br></pre></td></tr></table></figure>
</div>
<p>
这是协议栈的最底层，在我们实现了trans对象建立了之后，就可以初始化这个协议栈对象了，这个协议栈也是最底层的内容。
</p>

<p>
需要注意的是fastpath，所以这里值得一提。属于sec layer，说明这是加密的路径。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 服务器模型</h3>
<div class="outline-text-3" id="text-3-4">
</div><div id="outline-container-sec-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> 概述</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
一个好的服务器模型可以提高整个会话的吞吐量，也方便编码。
rdpproxy还提供了web管理页面，提供的功能如下：
</p>


<div class="figure">
<p><img src="./rdp代理概述/rdpproxy_web.png" alt="rdpproxy_web.png">
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> rdpproxy服务器模型</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
rdpproxy采用的是基于代理的多线程TCP服务器模型，和一般的多线程TCP服务器模型不同的地方在于，每个处理线程会和客户端和后台服务器建立至少两条连接，而普通的多线程服务器一般只要建立一条连接就可以了，这是代理服务器需要的。作为代理，处理线程不能直接响应客户端的输入，需要先将数据解包后重新包装再转发给后台服务器，之后才能得到真正的响应。
对于rdpproxy代理服务器模型，作者提供了一下流程图来描述（画得大概不好）：
<img src="./rdp代理概述/rdpproxy_active.png" alt="rdpproxy_active.png">
所以之后也照搬作者的描述
</p>
<blockquote>
<p>
每个连接来了以后，监听线程将启动一个连接处理线程进行处理。用文字描述连接处理流程：
</p>
<ol class="org-ol">
<li>代理服务端与客户端进行连接初始化。
</li>
<li>在完成了与客户端的连接初始化过程后，线程创建一个代理客户端socket，与服务器建立TCP连接，并进行与服务器进行协议连接初始化流程。
</li>
<li>完成1，2之后，连接处理线程分别于客户端和服务器建立了协议级的连接，之后转入了对连接会话的代理转发阶段。
</li>
<li>和上图类似，首先判断是否有客户端发来的数据，若有，则代理服务端接收数据，并按照服务端协议栈的分析，得到真实的数据。并交给代理客户端协议栈进行重新打包，发送给服务器。若没有数据，则直接跳到5。
</li>
<li>判断服务器是否有相应的数据发来，若有，则代理客户端接收数据，并按照客户端协议栈的分析，得到真实的服务端响应数据，并交给服务端协议栈进行重新打包，发送给客户端，若没有数据，则令线程挂起200ms，然后跳转到4，重复这个过程。
</li>
</ol>
</blockquote>
</div>
</div>
<div id="outline-container-sec-3-4-3" class="outline-4">
<h4 id="sec-3-4-3"><span class="section-number-4">3.4.3</span> xrdp服务器模型</h4>
<div class="outline-text-4" id="text-3-4-3">
</div><ol class="org-ol"><li><a id="sec-3-4-3-1" name="sec-3-4-3-1"></a>多线程和多进程<br><div class="outline-text-5" id="text-3-4-3-1">
<p>
相比rdpproxy，xrdp的服务器模型会复杂得多。首先xrdp既支持多线程模型也支持多进程模型，可以直接通过xrdp的选项配置。（另外，xrdp很多时候作为一个rdp服务器来使用，这里主要关注代理部分的内容，所以不做讲解。）无论xrdp使用的是多线程模型还是多进程模型，实际运行的代码都是一样的，只是开销的区别。
</p>
</div>
</li>
<li><a id="sec-3-4-3-2" name="sec-3-4-3-2"></a>代码分析<br><div class="outline-text-5" id="text-3-4-3-2">
<p>
这里大体介绍一下xrdp的处理连接的部分，首先xrdp定义了一个对象xrdp_listen来监听连接，这个对象的定义是：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rdp listener */</span></span><br><span class="line"><span class="keyword">struct</span> xrdp_listen</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">struct</span> trans* listen_trans; <span class="comment">/* in tcp listen mode */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="built_in">list</span>* process_list;</span><br><span class="line">  tbus pro_done_event;</span><br><span class="line">  <span class="keyword">struct</span> xrdp_startup_params* startup_params;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> trans</span><br><span class="line">{</span><br><span class="line">    tbus sck; <span class="comment">/* socket handle */</span></span><br><span class="line">    <span class="keyword">int</span> mode; <span class="comment">/* 1 tcp, 2 unix socket */</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> type1; <span class="comment">/* 1 listener 2 server 3 client */</span></span><br><span class="line">    ttrans_data_in trans_data_in;</span><br><span class="line">    ttrans_conn_in trans_conn_in;</span><br><span class="line">    <span class="keyword">void</span>* callback_data;</span><br><span class="line">    <span class="keyword">int</span> header_size;</span><br><span class="line">    <span class="keyword">struct</span> stream* in_s;</span><br><span class="line">    <span class="keyword">struct</span> stream* out_s;</span><br><span class="line">    <span class="keyword">char</span>* listen_filename;</span><br><span class="line">    tis_term is_term; <span class="comment">/* used to test for exit */</span></span><br><span class="line">    <span class="keyword">struct</span> stream* wait_s;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> port[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> no_stream_init_on_data_in;</span><br><span class="line">    <span class="keyword">int</span> extra_flags; <span class="comment">/* user defined */</span></span><br><span class="line">    <span class="keyword">struct</span> ssl_tls *tls;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ssl_protocol; <span class="comment">/* e.g. TLSv1, TLSv1.1, TLSv1.2, unknown */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cipher_name;  <span class="comment">/* e.g. AES256-GCM-SHA384 */</span></span><br><span class="line">    trans_recv_proc trans_recv;</span><br><span class="line">    trans_send_proc trans_send;</span><br><span class="line">    trans_can_recv_proc trans_can_recv;</span><br><span class="line">    <span class="keyword">struct</span> source_info *si;</span><br><span class="line">    <span class="keyword">int</span> my_source;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
<p>
xrdp源码的抽象程度是比较高的，所以先不要强求理解所有字段的含义，这里只需要最重要的是要知道trans是对socket的包装。接下来进入main函数：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> xrdp_listen *g_listen = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>{</span><br><span class="line">    <span class="comment">// 初始化、读取配置等...</span></span><br><span class="line">    g_listen = xrdp_listen_create();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    exit_status = xrdp_listen_main_loop(g_listen);</span><br><span class="line">    <span class="comment">// 结束、清理...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
可以看到进程启动后会调用xrdp_listen_create方法来构造一个xrdp_listen对象，并将其指针赋值给静态变量g_listen，显然g_listen变量一个进程只有一个。之后会调用xrdp_listen对象的xrdp_listen_main_loop()进入监听进程或者线程的主循环，由于循环的代码比较难懂，这里不贴代码了，其逻辑大体就差调用select来监听socket的事件，当有连接请求时，会通过accept建立新的socket（这里是和socket对应的trans），之后就进入连接处理流程，这也是多进程模型和多线程模型的逻辑分离的位置。xrdp的连接处理函数定义如下：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span><br><span class="line"><span class="title">xrdp_listen_conn_in</span><span class="params">(<span class="keyword">struct</span> trans *self, <span class="keyword">struct</span> trans *new_self)</span></span><br><span class="line"></span>{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_process *process;</span><br><span class="line">    <span class="keyword">struct</span> xrdp_listen *lis;</span><br><span class="line"></span><br><span class="line">    lis = (<span class="keyword">struct</span> xrdp_listen *)(self-&gt;callback_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lis-&gt;startup_params-&gt;fork) <span class="comment">// 是否使用多进程模型</span></span><br><span class="line">    {</span><br><span class="line">	<span class="keyword">return</span> xrdp_listen_fork(lis, new_self); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    process = xrdp_process_create(lis, lis-&gt;pro_done_event);<span class="comment">// 使用了多线程模型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xrdp_listen_add_pro(lis, process) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">	<span class="comment">/* start thread */</span></span><br><span class="line">	process-&gt;server_trans = new_self; <span class="comment">// </span></span><br><span class="line">	g_process = process;</span><br><span class="line">	tc_thread_create(xrdp_process_run, <span class="number">0</span>); <span class="comment">// 建立新的线程</span></span><br><span class="line">	tc_sem_dec(g_process_sem); <span class="comment">/* this will wait */</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">	xrdp_process_delete(process);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
lis-&gt;startup_params是从配置文件或者命令行中获取的配置信息，当我们设置了fork为非零值时，代表xrdp使用多进程模型。否则使用，多线程模型。可以看到xrdp_listen_fork是对fork的包装函数，而 <code>tc_thread_create(xrdp_process_run)</code> 创建了一个新的线程，相比多进程模型，多线程模型需要添加对于线程管理的功能。新线程运行的函数是xrdp_process。另一方面，新的进程最终也会进入函数xrdp_process_run：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> xrdp_process *g_process = <span class="number">0</span>;</span><br><span class="line">xrdp_process_run(<span class="keyword">void</span> *in_val)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">struct</span> xrdp_process *process;</span><br><span class="line"></span><br><span class="line">    DEBUG((<span class="string">"process started"</span>));</span><br><span class="line">    process = g_process;</span><br><span class="line">    g_process = <span class="number">0</span>;</span><br><span class="line">    tc_sem_inc(g_process_sem);</span><br><span class="line">    xrdp_process_main_loop(process);</span><br><span class="line">    DEBUG((<span class="string">"process done"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
再之后进入xrdp_process对象的xrdp_process_main_loop()方法，之后就可以进入之前讲过的协议栈代码了。
</p>
</div>
</li></ol>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> VNC代理</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> VNC</h3>
<div class="outline-text-3" id="text-4-1">
<p>
VNC(Virtual Network Computing，虚拟网络计算)是基于RFB（Remote Frame Buffer）协议进行通信的，是一个基于平台无关的简单显示协议的超级瘦 <b>客户系统</b> （也是一个软件），由Cambridge的AT&amp;T实验室设计开发的。vnc的缺省端口是main:5900（C/S）和 <a href="http:5800" target="_blank" rel="external">http:5800</a>(B/S)端口。RFB (远程帧缓存) 是一个远程图形用户的简单协议，因为它工作在帧缓存级别上，所以它可以应用于所有的窗口系统，例如：X11,Windows和Mac系统。在Linux下，VNC包括以下的四个命令：vncserver，vncviewer，vncpasswd，和 vncconnect。大多数情况下用户只需要其中的两个命令：vncserver 和 vncviewer。
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 如何阅读RDP代理</h3>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 基于RDP代理的堡垒机功能实现</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 堡垒机和RDP代理功能</h3>
<div class="outline-text-3" id="text-5-1">
<p>
为了实现对于RDP操作人员的的操作进行限制和审计，需要通过代理将RDP会话过程包括请求信息和应答信息都记录存储下来。为之后审计提供数据源。而为了审计RDP会话就需要对RDP报文进行解析，因此理解RDP协议必不可少。对于RDP代理，目前的堡垒机很多都实现回放功能，而且大部分操作信息都在RDP会话中，所以我们也有必要实现图形回放功能。rdpproxy实现了基本的图形回放功能以及基于图形的会话检索功能。
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <span class="todo TODO">TODO</span> 回放功能</h3>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> <span class="todo TODO">TODO</span> 图形检索</h3>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 总结</h2>
<div class="outline-text-2" id="text-6">
<p>
RDP代理主要还是针对Windows主机，现实中大部分人登录Linux一般还是选择能够返回shell的方式，如ssh、telnet等。所以个人前期对于xrdp的代码阅读的重点其实不对，我们会因为xrdp代码中带有大量处理Linux图形界面的代码以及支持本地server功能的代码，这些对于我们实现堡垒机的功能其实没有太大帮助。xrdp的对各个系统调用接口进行了包装，基于对象来组织代码，同时自身没有给出足够的说明文档，所以要理解xrdp的代码功能其实不该从源码入手，而应该先了解RDP协议、针对性地找到xrdp协议栈的实现，确定使用的服务器模型。
目前看来，xrdp的完成度其实已经非常高了，代码的组织也非常好，向像协议栈的代码组得就比较好了。当然，由于xrdp源码有大量的包装库，并基于对象来组织代码，所以如果要基于xrdp开发，那么就有必要按照原有的组织风格来，同时最好使用其包装好的函数库，这些都需要不少时间。
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> <span class="todo TODO">TODO</span> 计划</h3>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> FAQ</h2>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 附录</h2>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 零散</h2>
<div class="outline-text-2" id="text-9">
<p>
在callback处会有
</p>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> <span class="todo TODO">TODO</span> </h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li><code>[&#xa0;]</code> 策略配置怎么做？
</li>
<li><code>[&#xa0;]</code> rdp数据包的结构体位置，之后放到文档
</li>
<li><code>[&#xa0;]</code> RDP代理对于RDP客户端的数据是否直接发送。
</li>
<li><code>[&#xa0;]</code> RDP协议是什么，主要做什么？
</li>
<li><code>[&#xa0;]</code> RDP代理的实现，xrdp是怎么实现的，rdpproxy时怎么实现的？
</li>
<li><code>[&#xa0;]</code> 堡垒机功能实现，有那些功能可以实现，rdpproxy实现了什么？功能依赖那些资源？xrdp提供了那些资源
</li>
<li><code>[&#xa0;]</code> 协议栈要配合代码看
</li>
<li><code>[X]</code> 规则图形
</li>
<li><code>[&#xa0;]</code> 代理技术和审计技术的关联
</li>
<li><code>[X]</code> 单点登录系统
</li>
<li><code>[&#xa0;]</code> 协议栈
</li>
<li><code>[&#xa0;]</code> C语言面向对象
</li>
<li><code>[&#xa0;]</code> FAQ完善
</li>
<li><code>[&#xa0;]</code> 整理一下附录
</li>
<li><code>[&#xa0;]</code> rdpproxy处理线程为何要挂起200ms
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 参考</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Remote_Desktop_Protocol" target="_blank" rel="external">Wikipedia：Remote Desktop Protocol</a>
</li>
<li>RDP协议的代理与转发的研究和实现
</li>
<li><a href="http://qimo601.iteye.com/blog/614649" target="_blank" rel="external">RDP协议详细解析</a>
</li>
<li><a href="https://zh.wikipedia.org/zh-hans/%E4%BD%8D%E5%9B%BE" target="_blank" rel="external">维基百科:位图</a>
</li>
<li><a href="http://cn.linux.vbird.org/linux_basic/0590xwindow.php" target="_blank" rel="external">鸟哥的Linux私房菜：X Window配置介绍</a>
</li>
<li>宗波. 浅析堡垒机概念及工作原理[J]. 及计算机光盘软件与应用，2012,18：070
</li>
<li>基于代理的远程访问审计系统的设计于实现
</li>
<li>RDP协议的代理与转发的研究与实现 乔俊峰
</li>
<li>基于代理的远程访问审计系统的设计与实现 李灏  
</li>
<li>浅析运维堡垒机的设计和应用前景
</li>
<li><a href="https://github.com/neutrinolabs/xrdp" target="_blank" rel="external">https://github.com/neutrinolabs/xrdp</a>
</li>
<li><a href="https://github.com/neutrinolabs/NeutrinoRDP" target="_blank" rel="external">https://github.com/neutrinolabs/NeutrinoRDP</a>
</li>
<li><a href="https://github.com/silenceli/rdpproxy" target="_blank" rel="external">https://github.com/silenceli/rdpproxy</a>
</li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf" target="_blank" rel="external">C11标准的最终定稿的草案</a>
</li>
<li><a href="https://wiki.wireshark.org/RDP" target="_blank" rel="external">RDP - The Wireshark Wiki</a>
</li>
<li><a href="http://yosefk.com/blog/oo-c-is-passable.html" target="_blank" rel="external">oo-c-is-passable</a>
</li>
<li><a href="https://baike.baidu.com/item/VNC/2906305?fr=aladdin" target="_blank" rel="external">百度百科:VNC</a>
</li>
<li>The RFB Protocol
</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p>严格来说最早舒畅国际电信联盟设计的，后被微软收购</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p>xrdp默认只监听TCP端口</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p>历史版本包括4.0、5.0、5.1、5.2、6.0、6.1、7.0、8.0、8.1、10.0</p></div>


</div>
</div>
Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VRRP协议及其实现]]></title>
      <url>/2017/08/11/VRRP%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 引言j</h2>
<div class="outline-text-2" id="text-1">
<p>
VRRP协议（Virt8ual Router Redundancy Protocol，虚拟路由冗余协议），用于解决局域网配置静态网关出现单点失效的问题。对于大型的局域网，避免单点失效是必要的。VRRP开始将一组路由器组成了 <b>一个虚拟路由器</b> ，一般包含一个主路由器和几个备份的路由器。虚拟路由器拥有IP（对于连接它的局域网），同时虚拟路由器组内的路由器也会有自己的IP，可以认为虚拟路由器其实是一个局域网。虚拟路由器对外还有MAC地址
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> VRRP报文</h2>
<div class="outline-text-2" id="text-2">
<p>
VRRP只有一种报文，由主路由器定时向其他成员发送组播报文，其 <b>内容封装在IP报文中</b> 。每个虚拟路由器中的
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> <span class="todo TODO">TODO</span> 问题 <code>[%]</code></h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li><code>[&#xa0;]</code> </li>
</ul>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> vrrpd</h2>
<div class="outline-text-2" id="text-4">
<p>
vrrpd是VRRP的是一个实现，作为一个守护进程一直运行在后台。其实现和协议一样非常简单，代码文件主要包括三部分。
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 源码分析</h2>
<div class="outline-text-2" id="text-5">
<p>
源码量不大，一个主程序文件加3个编写好的库文件。作为库文件本身就需要暴露符号给其他模块供其链接。一个进程运行到main loop前，初始化的过程也会决定其之后的行为，所以即使不喜欢也有必要对基本的全局变量有一定了解。
vrrpd是作为后台进程的，所以这个程序从其main开始分析比较好：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span><br><span class="line"></span>{</span><br><span class="line">	vrrp_rt     *vsrv = &amp;glob_vsrv;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">1</span>       <span class="comment">/* for debug only */</span></span></span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// First we fork and kill our parent</span></span><br><span class="line">	<span class="keyword">if</span> (fork())</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 实际syslog，不知这种alising是否有价值</span></span><br><span class="line">	vrrpd_log(LOG_WARNING, <span class="string">"vrrpd version %s starting...\n"</span>, VRRPD_VERSION);<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>( PidDir, <span class="keyword">sizeof</span>(PidDir), <span class="string">"%s"</span>, VRRP_PIDDIR_DFL );</span><br><span class="line"></span><br><span class="line">	init_virtual_srv(vsrv);</span><br><span class="line">	<span class="comment">/* parse the command line */</span></span><br><span class="line">	argc = parse_cmdline(vsrv,argc, argv );</span><br><span class="line">	<span class="keyword">if</span>( argc &lt; <span class="number">0</span> ) {</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* add the virtual server ip */</span></span><br><span class="line">	<span class="keyword">for</span>( ; argv[argc]; argc++ ){</span><br><span class="line">		<span class="keyword">uint32_t</span> ipaddr = inet_addr( argv[argc] );</span><br><span class="line">		cfg_add_ipaddr( vsrv, ntohl(ipaddr) );</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* check if the minimal configuration has been done */</span></span><br><span class="line">	<span class="keyword">if</span>( chk_min_cfg( vsrv ) ){</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"try '%s -h' to read the help\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>( open_sock( vsrv ) ){</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the init is completed */</span></span><br><span class="line">	vsrv-&gt;initF = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init signal handler */</span></span><br><span class="line">	signal( SIGINT, signal_end );</span><br><span class="line">	signal( SIGTERM, signal_end );</span><br><span class="line">	signal( SIGUSR1, signal_user );</span><br><span class="line">	signal( SIGUSR2, signal_user );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try to write a pid file */</span></span><br><span class="line">	<span class="keyword">if</span>( pidfile_exist( vsrv ) ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	pidfile_write( vsrv );</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* main loop */</span></span><br><span class="line">	<span class="keyword">while</span>( <span class="number">1</span> ){</span><br><span class="line">		<span class="keyword">switch</span>( vsrv-&gt;state ){</span><br><span class="line">		<span class="keyword">case</span> VRRP_STATE_INIT:       state_init( vsrv );     <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> VRRP_STATE_BACK:       state_back( vsrv );     <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> VRRP_STATE_MAST:       state_mast( vsrv );     <span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
可以看到初始化完毕后，程序是作为一个只有三个状态的状态机不断运行。而程序运行后其实状态就会进入Backup或者MAST状态。Initialize其实是在初始化时出现的状态。到了这里大概知道接下来要看vrrp<sub>rt的定义了。</sub>
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {    <span class="comment">/* parameters per virtual router -- rfc2338.6.1.2 */</span></span><br><span class="line">	<span class="keyword">int</span> vrid;           <span class="comment">/* virtual id. from 1(!) to 255 */</span></span><br><span class="line">	<span class="keyword">int</span> priority;       <span class="comment">/* priority value */</span></span><br><span class="line">	<span class="keyword">int</span> naddr;          <span class="comment">/* number of ip addresses */</span></span><br><span class="line">	vip_addr *vaddr;    <span class="comment">/* point on the ip address array */</span></span><br><span class="line">	<span class="keyword">int</span> adver_int;      <span class="comment">/* delay between advertisements(in sec) */</span>      </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">0</span>       <span class="comment">/* dynamically calculated */</span></span></span><br><span class="line">	<span class="keyword">double</span>      skew_time;      <span class="comment">/* skew Master_Down_Interval. (256-Prio)/256 */</span> </span><br><span class="line">	<span class="keyword">int</span> mast_down_int;  <span class="comment">/* interval for backup to declare master down*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> preempt;        <span class="comment">/* true if a higher prio preempt a lower one */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> state;          <span class="comment">/* internal state (init/backup/master) */</span></span><br><span class="line">	<span class="keyword">int</span> wantstate;      <span class="comment">/* user explicitly wants a state (back/mast) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sockfd;         <span class="comment">/* the socket descriptor */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> initF;          <span class="comment">/* true if the struct is init */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> no_vmac;        <span class="comment">/* dont handle the virtual MAC --rfc2338.7.3 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* rfc2336.6.2 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>    ms_down_timer;</span><br><span class="line">	<span class="keyword">uint32_t</span>    adver_timer;</span><br><span class="line"></span><br><span class="line">	vrrp_if     vif;</span><br><span class="line">} vrrp_rt;</span><br></pre></td></tr></table></figure>
</div>
<p>
vrid是虚拟路由器的ID，要注意这个ID不属于任何一个具体的路由器。虚拟路由器组中只有一个主路由器，priority则是用于选举主路由器，其中255和0是保留的值：255被保留给拥有虚拟路由器IP的IP地址所有者，0这用于主路由器指示其将改变Master状态。默认值是100。接下来的naddr和vaddr表示一个虚拟路由器的IP地址，可以是一个或者多个。adver<sub>int代表主路由器发送VRRP报文的间隔，默认为一秒。</sub>
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {    <span class="comment">/* parameters per virtual router -- rfc2338.6.1.2 */</span></span><br><span class="line">	<span class="keyword">int</span> vrid;           <span class="comment">/* virtual id. from 1(!) to 255 */</span></span><br><span class="line">	<span class="keyword">int</span> priority;       <span class="comment">/* priority value */</span></span><br><span class="line">	<span class="keyword">int</span> naddr;          <span class="comment">/* number of ip addresses */</span></span><br><span class="line">	vip_addr *vaddr;    <span class="comment">/* point on the ip address array */</span></span><br><span class="line">	<span class="keyword">int</span> adver_int;      <span class="comment">/* delay between advertisements(in sec) */</span>      </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> <span class="number">0</span>       <span class="comment">/* dynamically calculated */</span></span></span><br><span class="line">	<span class="keyword">double</span>      skew_time;      <span class="comment">/* skew Master_Down_Interval. (256-Prio)/256 */</span> </span><br><span class="line">	<span class="keyword">int</span> mast_down_int;  <span class="comment">/* interval for backup to declare master down*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> preempt;        <span class="comment">/* true if a higher prio preempt a lower one */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> state;          <span class="comment">/* internal state (init/backup/master) */</span></span><br><span class="line">	<span class="keyword">int</span> wantstate;      <span class="comment">/* user explicitly wants a state (back/mast) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sockfd;         <span class="comment">/* the socket descriptor */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> initF;          <span class="comment">/* true if the struct is init */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> no_vmac;        <span class="comment">/* dont handle the virtual MAC --rfc2338.7.3 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* rfc2336.6.2 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>    ms_down_timer;</span><br><span class="line">	<span class="keyword">uint32_t</span>    adver_timer;</span><br><span class="line"></span><br><span class="line">	vrrp_if     vif;</span><br><span class="line">} vrrp_rt;</span><br></pre></td></tr></table></figure>
</div>
<p>
这个是这个结构题vrrp<sub>rt，的rt的意思应该是router，这是虚拟路由的设置结构体。vrrp</sub><sub>rt其实是一个状态机的数据而已。所以对于vrrp的实现重在状态机。一个比较细节的是，这个状态机接收的输入只是数据报，也包括程序的数据。所以vrrp</sub><sub>rt的定义要包括状态字段。之后再根据转移的函数增加字段。回顾一下有限自动机的定义：</sub>
</p>
<blockquote>
<p>
有穷自动机是由一个5元组\((Q, \sum, \delta, q_0, F)\)
</p>
<ol class="org-ol">
<li>\(Q\) 是一个有穷集合，叫做状态集
</li>
<li>\(\sum\) 是一个用穷集合，叫做字母表
</li>
<li>\(\delta\) ：\(Q \mul \sum -> Q\) 是一个转移函数
</li>
<li>\(q_0 \sub Q\) 是起始状态
</li>
<li>\(F \sub Q\) 是接受状态集
</li>
</ol>
</blockquote>
<p>
查看vrrp的文档，状态定义没问题。关键在于把输入字母表和转移函数理清。顺带一提，三个状态都是接受状态。这里把使状态改变的字母表设定叫做某个事件。和处理字符串或者文本文件的自动机不同，路由器会长期在某个状态下停留，不知道什么时候能收到事件。
状态机化简之后，其他字段只是作为当前状态的映射信息而已。
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> open<sub>sock</sub>()</h3>
<div class="outline-text-3" id="text-5-1">
<p>
这个函数用于打开socket并将其加入多播组中
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 原始套接字</h3>
<div class="outline-text-3" id="text-5-2">
</div><div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> 前言</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
原始套接字只有超级用户可以使用，这样可以防止普通用户往网络发送自行构造的IP数据报。另一方面我们也可以使用原始套接字来设计在IP层之上的协议
</p>
</div>
</div>
<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2"><span class="section-number-4">5.2.2</span> 作用</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
有了原始套接字：
</p>
<ul class="org-ul">
<li>进程可以区别ICMP和IGMP等分组
</li>
<li>进程可以读写未处理协议字段的IPv4的报文
</li>
<li>TCP或者UDP分组
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 阅读协议实现代码的思路</h2>
<div class="outline-text-2" id="text-6">
<p>
先查看数据类型的定义以及对于数据类型的操作函数。
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 有限状态机</h2>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 零散</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>每个虚拟路由器中的路由器都处于三种状态：Initialize，Master和Backup
</li>
<li>高层的协议包括实现了哪些概念，用到了哪些概念，如何构建信的概念。这是一般抽象的过程。
</li>
<li>守护进程的编写和一般用户程序的编写的一个不同之处在于编程，对于错误一般写到日志中。
</li>
<li>二进制协议一般没有parse的必要，这也是效率高的一个原因
</li>
</ul>
</div>
<div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> VRRP组播报文的TTL是255direct</h3>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> pid文件使用来做什么？</h3>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> checksum计算</h3>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 结构体设计的思路（相比之下其他的只是技术细节）</h3>
<div class="outline-text-3" id="text-8-4">
<p>
若结构体是作为数据结构的组成部分，则要支持查询功能。一般要在结构体定义中提供关键字或者ID。当然如果结构体在程序中只有一个实例时，这部分可能没那种重要，顶多提供一些额外的信息而已，在设计初期可以不考虑。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 思考</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>二进制协议的设计一般是和程序的处理逻辑相关的，先使用的在前，后使用的则在后。
</li>
<li>还是看不出C语言分开多个文件的编写对于抽象的价值，不过一般一系列功能联系紧密的还是设置成一个模块比较好，就像类定义一样。这样编译出错时只要修改一个文件即可。不过从抽象的程度来看其实和全部函数写一个文件上没有太大区别，编译速度还能加快。
</li>
<li>主程序文件其实没有必要过于在意符号污染的问题，一旦发现符号重定义，大不了改名。因为主程序文件一般不会被作为模块被使用。不过如果为了避免重复定义的问题也可以直接用static。主程序文件是符号的使用者，而不是符号的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 参考</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li><a href="https://sourceforge.net/projects/vrrpd/?source=typ_redirect" target="_blank" rel="external">vrrp实现源码下载地址</a>
</li>
<li>《Unix网络编程 卷I 套接字联网API》
</li>
<li></li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Network </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux模块的知识]]></title>
      <url>/2017/08/11/Linux%E6%A8%A1%E5%9D%97%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前言</h2>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> hello模块示例</h2>
<div class="outline-text-2" id="text-2">
<p>
先尝试编写一个模块：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello, world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    printk(KERN_ALERT <span class="string">"goodbye, world\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
</div>
<p>
module注册的初始化函数要求类型是int (*)(void)的。这个模块的功能是在加载的时候打印hello world，而在卸载的时候打印goodbye。另一方面，内核模块的编译不同域普通程序。以下是Makefile：
</p>
<div class="org-src-container">

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m := hello.o</span><br><span class="line"></span><br><span class="line"><span class="title">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(shell uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="title">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(shell uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
</div>
<p>
要注意的是/lib/modules/$(shell uname -r)/build一般系统默认是不存在的，所以需要安装：
</p>
<div class="org-src-container">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pacman -S linux-headers</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 重要的数据结构</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> file结构</h3>
<div class="outline-text-3" id="text-3-1">
<p>
这是一个在用户空间无法看到的一个结构
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 字符设备驱动编写实例</h2>
<div class="outline-text-2" id="text-4">
<p>
其中定义了结构和相关的
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 在/proc建立虚拟文件</h2>
<div class="outline-text-2" id="text-5">
<p>
/proc是内核导出的的一个虚拟文件系统，是古老的用户态和内核态交换数据的方式(通过read和write操作)，设定proc文件的接口已经改变了，所以必须要设置，这个需要注意。1
一般这类文件是模拟的是只读的文件，使用/proc的模块必须使用&lt;linux/proc<sub>fs</sub>&gt;。模块必须实现一个函数，这样我们读取该文件时，读取请求也会发送到这个模块。实际调用的是模块定义的一个函数，接口是:
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*read_proc)(<span class="keyword">char</span>* page, <span class="keyword">char</span>** <span class="keyword">char</span>, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> count,</span><br><span class="line">		 <span class="keyword">int</span>* eof, <span class="keyword">void</span>* data);</span><br></pre></td></tr></table></figure>
</div>
<p>
创建和删除proc文件（包括目录文件）的接口分别是 <code>proc_create()</code> 和 <code>proc_remove()</code> 理解
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 用户空间和内核空间传递数据</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> get<sub>user</sub></h4>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 实用函数</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> kmalloc和kfree</h3>
<div class="outline-text-3" id="text-6-1">
<p>
这两个函数是用于内核模块分配内存使用的，它的特点是得到的内存是在物理上连续的。
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 关闭中断和打开中断</h3>
<div class="outline-text-3" id="text-6-2">
<p>
一般情况下使用local<sub>irq</sub><sub>save</sub>(flags)和local<sub>irq</sub><sub>restore</sub>(flags)这两个宏来分别关闭和打开中断，flags是当前中断状态。当然还提供了无条件打开和关闭中断的方法，但是其实很少使用，分别是local<sub>irq</sub><sub>disable</sub>(void)和local<sub>irq</sub><sub>enable</sub>(void).
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 时间、延迟及延缓操作</h2>
<div class="outline-text-2" id="text-7">
<p>
内核通过定时器中断来跟踪时间流。时钟中断由系统定时硬件以周期性的间隔产生，这个间隔根据HZ的值设定，HZ是频率的意思，代表每秒中断几次。HZ不同平台上不同，不应该有所假定，使用默认值即可。如果要修改HZ就要重新编译一遍内核了。
jiffies<sub>64是内核的计数器，它的值是自从上次操作系统引导以来的时钟滴答数数，我们一般使用jiffies变量来访问它，因为足够块。当然这个变量是会溢出的。用户程序虽然也可以获得HZ的值，但实际上这个值被设定100，相应的于时间相关的函数也已经做了转化。</sub>
</p>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 定时器api</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> timer_list {</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires;</span><br><span class="line">    <span class="keyword">void</span> (*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data; <span class="comment">// function指向的函数的参数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mod_time</span><span class="params">(<span class="keyword">struct</span> timer_list* timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span>;</span><br></pre></td></tr></table></figure>
</div>
<p>
其中mod<sub>timer用于修改一个已经调度的定时器的到期时间，</sub>
del<sub>timer用于在定时器到期前禁止一个已注册的定时器。有些</sub>
del<sub>timer</sub><sub>sync</sub> 在单核时和del<sub>timer行为相同，多核时要使用前者，所以我们在代码中一般要使用前者</sub>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 设备驱动</h2>
<div class="outline-text-2" id="text-8">
<p>
主设备号标识设备的驱动，现代Linux允许多个驱动程序对应一个设备号，但一般还是一个驱动对应一个设备号的原则。次设备号是设备本地数组的索引，可以获得指向内核设备的直接指针，用于获得实际实现的设备。
设备类型dev<sub>t在</sub>&lt;linux/types.h&gt;中定义，目前是32位，主设备号占12位，次设备号占10位，获取编号的方法是:
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAJOR(<span class="keyword">dev_t</span> dev);</span><br><span class="line">MINOR(<span class="keyword">dev_t</span> dev);</span><br></pre></td></tr></table></figure>
</div>
<p>
构造设备号的方法是：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MKDEV(<span class="keyword">int</span> major, <span class="keyword">int</span> minor);</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 网络驱动程序</h2>
<div class="outline-text-2" id="text-9">
<p>
网络接口不像其他设备，在/dev下没有对应的节点。网络接口异步地处理数据包。一般而言，网络世界中，网络接口和协议能理解的最小单元叫octet，它是8个数据位。数据经过协议栈是会被打上不同的协议头。
网络设备和驱动设备最重要的不同是：块设备只响应来自内核的请求，而网络驱动程序异步地接收来自外部的数据包。内核每次处理的是一个数据包。
</p>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 连接到内核</h3>
<div class="outline-text-3" id="text-9-1">
<p>
网络接口没有设备号的说法，那么它仍然需要被
</p>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 数据包传输</h3>
<div class="outline-text-3" id="text-9-2">
<p>
传输是指将数据包通过网络连接发送出去的行为，内核要发送一个数据包时，它会自动调用驱动程序的hard<sub>start</sub><sub>transmit函数将数据放入外发队列。内核处理的每个数据包都放在sk</sub><sub>buff中，结构定义于</sub>&lt;linux/skbuff&gt;中。
当sk<sub>buff的的出口设备，下一跳地址，以及链路层的地址填充后，最终发送数据时，就会调用该函数来dev</sub><sub>queue</sub><sub>xmit函数，该函数是驱动程序执行传输的接口。不同的设备驱动程序实现不同。</sub>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 内核通知链</h2>
<div class="outline-text-2" id="text-10">
<p>
Linux内核的子系统相互依赖，当某些子系统的状态发生改变时，需要提供机制通知其他子系统，以便其他子系统采取相应的措施，于是有了通知链（notification chain）。Linux网络子系统的通知链有三个，ipv4地址变化
</p>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 零散</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>THIS<sub>MODULE代表这个模块对象的地址，它是在编译是确定值的</sub>
</li>
<li>ssize<sub>t</sub> 是signed size<sub>t的意思</sub>
</li>
<li>内核源码中char _<sub>user</sub>* 的<sub>user指的是，用于修饰用户区的指针，内核态可以访问用户内存，但是用户态内存是不可靠的，所以要特别处理，这个应该是告诉编译器的。</sub>
</li>
<li>一般编写使用系统调用的时候，我们只是解析错误码，但是在编写内核程序的时候，我们需要自己涉及错误码，确定要返回的错误码。
</li>
<li>为什么说每个网络数据包属于更高的网络层的某个套接字
</li>
<li>一个设备接口被定义为以太网接口的优点是可以调用tcpdump来查看数据包。
</li>
<li><code>list_for_each(pos, head)</code> 用于遍历链表，pos作为循环变量，同时head是头节点，指向链表第一个节点，同时被最后一个节点指向
</li>
<li>内核主要通过两种方法和进程打交道，一种是通过设备文件，一种是通过proc文件系统。
</li>
<li>所有的设备都是由mknod，
</li>
<li>内核中的代码有三个调用在三种情况下会被调用:
<ol class="org-ol">
<li>进程通过系统调用（异常）
</li>
<li>中断
</li>
<li>被内核其他代码调用
</li>
</ol>
</li>
<li>C语言没有封装，所以有时即使我们不想变量被使用也不可能
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 参考</h2>
<div class="outline-text-2" id="text-12">
<ul class="org-ul">
<li>《Linux设备驱动程序》
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于C语言问题和改进]]></title>
      <url>/2017/08/10/%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98%E5%92%8C%E6%94%B9%E8%BF%9B/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
上班在车上无聊就看了一下《C++语言的设计和演化》，虽说目前主要用C，但看一下C++之父对编程语言（主要对C和C++）的思考还是大有裨益的。一旦语言要编译成机器码，就不得不了解一些底层的惯例。这些东西其实在学习C语言的过程中经常会接触到。C语言程序的链接约定估计是在C语言出现之前就有了雏形。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 链接模型</h2>
<div class="outline-text-2" id="text-2">
<p>
C语言是使用分别编译之后再链接的方式来生成可执行文件的，这算是历史传统。单独编译一个文件时为了保证之后能域其他模块顺利链接，必须要有其他模块的信息，一般我们把这些信息写在头文件中。C语言和C++的兼容指的是链接兼容的，即它们的链接模型是相同的。所谓的二进制兼容大约是在这个层次了。有了链接的兼容，代码的兼容是否重要又是另一回事了。最终的结果是C++其实早就和C在源码级别上不兼容了，一般所说的兼容其实是链接模型兼容。但其实对于符号的命名规范还是有所不同。
C语言的类型系统很比较弱，尤其到了链接的时候就能发现，因为C语言的符号修饰规则并不包含类型信息。而对于包含了符号信息的C++来说，链接时出现函数类型不匹配时，可以报未定义的引用这个错误，另一方面，这也是实现重载的手段。方法很简单，可以C语言从大规模使用开始就注定了不能这样改进了。
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 预处理器（Cpp）</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 前言</h3>
<div class="outline-text-3" id="text-3-1">
<p>
由于历史原因，C语言对于名称的处理一直不好，这个从链接的过程就可以看出了，加上C语言是弱类型，这个已经很麻烦了。平时编程的时候要小心符号的污染问题。预处理器的做法又进一步减弱了我们把握符号的能力。
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> #include</h3>
<div class="outline-text-3" id="text-3-2">
<p>
这是预处理器的指示字，以前我一直觉得这是个比较智能的指令，可以根据文件使用的函数到相关文件中查找定义再插入生成.i文件。然而其实它只是单纯从其他文件里复制源文件正文，并且是整个文件复制。这样的结果是会给编译其前端带来巨大的负担。要体会一下，可以用指令生成.i文件来查看：
</p>
<div class="org-src-container">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -E -o test.i test.c</span><br></pre></td></tr></table></figure>
</div>
<p>
多#include几个文件就千行了，考虑到很多头文件都被重复引用，代价还是比较大的。
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> #define（可部分替代）</h3>
<div class="outline-text-3" id="text-3-3">
<p>
这个指示字可以进行简单的文本替换。比较常用的是定义开子程序，和定义常量。目前这两个功能已经可以被const，enum和inline大部分替代。
</p>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> #ifdef</h3>
<div class="outline-text-3" id="text-3-4">
<p>
目前还是不可缺的功能：
</p>
<ul class="org-ul">
<li>版本控制
</li>
<li>注释代码（可以提供嵌套的注释）
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> #progma</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>布局控制
</li>
<li>为编译程序提供非常规的控制流信息
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 关于静态分配内存</h2>
<div class="outline-text-2" id="text-4">
<p>
C语言用于存放结构化数据的内存大体分成了三种：栈、数据段、堆。我过去编程的时候比较在意堆和栈的内存使用，而忽略了数据段这个在初始化时就分配的内存，相比其他两个，合理使用数据段能带来更多的好处。
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 语法</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a; <span class="comment">// 默认类型是int</span></span><br><span class="line">f(); <span class="comment">// 默认返回类型是int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    a =<span class="number">5</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
这样的程序居然编译过了，只有一个警告。第一次知道C
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 关于使用goto语言的要点</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 分析状态来消去goto</h3>
<div class="outline-text-3" id="text-6-1">
<p>
内核以及系统编程总是能看到goto语句的实现，类似资源释放这种事情暂时还没找到更好的办法。但是偶然在《Unix网络编程 卷一》看到一段代码：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span><br><span class="line"></span>{</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">while</span> ((n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">	Writen(sockfd, buf, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">	<span class="keyword">goto</span> again;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">	err_sys(<span class="string">"str_echo: read error"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
这里使用了goto跳转，其使用实在是没必要地增加了代码的阅读难度。由于能力所限，还是用自动机来将代码理清。个人目前对于while的理解还是如下图：
</p>

<div class="figure">
<p><img src="关于C语言问题和改进/while.png" alt="while.png">
</p>
</div>

<p>
这是一个比较笼统的图，表示不断重复一个循环体，直到达到终止条件，所以使用while的关键是要把终止条件描述完整。前面之所以要用goto，是因为上面哪个while不能完整描述终止条件。去掉goto的做法是：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span><br><span class="line"></span>{</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">while</span> ((n = read(sockfd, buf, MAXLINE)) != <span class="number">0</span>) {</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">	    Writen(sockfd, buf, n);</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno != EINTR) {</span><br><span class="line">	    err_sys(<span class="string">"str_echo: read error"</span>);</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
这样就好看多了。当然，这样还有一个问题，对于C语言编程，我一直希望 <b>计算</b> 和 <b>写</b> 操作可以比较明显的分开。可惜在while中这种在判断语句中还是有点让人迷惑，毕竟判断语句有副作用，这不算是好的判断语句，虽然在C语言里不用太在意就是了。我换了一种形式：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">str_echo</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span><br><span class="line"></span>{</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ssize_t</span> n = read(sockfd, buf, MAXLINE); n; n = read(sockfd, buf, MAXLINE)) {</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">	    Writen(sockfd, buf, n);</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno != EINTR) {</span><br><span class="line">	    err_sys(<span class="string">"str_echo: read error"</span>);</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
这样就把判断和副作用分开了，这个算是for的一个作用。至少个人觉得代码美观了不少。需要额外注意的是代码的对于异常处理，我的理解是不把它当作执行流的一部分。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> 关于减少使用#define的问题</h2>
<div class="outline-text-2" id="text-7">
<p>
使用宏定义的问题在于我们定义的名字是无法被编译器看到的，这意味这我们和编译器的交流过程存在信息的损失，这对我们报错会造成很大的影响
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 阅读源码中学习到的一些小技巧</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>使用基本数据类型或者系统数据类型的别名，别名的作用是提供了多一层抽象。这样可以提高可移植性，如可能会域到不同的系统应该使用不同的类型来提高效率的情况。
</li>
<li>有时我们用一个结构体来表示不同的类型，一般情况下结构体会变得十分大，所以我们需要对公共的部分进行抽象。设定宏来强调并快速访问
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 零散</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>相比之下，Python、Java、Lua这类语言代表是有自己完整系统和环境（虚拟机）的语言，这样限制了语言的角色，而不必去做它不擅长的事情。
</li>
<li>相比之下llvm是如何做到的？
</li>
<li>类型检查发生编译器运行过程中，然而C语言本身是弱类型，所以可能使用const，enum，inline来替代#define的动力没那么大？
</li>
<li>当分支不会在合并时，最好记得使用else，不带else的if应该暗示它的分支最终会合并，即最终没有分支的时候可以。对于continue而言分支其实最终会合并，所以可以不是用else
</li>
<li>编程中对于类型其别名，本身是一种抽象。主要为了应对对于不同平台上的不同类型，或者之后要增大类型的情况，
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 参考</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>《C++语言的设计和演化》
</li>
<li>《Effective C++》
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xv6源码分析]]></title>
      <url>/2017/08/02/xv6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
xv6的一个麻烦的点是它支持多核处理器，所以代码要比一般的简单的操作系统项目要麻烦。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> xv6源码获取</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mit-pdos/xv6-public.git xv6</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> <span class="todo TODO">TODO</span> xv6源码结构</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> <span class="todo TODO">TODO</span> 内核</h3>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> <span class="todo TODO">TODO</span> 用户态程序</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>cat.c
</li>
<li>date.c
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> <span class="todo TODO">TODO</span> 多核的符号引用（似乎是通过段机制）</h2>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 物理地址空间</h2>
<div class="outline-text-2" id="text-5">
<p>
虽然有页机制掩盖了物理地址，但是物理地址也不是杂乱无章的。物理地址按低地址到高地址分成三个部分：
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 自旋锁的实现</h2>
<div class="outline-text-2" id="text-6">
<p>
使用一个锁变量，不同的运行实体通过读取该变量来判断是否使用某个资源。看描述就知道这个锁变量满足了引起竞态条件的所有条件，一般的解决方案是使用x86提供的特殊指令xchg：
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">static inline uint</span><br><span class="line">xchg(volatile uint *addr, uint newval)</span><br><span class="line">{</span><br><span class="line">  uint result;</span><br><span class="line"></span><br><span class="line">  // The + in "+m" denotes a read-modify-write operand.</span><br><span class="line">  asm volatile("lock; xchgl %0, %1" :</span><br><span class="line">	       "+m" (*addr), "=a" (result) :</span><br><span class="line">	       "1" (newval) :</span><br><span class="line">	       "cc");</span><br><span class="line">  return result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
lock前缀保证了多处理器系统中的某个处理器能独立使用共享内存，这里lock前缀不是必要的，xchg默认会设置lock信号。由于锁变量只是内存，所以主要的难点在于获取锁和释放锁的过程。这里先观察xv6中的实现：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="comment">// Holding a lock for a long time may cause</span></span><br><span class="line"><span class="comment">// other CPUs to waste time spinning to acquire it.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line"></span>{</span><br><span class="line">  pushcli(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The xchg is atomic.</span></span><br><span class="line">  <span class="keyword">while</span>(xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen after the lock is acquired.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line">  lk-&gt;cpu = cpu;</span><br><span class="line">  getcallerpcs(&amp;lk, lk-&gt;pcs);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
自旋锁采用的是忙等待的策略来获得锁，while的那一行是主要的逻辑。释放锁只有写入的操作，所以不需要考虑太多，直接用mov写入一个0即可。自旋锁的自旋描述的是获取锁的控制流不断试探的行为。
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> 多核CPU的理解</h2>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 内核写入内存后的启动流程</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 开启分页机制</h3>
<div class="outline-text-3" id="text-8-1">
<p>
分页机制是操作系统，
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 不同模块的分析</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 代码</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>bootasm.S
</li>
<li>bootmain.c
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 系统初始化</h3>
<div class="outline-text-3" id="text-9-2">
</div><div id="outline-container-sec-9-2-1" class="outline-4">
<h4 id="sec-9-2-1"><span class="section-number-4">9.2.1</span> BIOS</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
计算机上电之后，第一条指令执行ROM中的BIOS，进行硬件自检，并读取第一个扇区，将其放入0x7c00处，一般情况下这就是bootloader。
</p>
</div>
</div>
<div id="outline-container-sec-9-2-2" class="outline-4">
<h4 id="sec-9-2-2"><span class="section-number-4">9.2.2</span> 设置A20地址线</h4>
</div>
<div id="outline-container-sec-9-2-3" class="outline-4">
<h4 id="sec-9-2-3"><span class="section-number-4">9.2.3</span> 内核的初始化</h4>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 编译结果和调试</h2>
<div class="outline-text-2" id="text-10">
<p>
我使用的是qemu来调试内核代码，所以编译的指令是：
</p>
<div class="org-src-container">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure>
</div>
<p>
观察xv6的Makefile可以看到：
</p>
<div class="org-src-container">

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">QEMUOPTS</span> = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp <span class="variable">$(CPUS)</span> -m 512 <span class="variable">$(QEMUEXTRA)</span></span><br><span class="line">$(QEMU) -serial mon:stdio $(QEMUOPTS)a</span><br></pre></td></tr></table></figure>
</div>
<p>
所以我们要生成的文件是fs.img和xv6.img，一个是根文件系统，而另一个是内核镜像。先讨论内核镜像，即先分析xv6.img
</p>
<div class="org-src-container">

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xv6.img: bootblock kernel fs.img</span><br><span class="line">	dd if=/dev/zero of=xv6.img count=10000</span><br><span class="line">	dd if=bootblock of=xv6.img conv=notrunc</span><br><span class="line">	dd if=kernel of=xv6.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure>
</div>
<p>
第一条指令相当有建立一个磁盘，大小是5120000字节。第二条指令是将bootblock写入虚拟磁盘的第一个扇区中。第三条指令代表跳过一个扇区后写入内核文件。
xv6是直接使用第一个扇区的程序作为bootloader的：
</p>
<div class="org-src-container">

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bootblock: bootasm.S bootmain.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -fno-pic -O -nostdinc -I. -c bootmain.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -fno-pic -nostdinc -I. -c bootasm.S</span><br><span class="line">	<span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</span><br><span class="line">	<span class="variable">$(OBJDUMP)</span> -S bootblock.o &gt; bootblock.asm</span><br><span class="line">	<span class="variable">$(OBJCOPY)</span> -S -O binary -j .text bootblock.o bootblock</span><br><span class="line">	./sign.pl bootblock</span><br></pre></td></tr></table></figure>
</div>
<p>
从以上指令可以看出bootasm.S和bootmain共同定义了bootloader。
</p>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> <span class="todo TODO">TODO</span> 异常和中断</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 概念探究</h3>
<div class="outline-text-3" id="text-11-1">
<p>
对异常和中断的概念往往比较容易混乱，所以先收集一下概念。首先是Intel的文档的内容：
</p>
<blockquote>
<p>
The processor provides two mechanisms for interrupting program execution, interrupts and exceptions:
• An interrupt is an asynchronous event that is typically triggered by an I/O device.
• An exception is a synchronous event that is generated when the processor detects one or more predefined conditions while executing an instruction. The IA-32 architecture specifies three classes of exceptions: faults, traps, and aborts.
</p>
</blockquote>
<p>
这是比较权威的解释了，按这个解释中断和异常都提供了打断程序运行的能力，中断是指由设备产生的异步事件，而异常是在处理器运行某个指令时探测到某些条件后产生的同步事件，异常分成了三种：故障、陷阱和终止。
之后再对比一下，《深入理解计算机系统》，果然不大一样，也难怪一直混淆了。《深入理解计算机系统》中对于异常的定义是：
</p>
<blockquote>
<p>
异常（execption）是控制流中的突变，用来响应处理其状态的某些变化。
</p>
</blockquote>
<p>
这里对异常的定义是把它当打断程序运行的事件，必Intel的定义更广，它把异常又分成了4种：中断、故障、陷阱和终止。所以两种定义没有本质的区别！
最后再来看看xv6文档的定义：
</p>
<blockquote>
<p>
术语 exception 指产生中断的非法程序操作,例如除以0,尝试访问 PTE 不存在的内存等等。术语 interrupt 指硬件产生的希望引起操作系统注意的信号。
</p>
</blockquote>
<p>
显然这xv6也采用Intel的定义，但表述还是模糊了一点。既然暂时还是和Intel的处理器打交道，我还是决定使用Intel
</p>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> 系统调用</h3>
<div class="outline-text-3" id="text-11-2">
<p>
系统调用是通过产生异常实现的，一般情况下，系统调用的中断号是64，在xv6中是用宏T<sub>SYSCALL。系统调用也叫陷阱</sub>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> <span class="todo TODO">TODO</span> 中断向量表和中断描述符表的区别</h2>
<div class="outline-text-2" id="text-12">
<p>
在内存中
</p>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> 调度</h2>
<div class="outline-text-2" id="text-13">
</div><div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1"><span class="section-number-3">13.1</span> 引言</h3>
<div class="outline-text-3" id="text-13-1">
<p>
多核CPU共享一个进程表，进程表可变，且读写是分开的，所以会造成竞争条件。这里一般的想法是用代价较小的锁，要不可能就要不断生成新的进程表了。
</p>
</div>
</div>
<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2"><span class="section-number-3">13.2</span> swtch分析</h3>
<div class="outline-text-3" id="text-13-2">
<p>
swtch是切换线程时必须使用的程序：
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Context switch&#10;#&#10;#   void swtch(struct context **old, struct context *new);&#10;# &#10;# Save current register context in old&#10;# and then load register context from new.&#10;&#10;.globl swtch&#10;swtch:&#10;  movl 4(%esp), %eax&#10;  movl 8(%esp), %edx&#10;&#10;  # Save old callee-save registers&#10;  pushl %ebp&#10;  pushl %ebx&#10;  pushl %esi&#10;  pushl %edi&#10;&#10;  # Switch stacks&#10;  movl %esp, (%eax)&#10;  movl %edx, %esp&#10;&#10;  # Load new callee-save registers&#10;  popl %edi&#10;  popl %esi&#10;  popl %ebx&#10;  popl %ebp&#10;  ret</span><br></pre></td></tr></table></figure>
</div>
<p>
该函数是内核线程调用的，用于保存内核线程自身的上下文并切换到另一个内核线程。这个函数可以和一般的函数的汇编代码对比，可以发现这个汇编程序的一开始并没有保存%ebp的值来建立一个帧，原因是这个函数并不需要返回，在保存了内核线程的%eip和被调用者保存寄存器后就可以切换到另一个程序了，ret时返回地址已经和调用时不同了。通过改变%esp来改变返回地址，这算是一个对初学者来说比较巧妙的做法。这个程序页暗示，内核线程的栈在切换后是一直保留在内存中的。swtch的第一个参数的含义也就明了了，是一个proc实例的context字段的地址。context其实是内核线程栈的栈顶地址
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> context {</span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebx;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint eip;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">enum</span> procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> proc {</span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;                <span class="comment">// Page table</span></span><br><span class="line">  <span class="keyword">char</span> *kstack;                <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="keyword">enum</span> procstate state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line">  <span class="keyword">struct</span> proc *parent;         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">struct</span> trapframe *tf;        <span class="comment">// Trap frame for current syscall</span></span><br><span class="line">  <span class="keyword">struct</span> context *context;     <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">struct</span> file *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">  <span class="keyword">struct</span> inode *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3"><span class="section-number-3">13.3</span> scheduler分析</h3>
<div class="outline-text-3" id="text-13-3">
<p>
scheduler是xv6进程调度的核心代码，它是永远不会返回的函数。xv6的实现代码是：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PAGEBREAK: 42</span></span><br><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//      via swtch back to the scheduler.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>{</span><br><span class="line">  <span class="keyword">struct</span> proc *p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;){</span><br><span class="line">    <span class="comment">// Enable interrupts on this processor.</span></span><br><span class="line">    sti();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over process table looking for process to run.</span></span><br><span class="line">    acquire(&amp;ptable.lock);</span><br><span class="line">    <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != RUNNABLE)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">      <span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line">      <span class="comment">// before jumping back to us.</span></span><br><span class="line">      proc = p;</span><br><span class="line">      switchuvm(p);</span><br><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line">      swtch(&amp;cpu-&gt;scheduler, p-&gt;context);</span><br><span class="line">      switchkvm();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      proc = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    release(&amp;ptable.lock);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
可以看到，这个调度器其实很简单，只是不断重复地遍历进程表，直到看到一个RUNNABLE的进程项，这是首次适配算法。中间使用了swtch，这是之后再次进入到scheduler的起点，也就是说进程切换之前关键的三步是：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proc = p;</span><br><span class="line">switchuvm(p);</span><br><span class="line">p-&gt;state = RUNNING;</span><br></pre></td></tr></table></figure>
</div>
<p>
将全局的变量proc赋值为当前将要运行的进程数据结构，之后调用switchuvm()，所以接下来在分析switchuvm()：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">switchuvm</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line"></span>{</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"switchuvm: no process"</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kstack == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"switchuvm: no kstack"</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pgdir == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"switchuvm: no pgdir"</span>);</span><br><span class="line"></span><br><span class="line">  pushcli();</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;cpu-&gt;ts, <span class="keyword">sizeof</span>(cpu-&gt;ts)-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  cpu-&gt;gdt[SEG_TSS].s = <span class="number">0</span>;</span><br><span class="line">  cpu-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  cpu-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;</span><br><span class="line">  <span class="comment">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span></span><br><span class="line">  <span class="comment">// forbids I/O instructions (e.g., inb and outb) from user space</span></span><br><span class="line">  cpu-&gt;ts.iomb = (ushort) <span class="number">0xFFFF</span>;</span><br><span class="line">  ltr(SEG_TSS &lt;&lt; <span class="number">3</span>);</span><br><span class="line">  lcr3(V2P(p-&gt;pgdir));  <span class="comment">// switch to process's address space</span></span><br><span class="line">  popcli();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
从函数名就知道主要是切换虚拟地址空间的
</p>
</div>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> 进程调度</h2>
<div class="outline-text-2" id="text-14">
<p>
进程是一个抽象概念，它让一个程序可以假设它独占一台机器。进程向程序提供独立的内存空间和CPU。对于进程间的通信看作是不同机器的通信其实是最自然的一种做法，这也是进程间通信使用。
通常我们为进程提供一个独占处理器的假象，而处理器的数目其实是有限的，所以这里同内存一样也是使用有限的资源来模拟大量的资源的一种做法。这里的资源有限不是处理器速度的有限，而是每个处理器核心一次只能处理一个控制流。进程独占处理器的抽象其实只要保证它的行为和中断运行的行为效果是相同的即可。所以这其实页取决域进程的定义，不可过于爆漏资源。一个进程独占处理器和内存资源主要通过进程调度器、内存分配其、页表来实现的。
实现处理器的多路复用有几个难点：
</p>
<ol class="org-ol">
<li>普通的上下文切换
</li>
<li>上下文切换如何透明化
</li>
<li>如何避免多核处理器的切换问题
</li>
<li>如何释放占用的内存和资源
</li>
</ol>
<p>
另外，进程的协作可以降低软件编写的复杂度。所以IPC机制的实现也十分重要。
</p>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> <span class="todo TODO">TODO</span> xv6和Linux的进程定义的区别</h2>
<div class="outline-text-2" id="text-15">
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc {</span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;                <span class="comment">// Page table </span></span><br><span class="line">  <span class="keyword">char</span> *kstack;                <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="keyword">enum</span> procstate state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line">  <span class="keyword">struct</span> proc *parent;         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">struct</span> trapframe *tf;        <span class="comment">// Trap frame for current syscall</span></span><br><span class="line">  <span class="keyword">struct</span> context *context;     <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">struct</span> file *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">  <span class="keyword">struct</span> inode *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
<p>
需要对所有进程进行处理时需要考虑
首先是进程标识，进程名、pid，用于定位进程，kill 一个进程时可以通过进程来。构成集合的结构，一般的集合数据结构，parent 字段代表这是一个树形结构或者链表型结构。进程的运行信息字段包括sz，pgdir,kstack, state tf context
</p>
</div>
</div>

<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> <span class="todo TODO">TODO</span> x86的寄存器</h2>
<div class="outline-text-2" id="text-16">
<p>
由于任务切换时要保留CPU大部分寄存器的值，所以对于寄存器还是需要有总体的了解。寄存器分成了几种：
</p>
<ul class="org-ul">
<li>标志寄存器
</li>
<li>内存管理寄存器（GDTR、LDTR、IDTR和TR）
</li>
<li>控制寄存器（CR0、CR1、CR2、CR3）
</li>
<li>通用寄存器
</li>
<li>段寄存器
</li>
<li>程序指针
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> 用户空间和内核空间</h2>
<div class="outline-text-2" id="text-17">
<p>
它们指的是操作系统的运行模式，内核空间中可以执行系统级ISA，并且可以有自己的地址空间
</p>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> 任务管理</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1"><span class="section-number-3">18.1</span> 概述</h3>
<div class="outline-text-3" id="text-18-1">
<p>
任务由两个部分组成：
</p>
<ul class="org-ul">
<li>任务执行空间
</li>
<li>任务状态段（TSS）
</li>
</ul>
<p>
TSS管理任务执行空间，任务执行空间包括代码段、数据段、堆栈段，虽然在Linux中只是走一个过场，主要是权限的管理
如果操作系统使用了处理器提供的特权级保护机制，那么就需要为每个特权级提供独立的堆栈空间。
一般任务的切换直接影响的寄存器状态是寄存器TR和CR3（如果使用了页机制，一般会使用）。这里的任务管理是处理器提供的，也可以用软件实现，就是不知效率如何。现代Linux似乎没有依赖x86的任务管理功能，只是稍微用到而已。需要注意的是返回信息是保存在切换后的任务执行空间中的。
似乎xv6开始就对任务切换功能不是很在意了。
</p>
</div>
</div>
<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2"><span class="section-number-3">18.2</span> 任务寄存器（TR）</h3>
<div class="outline-text-3" id="text-18-2">
<p>
TR存放着16位的段寄存器以及当前任务TSS段的整个描述符（作为缓存），访问TR的指令是LTR和STR指令，其中LTR一般只是在系统初始化时使用。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> 思考</h2>
<div class="outline-text-2" id="text-19">
<ul class="org-ul">
<li>Linux 有很多复杂的结构体，但实际上处理结构体的复杂度未必有多高，每个处理程序可能只是处理有限的字段，对大的处理复杂度可以根据最复杂的处理程序而定。
</li>
<li>进程调度需要多少字段
</li>
<li>这里处理集合的算法又是一个类别
</li>
<li>如何表示集合，有哪些集合数据结构，
</li>
<li>段寄存器的指是否是不变的
</li>
<li>锁就实现的方式来看属于系统资源一级的东西。模块化的一个基本手段是函数，不幸的是函数调用链是在一个进程中的。所以每个函数都可以拥有锁。相当域有增加了不固定的全局资源，编程难度有进一步增加了。函数副作用太大。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> <span class="todo TODO">TODO</span> 文件系统</h2>
<div class="outline-text-2" id="text-20">
</div><div id="outline-container-sec-20-1" class="outline-3">
<h3 id="sec-20-1"><span class="section-number-3">20.1</span> 前言</h3>
<div class="outline-text-3" id="text-20-1">
<p>
这里的文件系统自然指xv6磁盘文件系统，它解决了几个问题：
</p>
<ol class="org-ol">
<li>设计的磁盘上的数据结构，用于表示目录树和文件，记录每个文件的数据块以及磁盘上哪些空间是空闲的。
</li>
<li>崩溃恢复（这个一般的想法是要有日志来保证操作是原子性）
</li>
<li>支持在并发访问是保持一致性（大概要用锁）
</li>
<li>磁盘读写速度过慢（使用缓存加速）
</li>
</ol>
<p>
xv6将实现分成了6层：
<img src="./xv6源码分析/xv6_fs.png" alt="xv6_fs.png">
每一层分别实现，xv6采用自底向上的分析方法。所以这里我也想从底层的代码开始阅读。
</p>
</div>
</div>
<div id="outline-container-sec-20-2" class="outline-3">
<h3 id="sec-20-2"><span class="section-number-3">20.2</span> 块缓冲层</h3>
<div class="outline-text-3" id="text-20-2">
<p>
作为缓冲层最基本的当然是缓冲区和磁盘数据的交换了。首先了解对于缓冲区的数据结构如何，这个在代码中只有一处：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> {</span><br><span class="line">  <span class="keyword">struct</span> spinlock lock;</span><br><span class="line">  <span class="keyword">struct</span> buf buf[NBUF];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// head.next is most recently used.</span></span><br><span class="line">  <span class="keyword">struct</span> buf head;</span><br><span class="line">} bcache;</span><br></pre></td></tr></table></figure>
</div>
<p>
缓冲的结构体只使用一次，所以没必要命名，同时可以看到这是一个全局的结构体变量，所以缓冲区在内核固定的（静态的）数据段中。这种实现的话要增加缓存的大小就得在编译内核时修改宏的值，不知道其他的文件系统是否有其他做法。从bcache可以看到代码，除了同步使用了锁以外就是head成员比较特别，大约可以估计使用的是下次适配的做法。所以要点还在buf的定义上:
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BSIZE <span class="number">512</span>  <span class="comment">// block size</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> buf {</span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="keyword">struct</span> sleeplock lock;</span><br><span class="line">  uint refcnt;</span><br><span class="line">  <span class="keyword">struct</span> buf *prev; <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="keyword">struct</span> buf *next;</span><br><span class="line">  <span class="keyword">struct</span> buf *qnext; <span class="comment">// disk queue</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> B_VALID <span class="number">0x2</span>  <span class="comment">// buffer has been read from disk</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> B_DIRTY <span class="number">0x4</span>  <span class="comment">// buffer needs to be written to disk</span></span></span><br></pre></td></tr></table></figure>
</div>
<p>
磁盘块的数据存储在data成员中，其他的都是管理的数据。这里flags只用到了两个位，留下其他位估计是方便扩展。dev是设备号，这意味者即使有几个磁盘也只是使用同一个缓冲区。refcnt用于引用计数，对于资源的释放这是常用的做法，之后的三个buf指针，目前还看不出作用。lock则表示这个块是否被其他进程使用。实际上lock这个锁是避免把代码简化的关键，否则处理起来是很麻烦的。
那么可以开始看bread的代码了，涉及到了bget()的实现：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line">     <span class="function"><span class="keyword">struct</span> buf*</span><br><span class="line">     <span class="title">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">     </span>{</span><br><span class="line">       <span class="keyword">struct</span> buf *b;</span><br><span class="line"></span><br><span class="line">       b = bget(dev, blockno);</span><br><span class="line">       <span class="keyword">if</span>(!(b-&gt;flags &amp; B_VALID)) {</span><br><span class="line">	 iderw(b);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line">     <span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line">     <span class="comment">// In either case, return locked buffer.</span></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line">     <span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">     </span>{</span><br><span class="line">       <span class="keyword">struct</span> buf *b;</span><br><span class="line"></span><br><span class="line">       acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Is the block already cached?</span></span><br><span class="line">       <span class="keyword">for</span>(b = bcache.head.next; </span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"types.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"defs.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"param.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"spinlock.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"sleeplock.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"fs.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"buf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> {</span><br><span class="line">  <span class="keyword">struct</span> spinlock lock;</span><br><span class="line">  <span class="keyword">struct</span> buf buf[NBUF];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// head.next is most recently used.</span></span><br><span class="line">  <span class="keyword">struct</span> buf head;</span><br><span class="line">} bcache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">binit</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>{</span><br><span class="line">  <span class="keyword">struct</span> buf *b;</span><br><span class="line"></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">"bcache"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++){</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">"buffer"</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line"></span>{</span><br><span class="line">  <span class="keyword">struct</span> buf *b;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);b != &amp;bcache.head; b = b-&gt;next){</span><br><span class="line">	 <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno){</span><br><span class="line">	   b-&gt;refcnt++;</span><br><span class="line">	   release(&amp;bcache.lock);</span><br><span class="line">	   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">	   <span class="keyword">return</span> b;</span><br><span class="line">	 }</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Not cached; recycle some unused buffer and clean buffer</span></span><br><span class="line">       <span class="comment">// "clean" because B_DIRTY and not locked means log.c</span></span><br><span class="line">       <span class="comment">// hasn't yet committed the changes to the buffer.</span></span><br><span class="line">       <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev){</span><br><span class="line">	 <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == <span class="number">0</span>) {</span><br><span class="line">	   b-&gt;dev = dev;</span><br><span class="line">	   b-&gt;blockno = blockno;</span><br><span class="line">	   b-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	   b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">	   release(&amp;bcache.lock);</span><br><span class="line">	   acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">	   <span class="keyword">return</span> b;</span><br><span class="line">	 }</span><br><span class="line">       }</span><br><span class="line">       panic(<span class="string">"bget: no buffers"</span>);</span><br><span class="line">     }</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> 磁盘高速缓存</h2>
<div class="outline-text-2" id="text-21">
<p>
磁盘高速缓机制存把磁盘上的一些数据保留在RAM中
</p>
</div>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> 零散</h2>
<div class="outline-text-2" id="text-22">
<ul class="org-ul">
<li>cli是通过清除IF位来屏蔽中断
</li>
<li>x86提供了分页和分段机制，所以地址有三种类型，虚拟地址、线性地址和物理地址。在xv6中，除了每个CPU独立的数据有非0的基址意外，其他的如内核数据段、代码段一般都是从基址0开始的，这样大大简化的地址操作的程序的编程。所以一般我们只需要考虑分页的地址映射而已。
</li>
<li>加载内核时是没有loader的所以我们要自己利用elf格式手动加载内核。
</li>
<li>进程的地址空间的控制并不再进程的数据结构中，而是在每次切换进程时，改变cr0的物理地址。
</li>
<li>分页机制下，物理地址空间被分为一个个页帧，所以如果只是索引叶帧的话只需要20位地址而已。cr0指向页目录表的基址，页目录每一项用20位指向一个子页表，由于一个页目录项指向的页表只有4k所以也是使用20位就可以了，其他位可以作为控制位。
</li>
<li>所有CPU核心共用一个进程表
</li>
<li>allocproc在进程表中找到一个标记为UNUSED的槽位
</li>
<li>进程有内核线程的用户线程，每个线程要有栈
</li>
<li>看linux源码时要注意组成内核的部分一般是不会出现在根文件系统中的，也就是自己要理清内核和通常意义上的操作系统的区别。
</li>
<li>进程表是用于调度一个计算机中所有的进程，所以用一个表统一管理
</li>
<li>进程的线程一般是交替使用内核栈和用户栈的
</li>
<li>第一个程序是操作系统内核来运行的，但是还是使用了对于操作系统来说比较统一的方法。
</li>
<li>在x64中一般是先call压如pc的返回地址，再由被调用者管理栈帧。但这其实也不是必须的，实际上调用者管理也是可以的，当然我觉得还是前者的汇编代码好看一点。当然参数还是调用者来管理
</li>
<li>x64之后寄存器多了，函数参数可以直接保存在寄存器里了
</li>
<li>x86中的leave是一个语法糖，被调用者用于栈帧管理。等价于movl %ebp %esp; popl %ebp
</li>
<li>x86中调用者保存寄存器是被过程认为是易失，所以被调用者可以直接使用，如果要要使用则要求调用者保存。被调用者保存的寄存器包括ebx, edi和esi，其中esp和ebp是必须要维护的。
</li>
<li>Unix的一大优点是大部分资源都可以用文件来表示
</li>
<li>文件操作是对设备操作的组织和抽象，设备操作则是文件操作最终实现。
</li>
<li>层次的划分取决于使用了使用了哪些元语，依赖哪些实现
</li>
<li>抽象的结果是我们可以忽略哪些东西了
</li>
<li>传统的设备文件包括块设备和字符设备，之后设备变得越来越复杂，像网络接口这种不能确定属于那一类的设备就被独立出来了。所以一般区分设备包括块设备，字符设备和网络接口。
</li>
<li>由于设备的多样性，设备驱动是一个需要正本专著讨论的大课题
</li>
<li>PCI已经成为通用的标准总线，
</li>
<li>通过修改EFLAG的IF位可以屏蔽中断，但只能屏蔽硬件中断
</li>
<li>时钟中断由时钟芯片产生，可能是每100ms产生一个中断
</li>
<li>int指令类似域call，但做的事情更多，对于的返回指令是iret
</li>
<li>任务段指定了栈
</li>
<li>当处理器有多个级别时，Unix/Linux只使用两个级别，而处理器最少有两个级别
</li>
</ul>
</div>
<div id="outline-container-sec-22-1" class="outline-3">
<h3 id="sec-22-1"><span class="section-number-3">22.1</span> 可安装模块（module）</h3>
<div class="outline-text-3" id="text-22-1">
<p>
moule可以在系统运行时动态安装和拆卸的内核软件，实际上它的作用不限于设备驱动
</p>
</div>
</div>
<div id="outline-container-sec-22-2" class="outline-3">
<h3 id="sec-22-2"><span class="section-number-3">22.2</span> 将内核频文件载入</h3>
<div class="outline-text-3" id="text-22-2">
<p>
C函数需要使用栈，所以bootloader先用0x7c00作为栈的开始，
</p>
</div>
</div>
<div id="outline-container-sec-22-3" class="outline-3">
<h3 id="sec-22-3"><span class="section-number-3">22.3</span> bootloader的理解</h3>
<div class="outline-text-3" id="text-22-3">
<p>
Intel的CPU一开始运行在实模式之上，为了进入保护模式我们要在实模式中构建保护模式的运行环境，最后通过一个jmp正式进入保护模式。内核运行在保护模式中，页机制对于保护模式而言不是必须的，第一步先要启动的是段机制。
</p>
</div>
</div>
<div id="outline-container-sec-22-4" class="outline-3">
<h3 id="sec-22-4"><span class="section-number-3">22.4</span> <span class="todo TODO">TODO</span> i386的内存管理</h3>
<div class="outline-text-3" id="text-22-4">
<p>
CPU对于内存管理其实设定了不少,
</p>
</div>
</div>
<div id="outline-container-sec-22-5" class="outline-3">
<h3 id="sec-22-5"><span class="section-number-3">22.5</span> 虚拟地址空间</h3>
<div class="outline-text-3" id="text-22-5">
<p>
x86其实提供了二维的地址空间，不过Linux似乎没有使用。
</p>
</div>
</div>
<div id="outline-container-sec-22-6" class="outline-3">
<h3 id="sec-22-6"><span class="section-number-3">22.6</span> 段寄存器</h3>
<div class="outline-text-3" id="text-22-6">
<p>
段寄存器有6个，一个程序一般至少需要3个CS、DS和SS，还有三个辅助的数据段寄存器ES、FS、GS。另外段寄存器还包含不可见的缓存来保存段描述符。对于描述符表做改动后立刻重新加载6个段寄存器
</p>
</div>
</div>
<div id="outline-container-sec-22-7" class="outline-3">
<h3 id="sec-22-7"><span class="section-number-3">22.7</span> 利用有限的资源模拟无限的资源</h3>
</div>
<div id="outline-container-sec-22-8" class="outline-3">
<h3 id="sec-22-8"><span class="section-number-3">22.8</span> types.h</h3>
<div class="outline-text-3" id="text-22-8">
<p>
基本系统数据类型。
</p>
</div>
</div>
<div id="outline-container-sec-22-9" class="outline-3">
<h3 id="sec-22-9"><span class="section-number-3">22.9</span> <span class="todo TODO">TODO</span> 不去使用递归锁的原因（理解不够）</h3>
<div class="outline-text-3" id="text-22-9">
<p>
两个原因：
</p>
<ul class="org-ul">
<li>这会加大相关函数的副作用，加大编程的复杂性
</li>
<li>另一个原因是不变量可能被破坏，因为C函数本身无法从函数定义了解相关的实现。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-22-10" class="outline-3">
<h3 id="sec-22-10"><span class="section-number-3">22.10</span> 门描述符</h3>
<div class="outline-text-3" id="text-22-10">
<p>
门描述符描述的是控制转移的入口点，它是通向另一段代码的门，可实现任务内特权级的变换和任务间的切换。任务
</p>
</div>
</div>
<div id="outline-container-sec-22-11" class="outline-3">
<h3 id="sec-22-11"><span class="section-number-3">22.11</span> 任务调度（x86特有）</h3>
<div class="outline-text-3" id="text-22-11">
<p>
任务是处理器可以分配调度、执行和挂起的一个工作单元。x86提供了一种机制来保存任务状态，算是x86特有的。估计不是通用的。任务切换操作不会把任何信息压入堆栈中，处理器的状态信息都被保存在内存中称为任务状态段的（TSS,Task State Segment）的数据结构中。当前指令的特权级CPL在保存在%cs（代码段寄存器）中。
</p>
</div>
</div>
<div id="outline-container-sec-22-12" class="outline-3">
<h3 id="sec-22-12"><span class="section-number-3">22.12</span> 有哪些中断处理程序没有关闭中断呢</h3>
</div>
</div>
<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> 思考</h2>
<div class="outline-text-2" id="text-23">
<ul class="org-ul">
<li>复杂的顺序结构和复杂的逻辑结构
</li>
<li>操作系统最重要的是进程管理，内存管理，文件系统。一些操作系统（嵌入式）可能没有文件系统也可能没有进程管理，进程管理和文件系统必须至少有一个才能
</li>
<li>对于硬件如磁盘来说，有不少动作，但是这些动作的模式却不多，硬件抽象的目的在于提取所有的模式，保证其内容都是完全的
</li>
<li>xv6中比较重要的结构体是proc，里面应该包含一个进程运行下去的所有内容。计算机是一状态机，根据当前的状态，计算出下一个状态，并具有可以完全丢弃当前状态的无后效性。proc设计的要点也在此。关键在于足够支持下一步的计算。
</li>
<li>处理器提供的很多功能或者指令本身没有特别东西，尤其是描述符的含义，其实可以自己去想象如何编写程序来处理，这样也就没有问题了，
</li>
<li>构建内核时先从可以运行开始，之后在增加功能，抽象的顺序大概就能理清了。
</li>
<li>有了一定感觉后把程序从开机到运行，并能够运行程序执行系统调用的做的事情理清。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> 参考</h2>
<div class="outline-text-2" id="text-24">
<ul class="org-ul">
<li><a href="http://blog.csdn.net/qq_25426415/article/category/6684908" target="_blank" rel="external">xv6源码分析</a>
</li>
<li><a href="http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html" target="_blank" rel="external">地址空间分布</a>
</li>
<li>xv6文档
</li>
<li><a href="https://segmentfault.com/a/1190000008308764" target="_blank" rel="external">xv6中存储cpu和进程信息的技巧</a>
</li>
<li>Intel 64 and IA-32 Architectures Developer's Manual: Vol.1
</li>
<li>Linux内核完全注释
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python入门]]></title>
      <url>/2017/07/08/Python%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 概述</h2>
<div class="outline-text-2" id="text-1">
<p>
Python的一大特点是各种概念十分简单而灵活。Python中一切皆对象，即使类型也是对象。所以有编程经验的人学习Python可以先理解其对象的构造。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Python对象</h2>
<div class="outline-text-2" id="text-2">
<p>
Python解释器先编译源码后生成了pyc文件，之后在启动虚拟机后加载pyc文件。
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Python对象的管理</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1"><span class="section-number-4">2.1.1</span> 概述</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Python中一切皆对象，当对象环境构建完成后，就可以使用同样的操作来处理每个对象了，所以一般推荐从object.c文件开始阅读。了解Python如何管理对象，以及对象是如何实现的。*
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Python3的整数对象</h3>
<div class="outline-text-3" id="text-2-2">
<p>
先看看他的定义：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _longobject {</span><br><span class="line">	PyObject_VAR_HEAD</span><br><span class="line">	digit ob_digit[<span class="number">1</span>];</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
</div>
<p>
这个是长整数对象，所以也是一个变长的对象。同时这也暗示了一件事情，对于类对象的定义之前其实要确定要生成的对象的结构，类对象更多的是确定方法而已。实际的数据除了公共部分还是需要自己定义的。这和定义类是差不多的。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Python对象模型（类型系统）</h2>
<div class="outline-text-2" id="text-3">
<p>
在这里先，对象模型做一个简要描述。对于一个集合O，
</p>
<ol class="org-ol">
<li>存在两种不对称关系：
<ol class="org-ol">
<li>is-instance-of
</li>
<li>is-kind-of
</li>
</ol>
</li>
<li>集合中只有一个对象&lt;type&gt;，&lt;type&gt;和&lt;type&gt;是is-instance-of关系的，&lt;type&gt;也称为metaclass对象；
</li>
<li>集合中只有一个对象&lt;object&gt;， &lt;type&gt; is-kind-of &lt;object&gt;；
</li>
<li>任意一个is-instance-of &lt;type&gt;的对象，都称为类对象（包括&lt;type&gt;也可以称为类对象）；
</li>
<li>任意一个is-instance-of 类对象的对象，都称为实例对象。
</li>
</ol>


<p>
以上便是Python对象模型的组成要素。可以看到有两个组成对象，&lt;type&gt;是所有对象实例化所依赖的。而object是所有类对象的最终父类。
同时这也只提供了这两个关系，这两个关系都是不对称的，也就是说我们可以知道一个实例对象所属类对象是哪个，但是我们无法知道这个类对象被实例化了多少实例对象。同理，我们可以知道一个类对象所属的类对象是哪个，但是我们也无法知道类对象有多少子类对象。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Python的类</h2>
<div class="outline-text-2" id="text-4">
<p>
构建类的过程需要借助类的元信息，
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 继承</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> super()</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
用于返回一个代理对象，它可以让我们访问父类或者其兄弟类的方法，不加参数的时候默认会返回的是当前类在MRO中的下一个。自己加了参数之后可以重新定位。必要的时候连当前类的子类也可以使用。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Python函数机制</h2>
<div class="outline-text-2" id="text-5">
<p>
Python的函数也是对象，我们def某个函数的时候其实就创建了一个函数对象。
</p>
</div>
<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> PyFunctionObject</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Include/funcobject.h*/</span>   </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *func_code;        <span class="comment">/* A code object, the __code__ attribute */</span></span><br><span class="line">    PyObject *func_globals;     <span class="comment">/* A dictionary (other mappings won't do) */</span></span><br><span class="line">    PyObject *func_defaults;    <span class="comment">/* NULL or a tuple */</span></span><br><span class="line">    PyObject *func_kwdefaults;  <span class="comment">/* NULL or a dict */</span></span><br><span class="line">    PyObject *func_closure;     <span class="comment">/* NULL or a tuple of cell objects */</span></span><br><span class="line">    PyObject *func_doc;         <span class="comment">/* The __doc__ attribute, can be anything */</span></span><br><span class="line">    PyObject *func_name;        <span class="comment">/* The __name__ attribute, a string object */</span></span><br><span class="line">    PyObject *func_dict;        <span class="comment">/* The __dict__ attribute, a dict or NULL */</span></span><br><span class="line">    PyObject *func_weakreflist; <span class="comment">/* List of weak references */</span></span><br><span class="line">    PyObject *func_module;      <span class="comment">/* The __module__ attribute, can be anything */</span></span><br><span class="line">    PyObject *func_annotations; <span class="comment">/* Annotations, a dict or NULL */</span></span><br><span class="line">    PyObject *func_qualname;    <span class="comment">/* The qualified name */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant:</span><br><span class="line">     *     func_closure contains the bindings for func_code-&gt;co_freevars, so</span><br><span class="line">     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)</span><br><span class="line">     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).</span><br><span class="line">     */</span></span><br><span class="line">} PyFunctionObject;</span><br></pre></td></tr></table></figure>
</div>
<p>
先了解一下
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 无参函数的调用</h3>
<div class="outline-text-3" id="text-5-2">
<p>
先看看下面这个代码
</p>
<div class="org-src-container">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Function"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f()</span><br></pre></td></tr></table></figure>
</div>
<p>
这里会被翻译成两个PyCodeObject，所以说这是直接的静态部分。可以直接翻译。程序运行的时候，
名字什么的也是用户动态设定的，所以直接存储在静态部分就可以了。
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 有参函数的调用</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Python中按照参数的形式可以分成四种类别：
</p>
<ul class="org-ul">
<li>位置参数
</li>
<li>键参数
</li>
<li>扩展位置参数
</li>
<li>扩展键参数
</li>
</ul>

<p>
在函数调用的过程中，一般是先解析参数，之后设置局部变量，无论时位置参数还是扩展位置参数都差不多。生成PyFrameObject，之后在这个PyFrameObject提供的环境下运行，Py<sub>EvalFrameEx会以PyFrameObject</sub>*为参数。PyFunctionObject在实际运行过程中不会被使用，只是用于保存信息
</p>

<p>
位置参数和键参数的个数只取决于键参数的只取决于实参
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 名字空间和PyFunctionObject的关系</h3>
<div class="outline-text-3" id="text-5-4">
<p>
在刚开始运行程序的时候，一般来说我们是运行一个模块，交互模式也有一个默认的模块。在一开始的帧中f<sub>locals和f</sub><sub>globals，所以我们在一开始这个真。</sub>
对于局部变量Python其实可以在编译时就知道它实际占用的空间，所以甚至可以不用字典来存储
名字空间决定了Python中很多的符号语义。
</p>

<p>
把名字空间和函数定义绑定的做法
</p>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 闭包</h3>
<div class="outline-text-3" id="text-5-5">
<p>
名字空间和函数捆绑后的结果称为闭包。所以有些东西是被静态绑定的。
</p>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> 修饰器和闭包</h3>
<div class="outline-text-3" id="text-5-6">
<p>
理解修饰器的关键在于理解闭包
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> <span class="todo TODO">TODO</span> 引用计数功能的实现</h2>
<div class="outline-text-2" id="text-6">
<p>
为了支持引用计数，Python在每个对象的开头增加一个字段，用于记录引用计数的值，在64位系统下这个值也是64位有符号整数（之所以有符号可能有其他作用吧，以后再补充）。
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Py_IncRef</span><span class="params">(PyObject *o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Py_DecRef</span><span class="params">(PyObject *o)</span></span>; <span class="comment">// 相比之下这个函数要处理引用计数为0的情况</span></span><br></pre></td></tr></table></figure>
</div>
<p>
需要注意的是一个对象符合释放其内存是在对象指向的类对象中描述的。另一方面，Python由于释放对象需要使用Python对象的类对象的函数，所以Python对象的共同部分是不能缺少达到类对象的能力。所以对于每个Python对象而言引用计数和指向类对象的指针是必要的。实际上，PyObject开头两个字段也正是这两个：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _object {</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="keyword">struct</span> _typeobject *ob_type;</span><br><span class="line">} PyObject;</span><br></pre></td></tr></table></figure>
</div>
<p>
对于可变长度的对象，其定义是
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">} PyVarObject;</span><br></pre></td></tr></table></figure>
</div>
<p>
可以看到只是在原有的基础上增加了一个字段，只是对PyObject的扩展而已，因此这是三个我们最常用的字段，为了方便我们使用，并且提高可读性，又提供了以下宏：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Py_REFCNT(ob)           (((PyObject*)(ob))-&gt;ob_refcnt)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Py_TYPE(ob)             (((PyObject*)(ob))-&gt;ob_type)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Py_SIZE(ob)             (((PyVarObject*)(ob))-&gt;ob_size)</span></span><br></pre></td></tr></table></figure>
</div>
<p>
有趣的一点是Python中异常也是对象，其类对象也是静态分配的内存。
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 对象的创建和初始化</h3>
<div class="outline-text-3" id="text-6-1">
</div><div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> 接口的实现</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
和C++类似，PyObject申请内存和初始化内存的方式也是分开的。这样可以更加灵活。对象的创建信息在类对象中，所以如果想要创建一个非类对象，首先要必须有一个类对象。所以类对象是Python虚拟机的基石。
</p>
</div>
</div>
<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2"><span class="section-number-4">6.1.2</span> 对象的内存管理器</h4>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 生成器对象</h3>
<div class="outline-text-3" id="text-6-2">
<p>
带有yield的函数可以
</p>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 作用域和命名空间</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Python中作用域往往没有明确的制定，我们可以制定一个符号的作用域。除了global作用域以外（或者global其实最终也被加入到某个函数之内？），总是关联到某个函数。按字面意义就是某个符号绑定有效的区域。
相对而言，命名空间是显式指定的，要在名称前加前缀。
一个符号的作用域是在编译时决定的，主要看作用域中是否有绑定语句。
而解析道具体的值的行为则是在运行时决定的。
简单地说，符号在哪里解析是在编译时决定的，这是实现闭包的要求，而符号的值则是在运行时解析的。
这里一个比较容易出错的问题是但我们能够使用某个函数对象的时候，其实其外层作用域已经被建立了。
</p>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 内存布局</h3>
<div class="outline-text-3" id="text-6-4">
<p>
默认情况下，Python对象的开头是一个用于引用计数的指针，之后是只是对象类型的Type。
</p>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 字符串对象</h3>
<div class="outline-text-3" id="text-6-5">
<p>
Python按照对象内存固定和不固定来区分定长对象和变长对象，其长度一般存储在对象中，而根据在运行时是否改变对象的的内存来区分对象的类型，分为可变对象和不可变对象，
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 符号绑定</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 概述</h3>
<div class="outline-text-3" id="text-7-1">
<p>
简单地说，Python使用符号来绑定对象来复用对象。虽然Python的绑定方式语法不止一种，但实际上都是一样的。类似import、def等都是可以看作是绑定对象和符号的语法糖。可以理解为对于某些类型的对象是可以有特殊的绑定方式以便于阅读（？）。
跟C++比较不同，个人感觉Python的对于内在一致性还是比较重视的，如Python3把print关键字都去掉了。是可以有特殊的绑定方式以便于阅读（？）。
跟Java不同，Python其实不存在C语言概念上的值，一切皆对象，表达式求值其实得到的是对象。C语言中的值是指的变量表示的内存块的状态，而Python的值指的反而倾向指某个对象，所以C语言的赋值等号指的是改变变量状态。
C++对象系统的一个设计目标是是对象的表现得像基本数据类型一样，Python没有基本数据类型，所以对象系统整体要简单得多。
Python终归是过程式语言，所以还是必须有改变状态的操作，对象占用实际的内存，所以改变对象的状态的能力还是需要的。函数
</p>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 修饰器</h2>
<div class="outline-text-2" id="text-8">
<p>
修饰器的一大要求是接口不要改变，这样才能保持透明，然而修饰器这个语法糖其实没有什么限制，只要函数可以接受一个参数基本就能够使用修饰器语法了。为了保持透明度，就需要保持函数信息的不缺失，这个时候就需要有functools.wraps来包装函数。
</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> PyDictObject分析</h2>
<div class="outline-text-2" id="text-9">
<p>
PyDictObject在Python中大量使用，所以其实
</p>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Python的编译流程</h2>
<div class="outline-text-2" id="text-10">
</div><div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 虚拟机</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Python的虚拟机相比Java的更加抽象，也就是说离真实的机器更远。这也意味着我们能优化的粒度不大。Python的虚拟机主要在于模拟cpu运行程序的过程。它运行的是PyCodeObject包含了程序的字节码指令和静态信息。
</p>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 编译器</h3>
<div class="outline-text-3" id="text-10-2">
<p>
虚拟机运行的代码是用一个PycodeObject来表示的，相关的信息存储在该对象中。作用域本身在代码中是隐含的概念，但在编译后其实是一个实在的概念，它会对应一个PyCodeObject。
PyCodeObject，
</p>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Python对数据结构和算法的支持被</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 前言</h3>
<div class="outline-text-3" id="text-11-1">
<p>
一般而言数据结构最为重要的依然是读写和映射机制。
</p>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> 可迭代对象</h3>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Python运行环境的初始化</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> 概述</h3>
<div class="outline-text-3" id="text-12-1">
<p>
Python真正意义上的初始化，调用的是函数 <code>Py_Initialize</code> ，如下：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">Py_Initialize</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>{</span><br><span class="line">    Py_InitializeEx(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
可以看到这个函数之后又直接调用了 <code>Py_InitializeEx</code> ，这个函数的作用大致上包括：
</p>
<ol class="org-ol">
<li>加载多个基础的module，如_<sub>builtin</sub>_<sub>，sys等</sub>
</li>
<li>完成Python类型系统的初始化
</li>
<li>异常系统的初始化
</li>
</ol>

<p>
启动类型系统的初始化是非常复杂的，
接下来就是设置系统module
</p>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> <span class="todo TODO">TODO</span> 线程的初始化</h3>
</div>
<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> 系统module的初始化</h3>
<div class="outline-text-3" id="text-12-3">
<p>
虚拟机创建的第一个module是_<sub>builtin</sub>__ module。interp-&gt;modules创建为一个PyDictObject对象，这个对象维护系统所有module，这些module是所有的PyThreadState使用。接下来分析一下<sub>PyBuiltin</sub><sub>Init，可以看到</sub>
</p>
</div>
</div>
<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> 激活Python虚拟机</h3>
<div class="outline-text-3" id="text-12-4">
<p>
Python进入到字节码虚拟机后才是真正地执行。Python有两种运行方式，一种是交互环境，一种是类似Python test.py这样的运行脚本的方式。但最终它们都进入了同一个字节码虚拟机。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Python虚拟机的进程和线程</h2>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> Python的名字空间</h2>
<div class="outline-text-2" id="text-14">
<p>
Python的名字空间有三个：builtins、global和local。Python每一个文件被视为一个module。一个符号是用于代表某些事物的一个有主语记忆的字符序列。module的一个目的是划分名字空间。module加载的方式有两种：
</p>
<ol class="org-ol">
<li>通过import动态加载
</li>
<li>以脚本模式运行的文件，作为主module被自动加载
</li>
</ol>
<p>
无论那种方式，加载的过程都会执行其中的表达式。Python中改变名字空间的语句是赋值语句（不算表达式）。一个 "对象的名字空间" （一切皆对象，所以名字空间也属于对象）。一个对象的名字空间中的所有名字都称为对象的属性。对于module，名字空间的规则很清晰，而对于一个module，名字空间的使用有另一套规则。在module内部，名字空间存在可见行的问题。在一个模块内部名字空间和作用域对应，所以需要注意的是Python虽然很多东西都是动态加载的，但作用域都是静态作用域（词法作用域）。builtins是最顶层的名字空间，global是module的名字空间，而global是module中的函数的名字空间。Python运行过程中搜索一个名字的顺序是locals-&gt;globals-&gt;modules
</p>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> C11的原子操作</h2>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> Python多线程</h2>
<div class="outline-text-2" id="text-16">
<p>
Python的内置的线程库有两个，thread和threading。其中thread是builtin module，而threading是标准库中的模块，是在thread的基础上实现的。
Python启动时并不支持多线程，也就是说Python支持多线程的数据结构和GIL都是没有创建的。这是有Python的使用场合决定的。
Python3的多线程比较难以理解，这里先使用Python2的源码来分析。
Python的threading库可以在线程中执行任何python的可调用对象
</p>
</div>
<div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1"><span class="section-number-3">16.1</span> Python2 GIL的实现</h3>
<div class="outline-text-3" id="text-16-1">
<p>
首先GIL是一个变量，其类型是void* 。
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyThread_type_lock interpreter_lock = <span class="number">0</span>; <span class="comment">/* This is the GIL */</span></span><br><span class="line">PyThread_allocate_lock(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">sem_t</span> *lock;</span><br><span class="line">    <span class="keyword">int</span> status, error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dprintf((<span class="string">"PyThread_allocate_lock called\n"</span>));</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">	PyThread_init_thread();</span><br><span class="line"></span><br><span class="line">    lock = (<span class="keyword">sem_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">sem_t</span>)); <span class="comment">// 分配sem_t</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) {</span><br><span class="line">	status = sem_init(lock,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	CHECK_STATUS(<span class="string">"sem_init"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error) {</span><br><span class="line">	    <span class="built_in">free</span>((<span class="keyword">void</span> *)lock);</span><br><span class="line">	    lock = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dprintf((<span class="string">"PyThread_allocate_lock() -&gt; %p\n"</span>, lock));</span><br><span class="line">    <span class="keyword">return</span> (PyThread_type_lock)lock;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
</div>
<p>
所以看到这里的GIL其实是信号量，由于Python需要可以同时在Windows上运行，所以，GIL才会是void*类型，否则如果只要在Linux上运行，就只会需要sem<sub>t</sub>*类型。创建了GIL后，
</p>

<p>
PyThread<sub>acquire</sub><sub>lock</sub>()有两种工作方式，通过参数waitflag来划分，如果waitflag的值大于0,则代表当前线程是否等待其他线程释放GIL，然后由操作系统唤醒。
GIL算是主要的多线程环境了，之后就是创建多线程。
Python的线程接口接近程序的接口。
</p>
</div>
<div id="outline-container-sec-16-1-1" class="outline-4">
<h4 id="sec-16-1-1"><span class="section-number-4">16.1.1</span> 线程状态保护机制</h4>
<div class="outline-text-4" id="text-16-1-1">
<p>
首先，还需要理清Python中线程的问题，在《Python源码剖析》中讲到Python线程是原生线程，这个其实会造成混淆。其实只是线程时一个描述动态过程的概念，python自然需要线程的支持。但是对于线程的理解，在虚拟机上，应该指的是运行虚拟机字节码的流程（即字节码一个个运行的流程）。而不要再考虑C语言级别。那么问题就是，线程时运行字节码的过程，给Python虚拟机造成的副作用，虚拟机没有寄存器的概念，所以写入寄存器对应压栈。
Python3使用了c11的机制
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> 实用知识</h2>
<div class="outline-text-2" id="text-17">
</div><div id="outline-container-sec-17-1" class="outline-3">
<h3 id="sec-17-1"><span class="section-number-3">17.1</span> <span class="todo TODO">TODO</span> 将数据结构读取到文件中</h3>
</div>
<div id="outline-container-sec-17-2" class="outline-3">
<h3 id="sec-17-2"><span class="section-number-3">17.2</span> 如何提供引用计数功能</h3>
<div class="outline-text-3" id="text-17-2">
<p>
首先Python中使用到的对象每个在内存中的第一个位置就是引用计数的整数内存，目前是64位的整数。编程时要手动使用增加和减少引用计数来维护。由于比较常用，所以可以使用宏或者inline函数来减少开销。
引用计数的增加和减少，需要注意的是指针为NULL的情况
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    (((PyObject*)(op))-&gt;(ob_refcnt++))             \</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Py_DECREF(op)\</span><br><span class="line">    do {        \</span><br><span class="line">	PyObject* _py_decref_tmp = (pyObject*)(op);\</span><br><span class="line">	<span class="keyword">if</span> (--(_py_decref_tmp) == <span class="number">0</span>) {                \</span><br><span class="line">	    _Py_Dealloc(_py_decref_tmp);      \</span><br><span class="line">	}                                     \</span><br><span class="line">    } while(<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> Py_XINCREF(o)                              <span class="number">1</span>       \</span><br><span class="line">    do {                                           \</span><br><span class="line">	PyObject* _py_xincref_tmp = (PyObject*)o;  \</span><br><span class="line">	<span class="keyword">if</span> (_py_xincref_tmp) {                             \</span><br><span class="line">							\</span><br><span class="line">	}                                          \</span><br><span class="line">    } while (<span class="number">0</span>)</span></span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> 模块对象</h2>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> 实用函数</h2>
<div class="outline-text-2" id="text-19">
<p>
关于字符串的匹配问题，Python提供了大约三种工具，一般处理函数、Unix shell格式的匹配以及正则表达式匹配，三者的用法有所不同而已。
</p>
</div>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> 虚拟机初始化</h2>
<div class="outline-text-2" id="text-20">
<p>
虚拟机的初始化过程其实已经把必要的东西都构建完毕了，我一其实没有足够的内容了。
</p>
</div>
</div>
<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> Python字节吗拆解</h2>
<div class="outline-text-2" id="text-21">
<p>
dis模块是Python提供的反编译的结果，Python提供了用户去访问，PyCodeObject的能力，所以可以在运行时改变程序的行为
</p>
</div>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> Python2和Python3的某些不同</h2>
</div>
<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> Python虚拟机</h2>
<div class="outline-text-2" id="text-23">
</div><div id="outline-container-sec-23-1" class="outline-3">
<h3 id="sec-23-1"><span class="section-number-3">23.1</span> 前言</h3>
<div class="outline-text-3" id="text-23-1">
<p>
Python虚拟机属于高级语言虚拟机，所以其实对于虚拟机的研究着眼于对程序运行时的理解。Python程序编译成虚拟机可执行的格式之后才会运行。可执行文件是描述一个程序的静态部分，它足以描述一个的虚的一切。但是程序在未运行之前是无法了解其结果的，原因是我们的程序中一般包含“空白”，没有这个“空白”是无法得到具体结果的，程序的空白一般是对应“参数”，用户输入这些。一个程序在运行过程中必须要能够填补这些”空白“。允许时的一大关键作用就是填补“空白”。所以我的思路是先了解一个有“空白”的程序，在根据这些空白来了解运行时。
</p>
</div>
</div>
<div id="outline-container-sec-23-2" class="outline-3">
<h3 id="sec-23-2"><span class="section-number-3">23.2</span> PyCodeObject对象</h3>
<div class="outline-text-3" id="text-23-2">
<p>
Python程序被编译后生成pyc格式的文件，而pyc格式的文件会被虚拟机读取后会被解析为PyCodeObject对象。为了方便起见，这里直接关注PyCodeObject对象的内容，其实没有本质区别。
PyCodeObject对象在Python 3.6.2中的定义是：
</p>
<div class="org-src-container">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Bytecode object */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;               <span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_kwonlyargcount; <span class="comment">/* #keyword only arguments */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;                <span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;              <span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;          <span class="comment">/* CO_..., see below */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;   <span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_code;             <span class="comment">/* instruction opcodes */</span></span><br><span class="line">    PyObject *co_consts;   <span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;            <span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames; <span class="comment">/* tuple of strings (local variable names) */</span></span><br><span class="line">    PyObject *co_freevars; <span class="comment">/* tuple of strings (free variable names) */</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest aren't used in either hash or comparisons, except for co_name,</span><br><span class="line">       used in both. This is done to preserve the name and line number</span><br><span class="line">       for tracebacks and debuggers; otherwise, constant de-duplication</span><br><span class="line">       would collapse identical functions/lambdas defined on different lines.</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *co_cell2arg; <span class="comment">/* Maps cell vars which are arguments. */</span></span><br><span class="line">    PyObject *co_filename; <span class="comment">/* unicode (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;             <span class="comment">/* unicode (name, for reference) */</span></span><br><span class="line">    PyObject *co_lnotab;   <span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span><br><span class="line">				   Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">    <span class="comment">/* Scratch space for extra data relating to the code object.</span><br><span class="line">       Type is a void* to keep the format private in codeobject.c to force</span><br><span class="line">       people to go through the proper APIs. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_extra;</span><br><span class="line">} PyCodeObject;</span><br></pre></td></tr></table></figure>
</div>
<p>
它对于Python源码中的一个代码块
</p>
</div>
</div>
</div>
<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> 装饰器</h2>
<div class="outline-text-2" id="text-24">
<p>
有特殊的语法糖，所以没有足够的内容，没有
</p>
</div>
</div>
<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25"><span class="section-number-2">25</span> 使用Python来进行脚本编程和系统管理</h2>
<div class="outline-text-2" id="text-25">
</div><div id="outline-container-sec-25-1" class="outline-3">
<h3 id="sec-25-1"><span class="section-number-3">25.1</span> Python解析命令行</h3>
<div class="outline-text-3" id="text-25-1">
<p>
相比Shell，Python解析命令行要麻烦一些，但是功能强大。一般使用argparse这个模块来解析。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26"><span class="section-number-2">26</span> 虚拟环境</h2>
<div class="outline-text-2" id="text-26">
<p>
一般虚拟环境最常用的是virtualenv
</p>
</div>
</div>
<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27"><span class="section-number-2">27</span> 协程的实现</h2>
<div class="outline-text-2" id="text-27">
<p>
Python有不只一种的协程实现。协程其实就是一个例程，可以在任意地方进入，也可以在任意地方离开。
</p>
</div>
</div>
<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28"><span class="section-number-2">28</span> 生成器的原理</h2>
</div>

<div id="outline-container-sec-29" class="outline-2">
<h2 id="sec-29"><span class="section-number-2">29</span> 零散</h2>
<div class="outline-text-2" id="text-29">
<ul class="org-ul">
<li>就函数调用来说，存在顶层，这个顶层存在global的命名空间。
</li>
<li>当我们进入Python的交换模式之后发现打印了文字之后，其实Py<sub>Initialize已经被调用了，所以</sub>
</li>
<li>Python中类似sys其实很早就被加载了，但是为了让初始环境比较干净，它并没有让这些东西变得可见。
</li>
<li>表达式一般要求返回某个类型的值
</li>
<li>虚拟机是比较原始的代码了，基本已经不是一般的应用层编程了。
</li>
<li>Python的虚拟机自定义了类型系统，而每个类型都是而且都可以作为PyObject，所以可以统一处理。但相对的，就必须在编写虚拟机之前，把内置类型都处理完毕。
</li>
<li>字节码指令对符号或者常量的操作最终都反应到运行时栈和local名字空间
</li>
<li>复制语句有不同的解释
</li>
<li>名称解析到哪个作用域是函数定义的时候就决定了
</li>
<li>赋值的说法其实是是C语言的概念，虽然多数时候可以套用，但是如果不把好其中的区别，很容易会出错。
</li>
<li>表达式有多种，一个共同的特点是只有一个返回值。返回一个列表也算是只有返回值，这个和Python的解构绑定可以达到返回多个值的效果。
</li>
<li>函数也是对象
</li>
<li>符号在哪个作用域解析是静态决定的，而符号解析到值的过程实在运行时决定的。
</li>
<li>一切皆对象可以让内存被统一管理，而对象的类型择提供了如何使用的信息，包括管理。所以类型对象是虚拟机基础的部件。另一方面，这也说明不同类型直接的差别可以非常巨大。
</li>
<li>要注意C和Python的隔离，不要把概念混淆
</li>
<li>Python源码的实现有很多看起来对于学习编译原理没有用的东西，但要有耐心，这是工业级的代码
</li>
<li>突然对于C语言有了新的想法，其实全局的内容（表现是拥有全局的符号）构成了一个程序的基础结构。而其他局部的数据则构成了各个局部对象的内容
</li>
<li>对于static即使取得了外部地址，也会引起段错误。虽然实在运行时发现的错误，不过也可以说明这是没有漏洞的。
</li>
<li>一切皆对象的另一个作用是统一了内存管理的形式，虚拟机的构建也是基于该结构的
</li>
<li>栈帧是执行环境的一种实现，Python使用PyFrameObject来实现，Python倾向用链表实现栈
</li>
<li>PyAPI<sub>FUNC</sub> 是为了和C++交互，同时显示声明这是一个Python公开的符号，这样当想用C/C++来调用Python中的函数时就可以使用了。
</li>
<li><code>__builtin_offsetof</code> 是gcc提供的函数，可以计算编译器在宏里面的函数
</li>
<li>Python一开始就将一切对象化的做法，使得Python本身元编程能力极强
</li>
<li>但对象引用计数为0时要调用tp<sub>dealloc字段指向的函数，如果对象是通过tp</sub><sub>alloc申请的，最后tp</sub><sub>dealloc就会调用这个函数。所以tp</sub><sub>dealloc可能是存在的</sub>
</li>
<li>Py<sub>True</sub>, Py<sub>True的本质是PyLongObject对象，我一其实还是使用整数来替代</sub>
</li>
<li>关联容器的目的是将两个关联的元素联系起来，方便用户通过一个元素来找到关联的元素。有趣的是一般使用关联起来的两个元素是没有公共信息的元素，也就是你不可以通过一个元素来限定另一个元素的取值。要达到这个程度才是关联容器的作用之处。
</li>
<li>需要如何hack
</li>
<li>关联容器的关联是某种关系，可以看作一一映射，一般情况下，我们然它们在一块内存里。PyDictObject，使用元素对实现映射的概念。Python的hash表存储的对象用于存储这些联系。
</li>
<li>如何访问一个集合，如果是用连续的内存空间来存储集合元素，那么，其实地址可以代表这个集合，因为我们会需要起始地址来访问。如果是链式的集合，我们需要通过某个元素从而达到所有的元素。比方说单向的树，往往只有根节点满足条件，而图的话需要存储的是内存。通过连续的空间来组织。总之我们表示集合的对象需要能够访问集合中所有对象的能力的所有能力。
</li>
<li>Python里面有的对象是可以操作的对象和自动回收的对象，此时则以PyObject作为其基础类型
</li>
<li>线程是一个动态的概念，我们用于表示线程的结构体，本身又是静态的数据，所以可以认为是线程对应的对象。
</li>
<li>PyInterpreterState对象维护着所有的PyThreadState对象的使用，
</li>
<li>需要注意的是Python目前依旧不能运用多核的性能，所以没救。PyPy是在CPython上使用的
</li>
<li>按域语言来算Python的module也可以是C语言编写的。
</li>
<li>Python虽然有对应线程的对象，但是其实进程调度都是借助操作系统的原生线程。
</li>
<li>启动线程的参数时void* ，因为void*类型本身意味着可以指向任何东西。
</li>
<li>还需要再次提醒，GIL（全局解释器锁）是对于多线程而言。所以无法利用多核。
</li>
<li>所谓的Python使用的原生线程是值他们的线程接口的实现实质是包装了函数
</li>
<li>实际上Python的运行器错误才称为异常
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-30" class="outline-2">
<h2 id="sec-30"><span class="section-number-2">30</span> <span class="todo TODO">TODO</span> 问题 <code>[%]</code></h2>
<div class="outline-text-2" id="text-30">
<ul class="org-ul">
<li><code>[&#xa0;]</code> 内置的类对象一般处于数据段中，而动态加载类库的时候应该是动态在堆中分配内存，其具体过程是怎样的？
</li>
<li><code>[&#xa0;]</code> Python是如何设计的？
</li>
<li><code>[&#xa0;]</code> tp<sub>free和tp</sub><sub>dealloc的区别</sub>
</li>
<li><code>[&#xa0;]</code> tp<sub>itemsize的作用</sub>
</li>
<li><code>[&#xa0;]</code> tp<sub>new的作用</sub>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-31" class="outline-2">
<h2 id="sec-31"><span class="section-number-2">31</span> 解答</h2>
<div class="outline-text-2" id="text-31">
</div><div id="outline-container-sec-31-1" class="outline-3">
<h3 id="sec-31-1"><span class="section-number-3">31.1</span> Python中一个类型最重要的是需要考虑哪些字段？</h3>
<div class="outline-text-3" id="text-31-1">
<p>
首先是创建的部分，需要有申请内存和释放内存的部分，对应到PyTypeObject就是tp<sub>new和tp</sub><sub>dealloc。long</sub><sub>as</sub><sub>number</sub>
</p>
</div>
</div>
<div id="outline-container-sec-31-2" class="outline-3">
<h3 id="sec-31-2"><span class="section-number-3">31.2</span> Python模块、库和包的区别？</h3>
<div class="outline-text-3" id="text-31-2">
<p>
库只是一个比较笼统的概念，在Python中不和模块以及包相提并论。模块一般值一个Python文件，包是指带有_<sub>init</sub>__.py的目录，目录下可能有模块或者其他子包
</p>
</div>
</div>
<div id="outline-container-sec-31-3" class="outline-3">
<h3 id="sec-31-3"><span class="section-number-3">31.3</span> 线程调度机制有哪些基本问题?</h3>
<div class="outline-text-3" id="text-31-3">
<ul class="org-ul">
<li>何时进行线程调度？
</li>
<li>如何选择激活哪个线程？
</li>
</ul>
<p>
有趣的是Python的线程选择直接有操作系统来操作，所以Python的线程是原生线程。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-32" class="outline-2">
<h2 id="sec-32"><span class="section-number-2">32</span> 参考</h2>
<div class="outline-text-2" id="text-32">
<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/30082392" target="_blank" rel="external">知乎：python中的模块、库、包有什么区别？</a>
</li>
<li><a href="https://stackoverflow.com/questions/5607283/how-can-i-manually-generate-a-pyc-file-from-a-py-file" target="_blank" rel="external">stackoverflow How can I manually generate a .pyc file from a .py file</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编程思考]]></title>
      <url>/2017/07/07/%E7%BC%96%E7%A8%8B%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <span class="todo TODO">TODO</span> 计算模型</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 概要</h3>
<div class="outline-text-3" id="text-1-1">
<p>
计算模型不只一种，而在不同的计算模型下对于计算过程有不同的描述。程序语言出现的目的在于压缩这些描述。压缩这些描述的技巧在于尽量找出重复的元素。我们成这种做法叫提取复用元素。一般可以复用的元素包括：
</p>
<ul class="org-ul">
<li>变量（复用内存）
</li>
<li>函数（复用计算过程）
</li>
<li>类型
</li>
<li>对象（同时复用内存和计算过程）
</li>
</ul>
<p>
同时各个编程语言对于相同的复用元素的复用能力有不同的设定。类似过程式编程，函数一般不是第一类对象，不能作为参数或返回值。在函数的复用能力上不如函数式语言。
然而，编程语言的复用能力并不是衡量一门语言的唯一因素。由于程序员是容易犯错的人，这在C/C++的使用中已经被证明了，所以压缩格式并不是单纯以压缩率来确定的，尽管不同的压缩方式（语言特性的组合）确实有区别，但我们可以在保证一个压缩等级的情况下选择更加适用于程序员编写程序的压缩格式。所以另一个问题是如何构造安全和简洁的压缩格式，也即程序语言。后一个目标其实更为重要，因为现代语言能提供压缩等级不多。
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 一般过程式语言的函数和函数式语言的函数</h3>
<div class="outline-text-3" id="text-1-2">
<p>
过程式语言是依靠改变状态来实现运算的，但函数也有返回值，如果我们不使用该返回值，这个值也就不会其作用，但是这个值有时也可以像函数式语言一样控制计算。在过程式语言中返回值可以反映部分状态信息。过程式语言读取并改变状态就是全部了。而函数式语言比较简单，只有映射一说。
对于过程式编程语言来说函数的返回值可以看做当前状态的映射，所以对于改变状态之后值也可能会不同。
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 学习语言的思路</h3>
<div class="outline-text-3" id="text-1-3">
<p>
首先是要明白这门语言提供了什么来支持计算，一般该有的都有。
</p>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> C语言</h3>
<div class="outline-text-3" id="text-1-4">
<p>
作为典型的过程式语言，这个语言能描述的东西分成了三类，读、写、运算（读和写的对象是内存，而运算是不会改变内存的，这样就分成了三类）。当然从函数式语言的角度上看，也可以分成两类，写和运算（读也是当作一种运算）。个人在编写C语言的过程中最大感觉是但这三者分得比较开时，往往能降低一定的编程复杂度。无副作用的函数可以看作是运算。而有副作用则应看作过程，这类过程的接口需要比较多的说明才能被理解。相比之下无副作用需要的额外说明相对较少。
另外，把读看作运算可以提高抽象程度，所以C++可能也倾向于此。当然，过程才是编程的重点和难点，区分好写和运算只是降低了复杂度而已。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 关于子任务和父任务</h2>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 面向对象</h2>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 编程语言的特性和共性</h2>
<div class="outline-text-2" id="text-4">
<p>
一般编程语言都有自己的特性，先总结一下这些特性，首先要知道这门语言使用的计算模型，是图灵机还是lambda演算（还是其他，不过主流就这两种）。无论是图灵机还是lambda演算，它们都离不开计算（否则怎么叫计算机呢）所以最基本的是语言如何进行算数运算，计算机运行的过程其实全部都是算数运算（可执行代码都是二进制的）。最基本的是四则运算，其他更加复杂的运算都可以基于这些和语言的其他机制来模拟，当然有些语言可能把它作为我基础的语言元素，这个也需要学习。有了计算当然不能离开计算的对象了，所以需要有基本的类型系统，一开始是先是初级的类型系统，符合类型要之后再看。接下来就是抽象了，否则写出的复杂一点的程序都不能看了。首先只有计算和数据写出来的叫计算过程。我们需要有东西来为这个计算过程命名，之后复用，这就是函数命名，或者说过程抽象。同时我们操作的运算对象可能十分复杂，所以还需要对数据进行抽象，也就是变量命名。另一方面，我们编写计算过程的时候，如果只是一条指令一条指令地编写，那样是不能描述类似无限这样的情况，对于不知道合适要停止运算的情况就无法描述了，所以需要一种可以描述无限的代码结构，或者通过跳转（如C语言的goto）来达成，或者通过循环，或者通过递归，具体要看语言采用的方案了。需要注意的是递归拥有的能力远不止如此。可以独立作为一种特性来看待。
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 关于抽象和函数定义（符号定义的思考）</h2>
<div class="outline-text-2" id="text-5">
<p>
一般的思考是，对于一个符号的定义如果使用了其他符号，则可以认为该符号的抽象层次可以高于其他符号。然而，没那么简单，符号的定义可能是相互的。虽然一般不至于循环定义但是如果几个定义间相聚很远的话十分难以理解，而且要认为它们的抽象层次是一样的。但我们认为一个符号的抽象层次高于另一个符号时，可能又有一个符号的定义同时使用了这两个符号，所以其实抽象层次是意义的，所以当一个符号的定义涉及到了另一个符号时，如果哪个符号也是全局的，那么这两个符号的抽象层次其实是一样的。那如果用到的符号是局部的呢（如C语言的static）？在外面不存在两个符号的比较，所以也不是问题吧。。。所以啊。。。抽象的关键还是在于隐藏。同时暴露的符号还是属于同一个抽象层的。但这是C语言的偷懒方法。。。。同一个抽象层的划分还是必要的。按抽象层次划分已经试过了，太过复杂，所以可以按功能、副作用相关行什么的来划分。所以之后的研究方向就是在一个抽象层对各个符号进行划分。
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 数据类型的理解</h2>
<div class="outline-text-2" id="text-6">
<p>
数据类型的理解其实没有足够的，
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 关于接口继承和抽象到具体的过程</h2>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 自动内存管理</h2>
<div class="outline-text-2" id="text-8">
<p>
其实C语言也有自动内存管理，虽然这是由编译器提供的，它属于管理可以在编译期确定生命周期的内容。如为了支持函数调用而使用的堆栈。
自动内存管理的直接目的是让名称的生命周期和内存保持一致，也就是说只要实现了这一点就称得上自动内存管理。至于使用的是引用计数还是垃圾回收那又是另一回事了。
</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 关于模块化</h2>
<div class="outline-text-2" id="text-9">
<p>
对于过程式语言，不得不使用作用域比较大的变量，如全局变量或者静态全局变量。由于函数的副作用无法重接口就看出来，所以看到一个模块中的函数就可能需要考虑其是否会对一个全局变量造成修改，全局变量越多造成的负担越大。所以模块化的目标是降低这个复杂度。并不是所有函数都会修改所有全局变量，而且不同的全局变量往往值是正交的，同时也不是所有函数都有副作用。
</p>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> <span class="todo TODO">TODO</span> 可能的方案 <code>[20%]</code></h3>
<div class="outline-text-3" id="text-9-1">
<p>
果然全局变量的问题还是无解的，一个变量被设定为全局的本身意味着要写函数来改变它的值，所以问题是要如何选择是否将一个变量设定为全局的。所以关键是对静态变量的作用域的设定。模块化的关键是限制某些要设为静态变量的作用范围，宏观上看，全局变量的改变是运算的目的，而静态全局变量是支持运算。对于单进程程序而言这样不会造成问题。
问题变成了如何减少一个函数需要 <b>考虑的变量数量</b> ，为了这个目的而模块化。
如果全局变量之间是正交的，分开为不同的模块是可行的
</p>
<ul class="org-ul">
<li><code>[&#xa0;]</code> 减少符号的做法只是缓解C语言的问题，不可太过执着。
</li>
<li><code>[X]</code> 全局变量在一个文件中可行吗？
</li>
<li><code>[&#xa0;]</code> 一个过程依赖的变量要最小化，也就是最小化其可能的最大副作用。
</li>
<li><code>[&#xa0;]</code> 如何利用功能模块化，有副作用的模块和无副作用的模块是分得比较开的。
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 概念到实现</h2>
<div class="outline-text-2" id="text-10">
<p>
现实的概念中有很多联系，我们先把能直接用数据表示的概念用内存表示，之后再使用粘合剂将各种内容联系起来。
</p>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 解答</h2>
<div class="outline-text-2" id="text-11">
</div><div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 全局变量放在一个文件可行吗？</h3>
<div class="outline-text-3" id="text-11-1">
<p>
不可行，这样还要static全局变量做什么？一个函数的符号本身，
</p>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 关于大型结构体的思考和化简</h2>
<div class="outline-text-2" id="text-12">
<p>
大型结构体中各个字段如果都是正交还好，但是很多时候存在结构体间的值是相关的，也就是你改变一个值就需要改变另一个字段的值。能把相关的字段合并为一个字段最好，有时甚至可以消去，有时甚至可以消去（当它是可以从其他字段直接计算的时候），如果不能，要区分开与其正交的字段，同时要理清于其相关的字段的依赖关系，哪个在前，哪个在后，没有依赖的字段要先修改，之后慢慢计算楚依赖它的字段的新值。
</p>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> 编程语句块的独立性和建立计算</h2>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> 关于多进程和多线程</h2>
<div class="outline-text-2" id="text-14">
<p>
但前计算机的进程仍然是一个自动机的动态运行的概念，所以目标仍然是收敛于某个状态。多进程编程要考虑不同进程的状态的相互影响，而多线程编程则是有共有的状态，相互影响的部分和多进程一样。目前还想不出两者在概念上有和区别。或者只是代价的区别而已？
Linux下的fork()复用了Linux环境，这是个优点。不过它同一个代码中，会有一些代码是不会被父进程使用的，也就是有只属于子进程的代码。父进程无所谓，只是增加了一段不会运行的代码而已，其他的和编写单进程程序没有太大区别。如果在运行完独有的代码之后还要运行公共代码，此时相当于要考虑两个后条件，复杂度似乎会增加。
</p>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> 关于如何阅读模块</h2>
<div class="outline-text-2" id="text-15">
<p>
肯定是先知道模块的接口
代码本来就不是线性阅读的，更接近树形
</p>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> 如何确定程序逻辑</h2>
<div class="outline-text-2" id="text-16">
<p>
其实要从我们知道的入手，而不去做太多的假设
</p>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> 关于类型的制约</h2>
<div class="outline-text-2" id="text-17">
<p>
一个函数的类型是确定的，所以其内容不稳定。范型函数可以可以描述更多的行为，何乐而不为呢?可以没有模板的C语言只能用宏来代替先了。
</p>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> 动态类型和模板</h2>
</div>

<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> 设计数据结构时如何先把结构的设想补全，细致的和大体的</h2>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> 关联数据结构和数据库</h2>
<div class="outline-text-2" id="text-20">
<p>
关联的对象是什么，一般而言是正交的两个数据居，索引的结果是软水。
</p>
</div>
</div>
<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> 关于虚拟设备</h2>
<div class="outline-text-2" id="text-21">
<p>
我们知道我们对于设备的认知，或者任何对象的认知取决于我们能获取的信息和改变的状态。对象也完全如此，我们完全可以只定义对象的接口，而使用不同的实现，而这个也是虚拟对象的前提，虚拟对象的前提。虚拟对象，所以没有可以想象的所有。
</p>
</div>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> 关于扩展结构体的理解</h2>
<div class="outline-text-2" id="text-22">
<p>
结构体对字段需要有哪些假设呢？这要看接口，有些接口必须要使用这个，一般是在最前面和最后面有假设，所以为结构体增加字段并不会导致结构体出现问题。 
</p>
</div>
</div>
<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> 关于对象复用的概念</h2>
<div class="outline-text-2" id="text-23">
<p>
对象复用其实引进了复杂度，而且往往是后续添加的优化，所以一般要保证复杂度相同。
</p>
</div>
</div>
<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> 关于阅读代码</h2>
<div class="outline-text-2" id="text-24">
<p>
阅读之前肯定需要理解程序的运行逻辑，也就是至少需要知道代码的运行方式，有一定的运行例子来支持。之后下一步就是阅读运行逻辑的代码。很多时候这个东西并不是一个程序的最重要的地方，但却是我们阅读代码的起点。需要注意的是我们阅读到那个深度停止。虽然问题就是这个问题。`我的想法是需要一定的文档支持，最为重要的是看到我们需要阅读的模块就差不多了。即便只有我们需要的模块和其他模块的关系其实也是足够的了。只有知道我们对于这个模块的修改会对实际的运行有那些影响，就可以了。如同我们看待函数一样，我们只要知道它是做什么的就可以了，这就是模块化。所以关键是先知道有那些模块，模块的功能和交流方式。之后才是我们需要深入的部分。
</p>
</div>
</div>
<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25"><span class="section-number-2">25</span> 关于一个函数的编写</h2>
<div class="outline-text-2" id="text-25">
<p>
一个函数的实现在不考虑调用的函数的情况下，其实我们需要在意的是算法层面的，而算法又有很多可以分成子算法。所以我们要看我们的理解，即便是主函数也应该这样。只是绑定的过程要比较多。有一点需要注意，函数的复杂度的问题。O(n)
</p>
</div>
</div>
<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26"><span class="section-number-2">26</span> 算法实现</h2>
<div class="outline-text-2" id="text-26">
<p>
算法的主要逻辑往往会比较简单，即便有些复杂，也可以把大的问题分解成为小的问题。一个算法往往一个最大的问题是简短，同时描绘足够的东西，这就要通过循环或者递归来达成，递归的分析相对简单。而循环需要完成对于循环不变量的分析。本质上没什么区别，都是使用归纳法的推理。其中循环在处理条件上有很多的麻烦点。
一个需要顾虑的点是如果有多个可能的终止条件，类似判断对错的算法可能有两种终止条件。
还有一个问题，就是对于当前状态，循环是要先检查还是后检查，目前大家倾向于先检查，原因是检查的代码不会有多少开销，即便重复也不会有多大问题，而如果后检查可能会导致有一个状态没有检查（初状态），当然偶尔也存在某些数据需要在检查时重复计算的情况，这个时候使用后检查可以降低开销。这个时候使用后检查也没什么不可以的，就是需要额外注意一下。
</p>
</div>
</div>
<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27"><span class="section-number-2">27</span> 关于闭包</h2>
<div class="outline-text-2" id="text-27">
<p>
闭包是函数的一种实现，Lua就是选用了这个策略的例子。
</p>
</div>
</div>
<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28"><span class="section-number-2">28</span> 开发</h2>
<div class="outline-text-2" id="text-28">
<p>
开发的一般情况不是从零开始完成，而是通常阅读别人写的代码，之后通过扩展这些代码完成自己的需求。
</p>
</div>
</div>
<div id="outline-container-sec-29" class="outline-2">
<h2 id="sec-29"><span class="section-number-2">29</span> 关于并发</h2>
<div class="outline-text-2" id="text-29">
</div><div id="outline-container-sec-29-1" class="outline-3">
<h3 id="sec-29-1"><span class="section-number-3">29.1</span> 竞态条件</h3>
<div class="outline-text-3" id="text-29-1">
<p>
过程式语言维护各种状态，在状态切换时时还有许多局部状态要维护，问题是在并发的情况下，状态切换过程一般是通用的不同的状态会产生不同的切换结果，而在并发条件下，如果切换结果可能被改变，那么就产生了竞态条件。关键就是状态切换过程被破坏。
</p>
</div>
</div>
<div id="outline-container-sec-29-2" class="outline-3">
<h3 id="sec-29-2"><span class="section-number-3">29.2</span> 并发程序的正确行为</h3>
<div class="outline-text-3" id="text-29-2">
<p>
在过程式语言中改变状态的操作只有一个，就是复制，也就是对于一般计算机结构的写内存的过程，由于这个操作一般指对应一条不可分割的指令，所以我们可以直接在编程语言层面对并发做限制。最严格的限制是对共享变量的操作不允许同时发生。但我们常常会5嫌弃这种做法的低效性，加锁的开销和风险常常困扰我们。所以又有不那么严格的限制，保证并发系统产生的结果与各个进程按照某种方式顺序运行长生出的结果一样，有时可以允许产生多于一个正确的结果。最后，类似于模拟扩散的过程我们完全可以不需要对变量作出任何限制，因为结果一定是收敛的。
</p>
</div>
</div>
<div id="outline-container-sec-29-3" class="outline-3">
<h3 id="sec-29-3"><span class="section-number-3">29.3</span> 控制并发的机制</h3>
<div class="outline-text-3" id="text-29-3">
<p>
我们把每个访问共享变量的行为看作一个事件，并发系统中这些事件可以交错执行，只要分析每种交错执行的结果就可以了，然而这种方法随着事件和进程数量的增加而变得无法控制。为了可以控制，我们拥有方法可以限制交错的行为，大大降低排列顺序的数目。从而保证程序有正确行为。
</p>
</div>
</div>
<div id="outline-container-sec-29-4" class="outline-3">
<h3 id="sec-29-4"><span class="section-number-3">29.4</span> 根本困难</h3>
<div class="outline-text-3" id="text-29-4">
<p>
时间和状态的问题，一直是一个比较麻烦的问题。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-30" class="outline-2">
<h2 id="sec-30"><span class="section-number-2">30</span> 关于包装和抽象</h2>
<div class="outline-text-2" id="text-30">
<p>
看过对于socket的包装和对于线程的包装，可惜如果作为包装来考虑，其实不好理解，因为必须要考虑socket或者线程的底层行为，但这样和抽象相悖。包装应该指的是接口级别的包装，不应该和抽象相互混淆。
</p>
</div>
</div>
<div id="outline-container-sec-31" class="outline-2">
<h2 id="sec-31"><span class="section-number-2">31</span> 数据结构的操作</h2>
<div class="outline-text-2" id="text-31">
<p>
对于过程式语言来说数据结构的操作其实比较简单，只要提供基本的几个就可以了。下面确定数据结构的状态集合，之后确定所有可行的状态转移。
对于查询而言，基本的复杂度是 \(O(n)\) ，然而，查询操作太过普遍，于是又出现了查询数据结构，但查询数据结构本身需要付出代价的，所以对于查询机会很少的应用，没必要使用查询数据结构。
数据结构存在状态变化，无论是结构还是内容，我们设计接口的目标是将状态变化都表现出来。接口的目标就是如此，然而状态的变化在没有合适的状态机来表示，而计算机是一个精细得多的计算设备，所以用汇编表述的时候免存在中间状态。 而中断会发生在这之间，这也是存在并发问题的原因。如果建立的每个状态机模型都是原子操作的也就没有了问题。或者只在一个进程中。单线程程序中其实不会有各种程序。
一个有趣的点是读和写，一个算法可以有读和写，但这是不方便的，编写程序的时候我们往往需要初始化的过程，这个过程其实就是之后读写的对象，同时运行的时候的局部作用域有时也需要我们构建，如果这个环境在栈中，就可以自动管理，如果在堆中要手动管理，这个就是自动变量，一般还是推荐使用函数的局部局部作用域，如果不影响代码的可读性，就可以使用块作用域。如果要把这个纳入考量，就是是否需要
</p>
</div>
</div>
<div id="outline-container-sec-32" class="outline-2">
<h2 id="sec-32"><span class="section-number-2">32</span> 状态驱动的编程</h2>
</div>

<div id="outline-container-sec-33" class="outline-2">
<h2 id="sec-33"><span class="section-number-2">33</span> 关于数据结构的简单分析</h2>
<div class="outline-text-2" id="text-33">
<p>
数据结构都有关键状态变化，只要把握关键状态变化即可其他的都是次要的，或者随之改变的。一个数据结构（容器比较重要），尤其是比较通用的数据结构要包含足够的定义信息，关键是你提供的数据结构需要多大的灵活性，哪些需要在在定义时就设置，对于外部来说数据结构有哪些状态变化。
</p>
</div>
</div>
<div id="outline-container-sec-34" class="outline-2">
<h2 id="sec-34"><span class="section-number-2">34</span> <span class="todo TODO">TODO</span> 关于函数调用链条如何达成所谓的分层？</h2>
<div class="outline-text-2" id="text-34">
<p>
数据是如何传输的？
</p>
</div>
</div>
<div id="outline-container-sec-35" class="outline-2">
<h2 id="sec-35"><span class="section-number-2">35</span> <span class="todo TODO">TODO</span> 关于运行，抽象运行这个概念需要的最少概念</h2>
</div>
<div id="outline-container-sec-36" class="outline-2">
<h2 id="sec-36"><span class="section-number-2">36</span> 错误</h2>
<div class="outline-text-2" id="text-36">
<p>
过早考虑软件的类似名字空间和符号的管理这个东西其实有些不好，一般依照一般的组织原则就可以了。
</p>
</div>
</div>
<div id="outline-container-sec-37" class="outline-2">
<h2 id="sec-37"><span class="section-number-2">37</span> 关于粘合剂量</h2>
</div>

<div id="outline-container-sec-38" class="outline-2">
<h2 id="sec-38"><span class="section-number-2">38</span> 关于编写项目</h2>
<div class="outline-text-2" id="text-38">
<p>
最根本的当然是完成一个虚拟机，达成对于计算机的所有抽象，而平常编写程序无非只是其中的一个部件或者整个虚拟机而已。最高级别的当然是一个可以执行的虚拟机。
</p>
</div>
</div>
<div id="outline-container-sec-39" class="outline-2">
<h2 id="sec-39"><span class="section-number-2">39</span> 开发的原因</h2>
</div>

<div id="outline-container-sec-40" class="outline-2">
<h2 id="sec-40"><span class="section-number-2">40</span> 关于阅读项目代码结构</h2>
<div class="outline-text-2" id="text-40">
<ul class="org-ul">
<li>如何分模块（这是基本组件）
</li>
<li>如何通信（这是粘合剂）
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-41" class="outline-2">
<h2 id="sec-41"><span class="section-number-2">41</span> 前条件需要需要处理</h2>
<div class="outline-text-2" id="text-41">
<p>
一个不能预知外界环境的系统会需要大量能检测前条件的接口，剩下的只能依靠计算机了。
</p>
</div>
</div>
<div id="outline-container-sec-42" class="outline-2">
<h2 id="sec-42"><span class="section-number-2">42</span> 不要重复自身</h2>
<div class="outline-text-2" id="text-42">
<p>
这个其实不是一开始决定的
</p>
</div>
</div>
<div id="outline-container-sec-43" class="outline-2">
<h2 id="sec-43"><span class="section-number-2">43</span> 核心的问题是关系，各种对象的关系，问题</h2>
<div class="outline-text-2" id="text-43">
<p>
问题经常有不同的层面，类似树，读的时候就是内部状态变化，树是状态转移表，而如果是add这种操作，我们操作的状态就是树了。                             
</p>
</div>
</div>
<div id="outline-container-sec-44" class="outline-2">
<h2 id="sec-44"><span class="section-number-2">44</span> 自底向上</h2>
<div class="outline-text-2" id="text-44">
<p>
现在看来传统的自底向上和自顶向下的争论意义不大，关键是状态的构建和状态的转化，如果状态转化的基础构建不行，那么何从测试呢？所以先是基础状态机的构建，至于某些基础接口的设计是之后的事情。
</p>
</div>
</div>
<div id="outline-container-sec-45" class="outline-2">
<h2 id="sec-45"><span class="section-number-2">45</span> 关于状态转移和接口</h2>
<div class="outline-text-2" id="text-45">
<p>
内部的恶状态状态转移要清晰，但是接口是否要暴露这是后面的事情。一开始全部清晰一点比较好。
本质上接口都会对于对象状态有限制，我们包装的时候要注意这一点。
</p>
</div>
</div>
<div id="outline-container-sec-46" class="outline-2">
<h2 id="sec-46"><span class="section-number-2">46</span> 前条件就是状态</h2>
<div class="outline-text-2" id="text-46">
<p>
条件的选择其实要复杂地多
</p>
</div>
</div>
<div id="outline-container-sec-47" class="outline-2">
<h2 id="sec-47"><span class="section-number-2">47</span> <span class="todo TODO">TODO</span> 能构建状态的自动机是否算是图灵完备的机器</h2>
</div>
<div id="outline-container-sec-48" class="outline-2">
<h2 id="sec-48"><span class="section-number-2">48</span> 副作用和主逻辑</h2>
<div class="outline-text-2" id="text-48">
<p>
一个程序中可能会用到各种复杂的算法，交错在一起让人迷惑，所以应该把握主要的矛盾其实，主要关心主体逻辑就可以了，哪些是副作用才是我们关心的。
</p>
</div>
</div>
<div id="outline-container-sec-49" class="outline-2">
<h2 id="sec-49"><span class="section-number-2">49</span> 编写项目</h2>
<div class="outline-text-2" id="text-49">
<p>
一开始还是以模仿为主，所以受限于这种思维，其实编程不是这样的，所以现在的想法是先搞清除主流程之后才是，处理各个模块。在不同的阶段考虑不同的东西，粒度也会有所不同。
定义的位置应该和使用的位置相近。
</p>
</div>
</div>
<div id="outline-container-sec-50" class="outline-2">
<h2 id="sec-50"><span class="section-number-2">50</span> 异步和同步</h2>
<div class="outline-text-2" id="text-50">
<p>
异步的eventloop其实类似于自动机，不断获取输入作为事件来推进状态转移。而同步代码则有所不同，其状态转移取决于当前状态是否“完全”（这里认为一个完全的状态是可以计算出下一个状态的），像如果需要用户输入，那么必须到得到了用户的数据之后状态才可以完全。
</p>
</div>
</div>
<div id="outline-container-sec-51" class="outline-2">
<h2 id="sec-51"><span class="section-number-2">51</span> 阅读代码以及二次开发</h2>
<div class="outline-text-2" id="text-51">
<p>
直接开代码其实是不对的，要先运行，之后不断添加日志和输出才是最佳的阅读手段，而补充不断脑补，因为可能是错的。
</p>
</div>
</div>
<div id="outline-container-sec-52" class="outline-2">
<h2 id="sec-52"><span class="section-number-2">52</span> 协程</h2>
<div class="outline-text-2" id="text-52">
<p>
协程是子程序的一个更加通用的形式，子程序可以在一个点进入，之后在另一个点离开。协程可以在任意一点进入、离开和重新开始。
</p>
</div>
</div>
<div id="outline-container-sec-53" class="outline-2">
<h2 id="sec-53"><span class="section-number-2">53</span> 接口</h2>
<div class="outline-text-2" id="text-53">
<p>
一个接口的实现应该是当前是哪个或哪些状态，使用哪个状态转移，至于自动机的输入，就是函数的接口中了。
</p>
</div>
</div>
<div id="outline-container-sec-54" class="outline-2">
<h2 id="sec-54"><span class="section-number-2">54</span> 常态</h2>
<div class="outline-text-2" id="text-54">
<p>
一个软件如何达到其常态是除了模块化之后最重要的部分了。
</p>
</div>
</div>
<div id="outline-container-sec-55" class="outline-2">
<h2 id="sec-55"><span class="section-number-2">55</span> 零散</h2>
<div class="outline-text-2" id="text-55">
<ul class="org-ul">
<li>现代语言的运行和语言的特性息息相关，以C语言为例，变量的定义带来的是运行时它可以占有一个固定的内存空间。
</li>
<li>现代编程语言的编译结果是运行时描述，这是最基础的描述
</li>
<li>表达式的特性是只有一个返回值
</li>
<li>其实现代的设备的编译结果：汇编语言已经是最灵活的压缩格式了。最重要的是对于内存地址的直接访问，可以实现足够细的粒度上的代码复用
</li>
<li>异常的状态一个就够了。
</li>
<li>对于贴近操作系统的编程，没有副作用是不现实的。
</li>
<li>值传递和引用传递的区别，在于行为上的区别，传递一个变量的值还是传递一个表达式的值
</li>
<li>我们知道对象在创建时要调用构造函数，但是这其实会导致效率的问题，因为调用函数
</li>
<li>C语言放回值为void的函数本身就意味着这不是一个计算过程，即使它使用的一个计算过程。
</li>
<li>一个状态下不断进行的行为，如果不改变自身状态，就只是计算而已
</li>
<li>求值所依赖的条件是什么，同样一个求职的过程，如何使他求值的结果发生改变，如何使其不变。如果求值过程不变，就会导致就会导致。
</li>
<li>为什么要自己定义别名呢，原因是如果有什么改变，如类型或者数据结构定义，我们很多时候也只要改动部分而已，而且也往往只是抽象层次的较底层。
</li>
<li>单向链表的粘合剂是next指针。
</li>
<li>什么状态转移，有了异常检查状态转移的描述就简洁多了，不过问题就变成了是否要及。
</li>
<li>转移和状态识别不知道要不要放到一块。一开始还是不喜欢放到一块，这样比较自底向上。
</li>
<li>锁可以在大范围内构建状态，比如独占的状态和松开的状态，这对于对象来说是全局状态之一。
</li>
<li>可以先只写转移，之后添加转移条件。
</li>
<li>读往往只会涉及到内部状态转移，而不会涉及到外部状态转移，所以条件由内部维护
</li>
<li>所谓不学无术啊。。。很多东西学习新概念自然就懂了。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-56" class="outline-2">
<h2 id="sec-56"><span class="section-number-2">56</span> 参考</h2>
<div class="outline-text-2" id="text-56">
<ul class="org-ul">
<li><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="external">什么是函数式编程思维 知乎</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Matplotlib学习笔记]]></title>
      <url>/2017/05/08/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <span class="todo TODO">TODO</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
pylab是Matplotlib的一个模块，不过一般用于交互时使用，提供了和Matlab类似的环境，默认导入了matplotlib、numpy等其他有用的库。如果不在交互环境下，就没必要使用。一般实验时还是有用的，不过在org-mode中价值好像又进一步降低了。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 初级绘制</h2>
<div class="outline-text-2" id="text-2">
<p>
先绘制简单的图，并保证能在网页上显示:
</p>
<div class="org-src-container">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y, label=<span class="string">"$sin(x)$"</span>, color=<span class="string">"red"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Time(s)"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Volt"</span>)</span><br><span class="line">plt.title(<span class="string">"函数$sin(x^2)$"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">pic_filename = <span class="string">"sin.png"</span></span><br><span class="line">path = <span class="string">'./Matplotlib学习笔记/'</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">'{}{}'</span>.format(path, pic_filename))</span><br><span class="line">print(<span class="string">"#+caption: 第一幅图"</span>)</span><br><span class="line">print(<span class="string">"[[{}{}]]"</span>.format(path, pic_filename))</span><br></pre></td></tr></table></figure>
</div>


<div class="figure">
<p><img src="./Matplotlib学习笔记/sin.png" alt="sin.png">
</p>
<p><span class="figure-number">Figure 1:</span> 第一幅图</p>
</div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 参考</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li><a href="http://old.sebug.net/paper/books/scipydoc/index.html" target="_blank" rel="external">Python科学计算</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Matplotlib </category>
            
        </categories>
        
        
        <tags>
            
            <tag> visualization </tag>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Graphviz学习笔记]]></title>
      <url>/2017/05/08/Graphviz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
Graphviz 是一个开源的图可视化工具，非常适合绘制结构化的图标和网络。Graphviz 使用一种叫 DOT 的语言来表示图形。本文主要记录了如何使用dot语言的一些实例。
Graphviz能供我们定义的图形元素有3种：
</p>
<ul class="org-ul">
<li>图
</li>
<li>定点
</li>
<li>边
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 图形类型</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>有向图
</li>
<li>无向图
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> dot语言和图片实例</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 顺序图</h3>
<div class="outline-text-3" id="text-3-1">
<p>
先尝试生成最简单的顺序图：
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">digraph g {&#10;      a-&#62;b&#10;      b-&#62;c&#10;      c-&#62;d&#10;}</span><br></pre></td></tr></table></figure>
</div>

<p>
使用编译指令:
</p>
<div class="org-src-container">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dot -Tpng test.dot -o test.png</span><br></pre></td></tr></table></figure>
</div>
<p>
可以得到以下图片：
</p>

<div class="figure">
<p><img src="seq_diagram.png" alt="seq_diagram.png">
</p>
</div>
<p>
可以看到，默认的顺序图是从上到下的。也可以让这幅图从左往右排列，代码修改如下：
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">digraph g {&#10;    rankdir=LR&#10;&#10;    a-&#62;b&#10;    b-&#62;c&#10;    c-&#62;d&#10;}</span><br></pre></td></tr></table></figure>
</div>
<p>
可见，是从上往下还是从左往右取决于rankdir这个全局变量。
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 带有子图的绘图要点</h3>
<div class="outline-text-3" id="text-3-2">
<p>
一大要点是带有子图的名字要带有cluster作为前缀。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> record定义</h2>
<div class="outline-text-2" id="text-4">
<p>
record是可以自由定义区域内容的节点，而且每个区域可以有独立的箭头。
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">digraph g {&#10;&#9;struct1 [shape = Mrecord, label = &#34; &#60;f0&#62; left | &#60;f1&#62; mid | &#60;f3&#62;right&#34;]&#10;&#9;struct1:f1 -&#62; B&#10;&#9;struct1:f3 -&#62; C&#10;&#9;B -&#62; C&#10;}</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 画板</h2>
<div class="outline-text-2" id="text-5">

<div class="figure">
<p><img src="Graphviz学习笔记/record.png" alt="record.png">
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> <span class="todo TODO">TODO</span> 使用Python生成复杂的图</h2>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> <span class="todo TODO">TODO</span> 收集常用的图片素材方便作为节点</h2>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 要点</h2>
<div class="outline-text-2" id="text-8">
<p>
rankdir会定义方向，之后就是根据定义节点的顺序来显示，而不是节点的逻辑结构。这个还需要不断实践。
</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 参考</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li><a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-graphviz/" target="_blank" rel="external">使用 Graphviz 生成自动化系统图</a>
</li>
<li><a href="https://casatwy.com/shi-yong-dotyu-yan-he-graphvizhui-tu-fan-yi.html" target="_blank" rel="external">使用DOT语言和Graphviz绘图(翻译)</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Graphviz </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Graphviz </tag>
            
            <tag> visualization </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编写网页文档]]></title>
      <url>/2017/05/07/%E7%BC%96%E5%86%99%E7%BD%91%E9%A1%B5%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
本文旨在记录使用org-mode做自动化报告的过程，当然，不搞学术所以也没想弄成pdf，只要网页能显示对我来说就足够了。我把所有能用到的都使用一遍，作为今后的一个参照。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> <span class="todo TODO">TODO</span> 在网页中显示图片</h2>
<div class="outline-text-2" id="text-2">
<p>
为了解决hexo图片路径和org-mode冲突的问题，需要安装
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 嵌入程序</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 启动嵌入代码的功能</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Emacs支持在org-mode中嵌入代码，目前支持的代码的类型包括：
\[a+b=c\]
<img src="./编写网页文档/org-suport-languages.png" alt="org-suport-languages.png">
启动语言支持的方法是在初始化文件加入如下代码
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">(org-babel-do-load-languages</span><br><span class="line">'org-babel-load-languages</span><br><span class="line">`((R . t)</span><br><span class="line">  (ditaa . t)</span><br><span class="line">  (dot . t)</span><br><span class="line">  (emacs-lisp . t)</span><br><span class="line">  (gnuplot . t)</span><br><span class="line">  (haskell . nil)</span><br><span class="line">  (latex . t)</span><br><span class="line">  (ledger . t)</span><br><span class="line">  (ocaml . nil)</span><br><span class="line">  (octave . t)</span><br><span class="line">  (python . t)</span><br><span class="line">  (ruby . t)</span><br><span class="line">  (screen . nil)</span><br><span class="line">  (,(if (locate-library "ob-sh") 'sh 'shell) . t)</span><br><span class="line">  (sql . nil)</span><br><span class="line">  (sqlite . t))))</span><br></pre></td></tr></table></figure>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 嵌入Python代码</h3>
<div class="outline-text-3" id="text-3-2">
<p>
关键在于对org-babel的使用，前面启动好了以后，为了让它可以在网页和org文件中同时显示要做一点额外的事情。先看一个实例
</p>
<div class="org-src-container">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> sin, pi, linspace</span><br><span class="line">t = linspace(<span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span>)</span><br><span class="line">pl.plot(t, sin(t))</span><br><span class="line">pic = <span class="string">'plot_test.png'</span></span><br><span class="line">pl.savefig(<span class="string">"./编写网页文档/{}"</span>.format(pic))</span><br><span class="line">print(<span class="string">"#+caption: test python plot"</span>)</span><br><span class="line">print(<span class="string">'[[./编写网页文档/{}]]'</span>.format(pic))</span><br></pre></td></tr></table></figure>
</div>


<div class="figure">
<p><img src="./编写网页文档/plot_test.png" alt="plot_test.png">
</p>
<p><span class="figure-number">Figure 1:</span> test python plot</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 参考</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><a href="http://dayigu.github.io/OrgModeAndLiterateProgramming.html" target="_blank" rel="external">org-mode, “文学编程” , 自动化报告</a>
</li>
<li><a href="http://orgmode.org/org.html" target="_blank" rel="external">org-mode官方文档</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Emacs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Emacs使用]]></title>
      <url>/2017/03/31/Emacs%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 配置</h2>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 借助ssh在远程主机上开发</h2>
<div class="outline-text-2" id="text-2">
<p>
一般把编译环境搭建在服务器或虚拟机上，但是我的编程环境在本地，所以文件共享是必要的。Tramp mode正好解决了这个痛点。
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Tramp Mode开发</h3>
<div class="outline-text-3" id="text-2-1">
<p>
C-x C-f /ssh:username@server.net:path/to/file.txt
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 借助ftp在远程主机上开发</h2>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 串口功能</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">M-x serial-term</span><br></pre></td></tr></table></figure>
</div>
<p>
如果是USB转串口，一般是/dev/ttyUSB0。
stackoverflow有人给出了基本的使用，而官方文档没有
</p>
<blockquote>
<p>
I'm not sure how GNU screen fits into the equation but have a look at serial-term.Use C-c C-k to go to char mode and C-c C-j to go to line mode (where your normal bindings apply).Killing the buffer closes the port (C-c k in char mode, C-x k in line mode).
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> C/C++代码索引</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> rtags</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> 为项目制作编译数据库</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
rtags需要一个compile_commands.json文件去告诉rdm（rtags的服务器）实际如何编译源代码。如果使用的cmake，可以在加上-DCMAKE_EXPORT_COMPILE_COMMANDS=1来生成这个文件。
</p>
</div>
</div>
<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> rtags补全的问题</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
rtags无法实时补全，是rtags的最大缺点。我的解决方法保存了修改之后重启rdm，
为了方便我直接绑定了了快捷键。
</p>
</div>
</div>
<div id="outline-container-sec-5-1-3" class="outline-4">
<h4 id="sec-5-1-3"><span class="section-number-4">5.1.3</span> 无法检索本文件中的内容以及无法实时将文本的更改加入索引中</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
这个问题是由于没有安装flycheck-rtags所致，这也说明rtags对于flcyeck-rtags1有依赖，安装上了之后功能提升了很多，每安装前对于static函数的索引都会出问题。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 使用rc来高速rdm你的项目位置</h3>
<div class="outline-text-3" id="text-5-2">
<p>
rc是一个rtags指令，用于告诉rdm你的path。
</p>
<div class="org-src-container">

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rc -J /path/complie_commands/</span><br></pre></td></tr></table></figure>
</div>
<p>
<code>-J</code> 参数 指出包含compile_commands.json文件的目录。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Emacs 快捷键总结</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 前言</h3>
<div class="outline-text-3" id="text-6-1">
<p>
随着使用插件不断增加，我的快捷键冲突问题以及不一致问题一直困扰着我，所以需要归纳一些
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 时间管理功能 agenda</h2>
<div class="outline-text-2" id="text-7">
<p>
我们会在各种org文件里面写入TODO条目，TODO条目还可以打上任务开始时间（SCHEDULED）和任务结束时间（DEADLINE）
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 参考</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li><a href="https://www.emacswiki.org/emacs/TrampMode" target="_blank" rel="external">TrampMode</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> Emacs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C编程及调试工具]]></title>
      <url>/2017/01/18/C%E7%BC%96%E7%A8%8B%E5%8F%8A%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
本文只记录工具的基本使用，至于原理什么的看参考文献即可。
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Core Dump处理</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 处理core dump</h3>
<div class="outline-text-3" id="text-2-1">
<p>
列出所有导致core dump的程序：
</p>
<div class="org-src-container">

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">coredumpctl list</span><br></pre></td></tr></table></figure>
</div>
<p>
如果要找到特定的dumnp，可以使用在后面加上PID、可执行文件名、可执行文件路径。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 入口函数</h2>
<div class="outline-text-2" id="text-3">
<p>
入口函数是不会返回的，因为它本身会调用进程推出函数。按我的想法，入口函数其实不算一个函数，初始阶段并没有达成抽象的基础。把它当作一段命名的指令序列即可。它做的事情是初始化程序环境、调用main函数，main返回后清理运行资源。
所以CRT（C运行时库）要做的事情有两样，为运行提供抽象，提供抽象需要计算机资源，所以当程序不需要运行的时候，要释放这些资源。
</p>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 参考文献</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li><a href="http://www.cnblogs.com/hazir/p/linxu_core_dump.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/p/linxu_core_dump.html</a>
</li>
<li><a href="https://wiki.archlinux.org/index.php/Core_dump" target="_blank" rel="external">https://wiki.archlinux.org/index.php/Core_dump</a>
</li>
</ul>
</div>
</div>

Last Updated 2018-03-04 日 03:01.<br>Render by <a href="https://github.com/CodeFalling/hexo-renderer-org" target="_blank" rel="external">hexo-renderer-org</a> with <a href="http://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a> 25.3.1 (<a href="http://orgmode.org" target="_blank" rel="external">Org</a> mode 8.2.10)
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
